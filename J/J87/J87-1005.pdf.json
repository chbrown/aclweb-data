{"sections":[{"title":"","paragraphs":["AN ALGORITHM FOR GENERATING QUANTIFIER SCOPINGS Jerry R. Hobbs and Stuart M. Shieber","Artificial Intelligence Center SRI International","Menlo Park, CA 94025","and","Center for the Study of Language and Information Stanford University Stanford, CA 94305 The syntactic structure of a sentence often manifests quite clearly the predicate-argument structure and relations of grammatical subordination. But scope dependencies are not so transparent. As a result, many systems for representing the semantics of sentences have ignored scoping or generated scopings with mechanisms that have often been inexplicit as to the range of scopings they choose among or profligate in the scopings they allow.","This paper presents, along with proofs of some of its important properties, an algorithm that generates scoped semantic forms from unscoped expressions encoding predicate-argument structure. The algorithm is not profligate as are those based on permutation of quantifiers, and it can provide a solid foundation for computational solutions where completeness is sacrificed for efficiency and heuristic efficacy. 1 INTRODUCTION A principal focus of computational linguistics, as a branch of computer science, ought to be the design of algorithms. A large number of algorithms have undoubtedly been devised for dealing with problems every researcher has to face in constructing a natural language system, but they simply have not received wide circulation. These algorithms are part of the \"folk culture\", buried in the most technical, unreadable portions of theses, passed among colleagues informally at best, and often reinvented. It should be a practice to publish these algorithms in isolation, independent of a particular implementation or system.","This paper constitutes an effort to initiate such a practice. A problem that many natural-language efforts have faced is the recovery of implicit semantic scope dependency possibilities - such as those manifest in quantifiers and modals - from predicate-argument relations and relations of grammatical subordination, which are more or less transparently conveyed by the syntactic structure of sentences. Previous computational efforts typically have not been based on an explicit notion of the range of possible scopings. In response to this problem, we present an algorithm that generates quantifier scopings for English sentences. I.I THE PROBLEM OF GENERATING QUANTIFIER SCOPINGS The naive algorithm for generating quantifier scopings is to generate all permutations of the quantifiers. For a sentence with n quantified noun phrases this will generate n! different readings. But for the sentence","(1) Every representative of a company saw most samples. there are not six different readings, but only five. The reading that is missing is the one in which most samples is outscoped by every representative but outscopes a company. A model for the disallowed reading could include a different company not only for each representative but also for each sample.","The reduction in number of readings for a given sentence is not significant for sentence (1), but in the sentence","(2) Some representative of every department in most companies saw a few samples of each product. there are only 42 valid readings, as opposed to the 120 readings the naive algorithm would generate, and this Copyright1987 by the Association for Computational Linguistics. Permission to copy without fee all or part of this material is granted provided that the copies are not made for direct commercial advantage and the CL reference and this copyright notice are included on the first page. To.copy otherwisc, or to republish, requires a fee and/or specific permission. 0362-613X/87/010047-63503.00 Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 47 Jerry R. Hobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Scopings constitutes a significant difference indeed. The recent trend in computational linguistics has been to view more and more noun phrases, as well as other constituents, as introducing quantifiers, so that sentences with this much quantificational complexity are not at all unusual. (The immediately preceding sentence, for example, has six or seven quantifiers.)","This observation of \"illegitimate readings\" is not intended as a new or controversial claim about an idiosyncrasy of English. It accords well with semantic judg-ments about the possibility of such readings. For instance, we find it impossible to view sentence (1) as expressing that for each representative there was a group of most samples which he saw, and furthermore, for each sample he saw, there was a company he was a representative of.","We can find the same problem of illegitimate readings in the standard account of the \"Cooper storage\" mechanism for generating quantifier scopings (Cooper 1983). Cooper's method generates an expression in intensional logic for the illegitimate readings, but the expression contains an unbound variable and a vacuous quantifier. 1","Finally, the observation follows merely syntactically from the ill-formedness of certain logical form expressions. Let us examine why this is so. The propositional content of a sentence can be seen as combining specifications that restrict the range of quantified entities, together with assertions about the entities so specified. This intuition is often made formal in the use of logical languages that syntactically separate the notion of the range of a quantified expression from its scope by placing the information about the range in a part of the expression we call the restriction and the assertions in a part called the body. (Henceforth, we will uniformly use the terms restriction and body.) The separation of these two semantic roles of range and scope into restriction and body as an important fact of the logical structure of English can be seen, for example, in Woods's four-part quantifier structures (Woods 1977), in the recommendations of Moore (1981), and in the generalized quantifier research of Barwise and Cooper and others. The latter have demonstrated the necessity of such a separation for quantifiers other than the standard first-order ones (Barwise and Cooper, 1981 ; Cushing, 1976).","But under this understanding of English logical structure, it follows that no sixth reading exists for sentence (1) above. Consider the reading in which the universal outscopes the most which outscopes the existential in the logical form for this sentence. Then, using the notation of Moore (1981) for four-part quantifier structures, the logical form must have the following structure: all(r, representative(r) ....... ) since the universal is outermost. Now the existential is within the scope of the universal by hypothesis, and since it provides a restriction on the range of the variable r, it must occur in the restriction of the quantifier. Thus, we have:","all(r, representative(r) & some(c, company(c), of(c,r)) .... saw(r,s)...) But where can the quantifier most be put to bind the variable s corresponding to the samples seen? It must outscope its occurrence in the body of the universal, but it must also by hypothesis outscope the existential in the restriction of the universal. To outscope both, it must outscope the universal itself, but this violates the assumed scope relations. Thus, no such reading is possible. By a similar argument, it follows from the logical structure of English that in general a quantifier from else-where in a sentence cannot come after the quantifier associated with a head noun and before the quantifier associated with a noun phrase in the head noun's complement.","Most research in linguistic semantics, e.g., Montague (1973) and Cooper (1983), has concentrated on explicit-ly defining the range of possible scope relationships that can be manifested in sentences. But, to our knowledge, all fall prey to the profligacy of generation just outlined. 1.2 OTHER ISSUES IN QUANTIFIER SCOPING 1.2.1 OTHER SPURIOUS SCOPINGS We are concerned here only with suppressing readings that are spurious for purely structural reasons, that is, for reasons that follow from the general relationship between the structure of sentences and the structure of their logical forms and independent of the meanings of the particular sentences. For instance, we are not concerned with logical redundancies, such as those due to the commutativity of successive universal quantifiers. When we move beyond the two first-order logical quantifiers to deal with the so-called generalized quantifiers such as most, these logical redundancies become quite rare. Similarly, we are not concerned with the infelicity of certain readings due to lexical semantic or world knowledge, such as the fact that a child cannot outscope every man in the sentence I've met a child of every man in this room. 1.2.2 HEURISTICALLY PRIMARY SCOPINGS Computational research on quantifier scoping has emphasized generating a single scoping, which can be thought of as heuristically primary, as discussed by, for example, Woods (1977), Pereira (1983), and Grosz et al. (1985). We are concerned not with generating the best reading but with generating all readings. The reader may object that it is inappropriate in a practical natural language system to generate scopings one by one for testing against semantic and pragmatic criteria. Instead, one should appeal to various heuristics to generate only the most likely reading, or at least to generate readings in order of their plausibility. These include the following: • lexical heuristics, e.g., each usually outscopes some; • syntactic heuristics, e.g., a noun phrase in a relative","clause is usually outscoped by the head noun, and a","noun phrase in a prepositional phrase complement of a 48 Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 Jerry R. Hobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Scopings","relational head noun usually outscopes the head noun;","and • ordering heuristics, such as the principle that left-to-","right order at the same syntactic level is generally","preserved in the quantifier order. 2","We are sympathetic with this view. Nevertheless, there are several reasons that codifying a complete algorithm remains useful. First, a complete and sound algorithm provides a benchmark against which other approaches can be tested. Second, one may actually wish to use a generate-and-test mechanism in simpler implementations, and it should be correct and as efficient as possible. It should not generate scopings that can be ruled out on purely structural grounds. Finally, the algorithm we present might be modified to incorporate heuristics to generate scopings in a certain order or only certain of the scopings. The soundness and correctness of the underlying algorithm, provide a guarantee of soundness for a heuristically guided version. We include a few comments below about incorporating ordering heuristics into our scoping generation algorithm, although we should point out that the possibilities are somewhat limited due to the local nature of where the heuristics can be applied. A full discussion of heuristically-guided scoping generation is, of course, beyond the scope of this paper. 1.2.3 SCOPE OF OPAQUE PREDICATES In addition to handling the scoping of quantifiers relative to each other, the algorithm we present also allows quantifiers to be scoped within or outside of opaque arguments of higher-order predicates. For instance, the algorithm generates two readings for the sentence Everyone isn't here. corresponding to the two relative scopings of the universal quantifier and the negation. 2 THE ALGORITHM In the discussion below, we assume that parsing has made explicit the predicate-argument relations and the relations of grammatical subordination in the form of a logical encoding in an input language. A well-formed formula (wff) in the input language is a predicate or other operator applied to one or more arguments. An argument can be a constant or variable, another wff, or what we will call a complex term. A complex term is an ordered triple consisting of a quantifier, a variable, and a wff (called the restriction), which represents the predication that is grammatically subordinated to the variable. The input representation for sentence (2) is, then, the following (ignoring tense):","see(<some r","and(rep(r), of(r,<every d","and(dept(d),","in(d,<most c co(e)>))>))>,","<a-few s and(samp(s),","of(s,<each p prod(p)>))>) A complex term can be read \"quantifier variable such that restriction\", e.g., \"most c such that c is a company\".","The output language is identical to the input language, except that it does not contain complex terms. Quantifiers are expressed in the output language as operators that take three arguments: the variable bound by the quantifier, a wff restricting the range of the quantified variable, and the body scoped by the quantification, schematically quantifier(variable, restriction, body) This encoding of quantification is the same as that found in Woods (1977) and Moore (1981). We will refer to such expressions as quantified wffs. Thus, one reading for sentence (2) is represented by the following quantified wff:","some(r, and(rep(r),","every(d, and(dept(d),","most(c, co(c),","in(d, c))), of(r, d))),","a-few(s, and(samp(s), each(p, prod(p),","of(s, p))), see(r, s))) Intermediate structures built during the course of scoping include both complex terms and quantified wffs. We use the term full seoping for an expression in the output language, i.e., one that has no complex terms.","We also will use the terms bound and free as follows: An expression binds a variable v if the expression is of the form < q v r > or q(v, r,s) where q is a quantifier. The variable v is said to be bound in the expressions r, or r and s, respectively. A variable v is unbound or free in an expression a if there is an occurrence of v in a that is not also an occurrence in a subexpression of a binding v. Note that here quantified wffs and complex terms are both thought of as expressions binding a variable. 2.1 SUMMARY OF THE ALGORITHM We present both nondeterministic and deterministic versions of the algorithm 3 in an ALGOL-like language. Both algorithms, however, have the same underlying structure, based on the primitive operation of \"applying\" a complex term to a wff in which it occurs: a complex term in a wff is replaced by the variable it restricts, and that variable is then bound by wrapping the entire form in the appropriate quantifier. Thus, applying the term < q x r(x) > to a wff containing that complex term, say, p( < q x r(x) > ), yields the quantified wff Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 49 Jerry R. Hobbs and Sluart M. Shieber An Algorithm for Generating Quantifier Scopings"]},{"title":"q(x,","paragraphs":["r(x),p(x)). This is the primitive operation by which complex terms are removed from a wff and quantified wffs are introduced. It is implemented by the function"]},{"title":"apply.","paragraphs":["The generation of a scoping from a wff proceeds in two stages. First, the opaque argument positions within the wff are scoped. The function"]},{"title":"pull-opaque-args","paragraphs":["performs this task by replacing wffs in opaque argument positions by a (full or partial) scoping of the original wff. For instance, if p were a predicate opaque in its only argument, then, for the wff"]},{"title":"p(s(<qxr(x) > )), pull-opaque-args","paragraphs":["would generate the wff"]},{"title":"p(q(x, r(x), s(x)))","paragraphs":["or the unchanged wff"]},{"title":"p(s( < qx r(x)","paragraphs":["> )). In the former, the opaque predicate p outscopes the quantifier q. In the latter, the quantifier q has not been applied yet and the wff will subsequently yield readings in which q has wider scope than p.","Second, some or all of the remaining terms are applied to the entire wff. The function"]},{"title":"apply-terms","paragraphs":["iteratively (through a tail recursion) chooses a complex term in the wff and applies it. Thus"]},{"title":"apply-terms","paragraphs":["acting upon the wff"]},{"title":"P( < ql x q(x) > , < qzY","paragraphs":["r2(Y) > ) will yield one of the five wffs"]},{"title":"P( < qlxrl(x) >, < q2Yr2(Y) >) qlCX,","paragraphs":["rl(x),"]},{"title":"p(x, < q2Yr2(Y) > ))","paragraphs":["q2(Y, r2(Y), P( < ql x rl(x) > , y)) q2(y, r2(Y),"]},{"title":"ql(x,","paragraphs":["rl(x),"]},{"title":"p(x, y))) ql(x,","paragraphs":["rl(x), q2(v, r2(Y),"]},{"title":"p(x, y)))","paragraphs":["depending on how many quantifiers are applied and in what order. The choice of a complex term is restricted to a subset of the terms in the wff, the so-called applicable terms. The principal restriction on applicable terms is that they not be embedded in any other complex term in the wff. Section 4.1 discusses a further restriction. The function"]},{"title":"applicable-term","paragraphs":["returns an applicable term in a","given wff. These two stages are manifested in the function"]},{"title":"pull","paragraphs":["which generates all partial or full scopings of a wff by invoking"]},{"title":"pull-opaque-args","paragraphs":["and"]},{"title":"apply-terms.","paragraphs":["Since ultimately only full scopings are desired, an additional argument to"]},{"title":"pull","paragraphs":["and"]},{"title":"apply-terms","paragraphs":["controls whether partial scopings are to be returned. When this flag,"]},{"title":"completeL","paragraphs":["is"]},{"title":"true, apply-terms,","paragraphs":["and hence"]},{"title":"pull","paragraphs":["will return only expressions in which no more complex terms remain to be applied, for example, only the last two of the five readings above.","Finally, the restrictions of the complex terms may themselves contain complex terms and must be scoped themselves. The"]},{"title":"apply","paragraphs":["function therefore recursively generates the scopings for the restriction by calling"]},{"title":"pull","paragraphs":["on that restriction, and a quantified wff is generated for each possible partial or complete scoping of the restriction. Schematically, in the simplest case, for the expression"]},{"title":"p( < ql x rl(x, < q2y r2fy)","paragraphs":["> ) and its complex term < ql -.. > ,4"]},{"title":"apply","paragraphs":["generates the complete scoping"]},{"title":"ql(x,","paragraphs":["q2(Y, r2(Y),"]},{"title":"rl(x,y)), p(x))","paragraphs":["(having called"]},{"title":"apply","paragraphs":["recursively on < q2 ... > ), and the partial scoping"]},{"title":"ql(x, rl(x , < q2Yr20,) > ), p(x))","paragraphs":["A subsequent application of the remaining complex term will yield .the \"wide scope\" reading q2(.v, r2(Y),"]},{"title":"ql (x, rl (xy), P(X) )","paragraphs":["The disallowed readings produced by the \"all permutations\" algorithm are never produced by this algorithm, because it is everywhere sensitive to the four-part quantifier structure of the target logical form.","The difference between the nondeterministic and deterministic versions lies only in their implementation of the choice of terms and returning of values. This is done either nondeterministically, or by iterating through and returning explicit sets of possibilities. A nondeterministic Prolog version and a deterministic COMMON LISP version of the algorithm are given in Appendices A and B. The full text of these versions (including auxiliary functions not listed here) is available from the authors. A variant of the COMMON LISP version is currently being used at SRI International to generate scopings in the KLAUS system. 2.2 LANGUAGE CONSTRUCTS In the specifications below, the let construct implements local variable assignment. All assignments are done sequentially, not in parallel. The syntax is let"]},{"title":"(assignments) in (body)","paragraphs":["The entire expression returns what the body returns. Destructuring by pattern matching is allowed in the assignments; for example, let"]},{"title":"<quant var restrict>","paragraphs":[":="]},{"title":"term","paragraphs":["in"]},{"title":"(body)","paragraphs":["simultaneously binds"]},{"title":"quant, var,","paragraphs":["and"]},{"title":"restrict","paragraphs":["to the three corresponding components in"]},{"title":"term.","paragraphs":["The symbol \":=\" is used for assignment, lambda is an anonymous-function-forming operator. Its syntax is lambda((variable))."]},{"title":"(body)","paragraphs":["where"]},{"title":"(variable)","paragraphs":["is free in"]},{"title":"(body).","paragraphs":["We assume lexical scoping in lambda expressions. The statement \"return"]},{"title":"value\"","paragraphs":["returns a value from a function. The binary function"]},{"title":"map","paragraphs":["(similar to LISP's"]},{"title":"mapcar)","paragraphs":["applies its second argument (a lambda expression) to each of the elements of its first argument (a list). It returns a corresponding list of the values of the individual applications. The function"]},{"title":"integers(lower, upper)","paragraphs":["returns a list of the integers in 50 Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 Jerry R. Hobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Scopings the range"]},{"title":"lower","paragraphs":["to"]},{"title":"upper,","paragraphs":["inclusive and in order (corresponding to APL's"]},{"title":"iota).","paragraphs":["The function"]},{"title":"length(list)","paragraphs":["is obvious. The expression"]},{"title":"list!n!","paragraphs":["returns the nth element of the list"]},{"title":"list.","paragraphs":["The function"]},{"title":"subst(x,y, expr)","paragraphs":["substitutes x for all occurrences of y in"]},{"title":"expr.","paragraphs":["The unary function"]},{"title":"predicate(wff)","paragraphs":["returns the main predicate in a wff. The unary function"]},{"title":"arguments(wff)","paragraphs":["returns a list of the arguments in a wff. Applied to two arguments,"]},{"title":"wff","paragraphs":["is a binary function that takes a predicate name and a list of arguments, and returns the wff consisting of the application of the predicate to the arguments. Applied to four arguments,"]},{"title":"wff","paragraphs":["is a quaternary function that takes a quantifier name, a variable name, a restriction, and a body, and returns the quantified wff consisting of the binding of the variable by the quantifier in the restriction and body. The binary predicate"]},{"title":"opaque(predicate, n)","paragraphs":["returns"]},{"title":"true","paragraphs":["if and only if the predicate is opaque in its nth argument. It is naturally assumed that opaque argument positions are filled by wff expressions, not terms. Each of the unary predicates"]},{"title":"wff?, term?,","paragraphs":["and"]},{"title":"quantifier?","paragraphs":["returns"]},{"title":"true","paragraphs":["if and only if its argument is a wff, a complex term, or a quantifier operator, respectively. 2.3 THE NONDETERMINISTIC ALGORITHM In the nondeterministic version of the algorithm, there are three special language constructs. The unary predicate"]},{"title":"exists(expression)","paragraphs":["evaluates its argument nondeterministically to a value and returns"]},{"title":"true","paragraphs":["if and only if there exist one or more values for the expression. The binary operator \"a 1[ b\" nondeterministically returns one of its arguments (a or b). The function"]},{"title":"term(form)","paragraphs":["nondeterministically returns a complex term in"]},{"title":"form.","paragraphs":["Finally, the function"]},{"title":"applicable-term(form)","paragraphs":["nondeterministically returns a complex term in"]},{"title":"form","paragraphs":["that can be applied to"]},{"title":"form.","paragraphs":["The nondeterministic version of the algorithm is as follows. The function"]},{"title":"gen(form)","paragraphs":["nondeterministically returns a valid full scoping of the formula"]},{"title":"form. function gen (form); return pull(form, true).","paragraphs":["The function"]},{"title":"pull(form, complete?)","paragraphs":["nondeterministically returns a valid'scoping of the formula"]},{"title":"form.","paragraphs":["If"]},{"title":"complete?","paragraphs":["is"]},{"title":"true,","paragraphs":["then only full scopings are returned; otherwise, partial scopings arc allowed as well. function"]},{"title":"pull(form, complete?); return apply-terms(pull-opaque-args(f orm ), complete?).","paragraphs":["The function"]},{"title":"pull-opaque-args(form),","paragraphs":["when applied to a wff, returns a wff generated from"]},{"title":"form","paragraphs":["but with arguments in opaque argument positions replaced by a valid scoping of the original value. Since the recursive call to"]},{"title":"pull","paragraphs":["has"]},{"title":"complete?","paragraphs":["set to"]},{"title":"false,","paragraphs":["the unchanged argument is a nondeterministic possibility, even for opaque argument positions. When applied to any other type of expression (i.e., a term of some sort),"]},{"title":"form","paragraphs":["is unchanged. function"]},{"title":"pull-opaque-args(f orm ) ; if not (wff?(form) ) then return form else let predicate := predicate(form); args := arguments(form) in return wff(predicate, map(integers(1,length(args)),","paragraphs":["lambda(arg-index). if"]},{"title":"opaque(predicate, arg-index) then pull(args[arg-index],false) else pull-opaque-args(args[arg-index]) ) ).","paragraphs":["The function"]},{"title":"apply-terms(form, complete?)","paragraphs":["chooses several terms in"]},{"title":"form","paragraphs":["nondeterministically and applies them to"]},{"title":"form.","paragraphs":["If"]},{"title":"complete?","paragraphs":["is"]},{"title":"true,","paragraphs":["then only full scopings are returned. function"]},{"title":"apply-terms(form, complete?); if not(exists(term(form))) then return form else let scoped-form := apply-terms(apply(applicable-term (form), form), complete?) in if complete? then return scoped-form else return scoped-form","paragraphs":["[["]},{"title":"form. Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 51 Jerry R. Hobbs and Sluar! M. Shieber An Algorilhm for Generating Quantifier Scopings","paragraphs":["The function"]},{"title":"apply(term, form)","paragraphs":["returns a wff consisting of the given complex term"]},{"title":"term","paragraphs":["applied to a form"]},{"title":"form","paragraphs":["in which it occurs. In addition, the restriction of the complex term is recursively scoped. function"]},{"title":"apply(term,form); let <quant var restrict> := term return wff(quant, var, pull(restrict,false), subst ( var, term,form)).","paragraphs":["2.4 THE DETERMINISTIC ALGORITHM For the deterministic version of the algorithm, there are five special language constructs. The unary predicate"]},{"title":"empty(set)","paragraphs":["returns"]},{"title":"true","paragraphs":["if and only if"]},{"title":"set","paragraphs":["is empty. Paired braces \"{ ... }\" constitute a set-forming operator. The binary function"]},{"title":"union","paragraphs":["applies its second argument (a lambda expression) to each of the elements of its first argument (a set). It returns a corresponding set of the values of the individual applications. The binary infix operator U returns the union of its two arguments (both sets). The function"]},{"title":"cross-product","paragraphs":["takes a list of sets as its argument and returns the set of lists corresponding to each way of taking an element from each of the sets in order. For example,"]},{"title":"cross-product(","paragraphs":["[{a,b},{c,d,e}]"]},{"title":") = { [a,c], [a,d], [a,e], [b,c], [b,d], [b,e] }.","paragraphs":["The function"]},{"title":"terms(form)","paragraphs":["returns the set of all complex terms in"]},{"title":"form.","paragraphs":["The function"]},{"title":"applicable-terms(form)","paragraphs":["returns the set of all complex terms in"]},{"title":"form","paragraphs":["that can be applied to"]},{"title":"form.","paragraphs":["The deterministic version of the algorithm is identical in structure to the nondeterministic version. Each function operates in the same way as its nondeterministic counterpart, except that they uniformly return sets rather than nondeterministically returning single values.","The algorithm is as follows. The function"]},{"title":"gen(form)","paragraphs":["returns a set of all valid full scopings of the formula"]},{"title":"form. function gen (form); return pull(form, true).","paragraphs":["The function"]},{"title":"pull","paragraphs":["returns a set of all valid scopings of the formula"]},{"title":"form.","paragraphs":["If"]},{"title":"complete?","paragraphs":["is"]},{"title":"true,","paragraphs":["only full scopings are returned; otherwise, partial scopings are allowed as well. function"]},{"title":"pull(form, complete?); return union(pull-opaque-args(form), iambda(pulled-opaque ). apply-terms( pulled-opaque, complete?)).","paragraphs":["The function"]},{"title":"pull-opaque-args(form)","paragraphs":["returns a set of all wffs generated from"]},{"title":"form,","paragraphs":["but with arguments in opaque argument positions replaced by a valid scoping of the original value. Since the recursive call to"]},{"title":"pull","paragraphs":["has"]},{"title":"complete?","paragraphs":["set to"]},{"title":"false,","paragraphs":["the unchanged argument is a possibility even for opaque argument positions. When applied to any other type of expression (i.e., a term of some sort), the argument is unchanged. function"]},{"title":"pu ll-opaque-args (form) if not(wff?(form) ) then return {form} else let predicate := predicate(form); args := arguments(form) return union( cross-product( map( integers( 1, length ( args) ), lambda ( arg-index ). if opaque(predicate, arg-index) then pull(args[arg-index], false) else pull-opaque-args(args[arg-index]) ) ), lambda( args-possibility). {wff(predicate, args-possibility) } ).","paragraphs":["The function"]},{"title":"apply-terms(form, complete?)","paragraphs":["returns a set of scopings of"]},{"title":"form","paragraphs":["constituting all of the ways of choosing several terms in"]},{"title":"form","paragraphs":["and applying them to"]},{"title":"form.","paragraphs":["If"]},{"title":"complete?","paragraphs":["is"]},{"title":"true,","paragraphs":["then only the full scopings are returned. 52 Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 Jerry R. Hobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Scopings (3) function"]},{"title":"apply-terms(form, complete?); if empty( terms(Jbrm ) ) then return [form} else let scoped-forms := union(applicable-terms(form), lambda( term ). union(apply(term, form), lambda( applied-f orm ). apply-terms(applied-form, complete?))). in if complete? then return scoped-forms else return {form} U scoped-forms.","paragraphs":["The function"]},{"title":"apply(term, form)","paragraphs":["returns a set of all wffs consisting of the given complex term"]},{"title":"term","paragraphs":["applied to the form"]},{"title":".form","paragraphs":["in which it occurs, with the restriction of the complex term recursively scoped in all possible ways. function"]},{"title":"apply(term,form); let (quant var restrict) := term in return","paragraphs":["(4)"]},{"title":"union(pull(restrict,false), lambda (pulled-restrict ). {wff(quant, var, pulled-restrict, subst ( var, term,form)) }).","paragraphs":["3 Two EXAMPLES Since the algorithm is not completely transparent, it may be useful to work through the deterministic version for a detailed example.","(5) Some representative of every department in most companies saw a few samples. The predicate-argument structure of this sentence may be represented as follows:"]},{"title":"(6)","paragraphs":["see(<some r","and(rep(r),","of(r,<every d","and(dept(d),","in(d,<most c co(c)>))>))>,","<a-few s samp(s)>) Suppose"]},{"title":"gen","paragraphs":["is called with expression (6) as"]},{"title":"form.","paragraphs":["Since this is the representation of the whole sentence,"]},{"title":"pull","paragraphs":["will be called with"]},{"title":"complete?","paragraphs":["equal to"]},{"title":"true.","paragraphs":["The call to"]},{"title":"pull-opaque-args","paragraphs":["will return the original wff unchanged since there are no opaque operators in the wff. We therefore call"]},{"title":"apply-terms","paragraphs":["on the wff. In"]},{"title":"apply-terms,","paragraphs":["the call to"]},{"title":"applicable-terms","paragraphs":["returns a list of all of the unnested complex terms. For (6), there will be two:","(7) <some r","and(rep(r), of(r,<every d","and(dept(d),","in(d,<most c co(c)>))>))> (8) <a-few s samp(s)> Each of these complex terms will ultimately yield the wffs in which its variable is the more deeply nested of the two.","The function"]},{"title":"apply","paragraphs":["is called for each of these complex terms, and inside"]},{"title":"apply","paragraphs":["there is a recursive call to"]},{"title":"pull","paragraphs":["on the restriction of the complex term. This generates all the possible scopings for the restriction. When"]},{"title":"apply","paragraphs":["is called with (6) as"]},{"title":"form","paragraphs":["and (7) as"]},{"title":"term,","paragraphs":["the result of seoping the restriction of (7) will be the following four wffs:","(9) and(rep(r),","of(r,<every d","and(dept(d),","in(d,<most c co(c)>))>))","(10) every(d, and(dept(d), in(d, <most c co(c)>)),","and(rep(r), of(r, d)))","(11) most(e, co(c), every(d, and(dept(d), in(d,c)),","and(rep(r), of(r,d))))","(12) every(d, most(e, co(c), and(dept(d), in(d,c))),","and(rep(r), of(r, d))) Because this call to"]},{"title":"pull","paragraphs":["has"]},{"title":"complete?","paragraphs":["equal to"]},{"title":"false,","paragraphs":["the unprocessed restriction itself, wff (9), as well as the partially scoped wff (10), is returned along with the fully scoped forms of the restriction. Wff (9) will ultimately generate the two readings in which variables d and c outscope r. Wff (10) is also partial as it still contains a complex term. It will ultimately yield a reading in which r outscopes d but is outscoped by c; the complex term for c is still\" available for an application that will give it wide Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 53 Jerry R. Hobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Scopings scope. Wffs (11) and (12) will ultimately yield readings in which d and c are outscoped by r.","Each of these wffs becomes the restriction in a quantified wff constructed by apply. Thus, from restriction (10), apply will construct the quantified wff","(13) some(r, every(d, and(dept(d),","in(d, <most e co(c)>)),","and(rep(r), of(r, d))),","see(r, <a-few s samp(s)>)) In apply-terms, the tail recursion turns the remaining complex terms into quantifiers with wide scope. Thus, in (13) c and s will be given wider scope than r and d. For example, one of the readings generated from wff (13) will be","most(c, co(c),","a-few(s, samp(s), some(r, every(d, and(dept(d), in(d, c)),","and(rep(r), of(r, d))),","see(r, s)))) Sentence (5), by the way, has 14 different readings.","As an example of the operation of the algorithm on a wff with opaque operators, we consider the sentence Everyone isn't here. This has the predicate-argument structure not(here(<every x person(x)>)) where not is an operator opaque in its only argument. The call to pull-opaque-args returns the two scopings not(here(<every x person(x)>)) not(every(x,person(x),here(x)))","The call to apply-terms then turns the first of these into every(x,person(x),not(here(x))) Thus, the following two full scopings are generated: every(x,person(x),not(here(x))) not(every(x,person(x),here(x))) Note that because of the recursive call in pull-opaque-args these two readings will be generated even if this form is embedded within other transparent predicates. 4 MODIFICATIONS AND EXTENSIONS 4.1 RESTRICTING APPLICABLE TERMS The notion of applicable term used above was quite simple. A complex term was applicable to a wff if it was embedded in no other complex term within the wff. The restriction is motivated by the following consideration. Suppose the input wff is p( <qlxq(x, <qyyry(y)> )> ) If the embedded term were first applied, yielding","q2 (Y, r2 (Y), P( < ql X r I (x~y) > )) the remaining complex term would include a free occur-fence of y so that when it is later applied, resulting in the formula","ql (x, r I (xo,), qz (,Y, rz (Y), p(x))) the variable y occurs free in the restriction of q/•","Thus, it is critical that a term never be applied to a form when a variable that is free in the term is bound outside of it in the form. The simple definition of applicability goes part of the way towards enforcing this requirement.","Unfortunately, this simple definition of applicability is inadequate. If x had itself been free in the embedded complex term, as in the wff","P( < ql x r I (x, < qz y rz (x, y) > ) >) the application of the outer term followed by the inner term would still leave an unbound variable, namely x. This is because the inner term, which uses x, has been applied outside the scope of the binder for x. Such structures can occur, for instance, in sentences like the following, where an embedded noun phrase requires reference to its embedding noun phrase. 5 Every man that I know a child of has arrived. Every man with a picture of himself has arrived. In these two sentences the quantifier a cannot outscope every because the noun phrase beginning with a embeds a reference to every man. If a were to outscope every, then himself or the trace following child of would be outside the scope of every man.","The definition of applicable term must be modified as follows. A term in a wff is applicable to the wff if and only if all variable occurrences that are free in the term are free in the wff as well. Our previous definition of applicability, that the term be unembedded in another term in the wff, is a simple consequence of this restriction. The versions of the algorithm given in Appendices A and B define the functions applicable-term and applicable-terms in this way. Given this definition, the algorithm can be shown never to generate unbound variables. (See Appendix C.) 4.2 ADDING ORDERING tlEURISTICS A full discussion of heuristic rules for guiding generation of quantifier scopings is outside of the aims of this paper. However, certain ordering heuristics can be incorporated relatively easily into the algorithm merely by controlling the way in which nondeterministic choices are made. We discuss a few examples here, merely to give the flavor for how such heuristics might be added.","For instance, suppose we want to favor the original left-to-right order in the sentence. The function applicable-terms should return the complex terms in right-to-left order, since quantifiers are extracted from the inside out. The union in line (3) should return form after scoped-forms.","if we want to give a noun phrase wide scope when it occurs as a prepositional phrase noun complement to a function word, e.g., every side of a triangle, then form should come before scoped-form in line (3) when pull has been called from line (4) in apply where the first argu-54 Computational Linguistics, Volume 13, Numbers i-2, January-June 1987 Jerry'R. Hobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Scopings ment to apply is a complex term for a noun phrase satisfying those conditions, e.g., the complex term for every side of a triangle.","The modifications turn out to be quite complicated if we wish to order quantifiers according to lexical heuristics, such as having each outscope some. Because of the recursive nature of the algorithm, there are limits to the amount of ordering that can be done in this manner. At the most, we can sometimes guarantee that the best scoping comes first. Of course, one can always associate a score with each reading as it is being generated and sort the list afterwards. 4.3 NONSTANDARD INPUT STRUCTURES The algorithm as presented will operate correctly only for input structures that are themselves well-formed. For instance, they must contain no unbound variables. Certain natural language phenomena, such as the so-called donkey sentences, exhibit structures that are ill-formed with respect to the assumptions made by this algorithm. For instance, the sentence","Every man who owns a donkey beats it. has an ill-formed input structure because the pronoun has to reach inside the scope of an existential quantifier for its antecedent. Its predicate-argument structure might be something like beat(<every m and(man(m),","own(m, <some d donkey(d)>))>,"]},{"title":"d)","paragraphs":["An alternative is to leave the pronoun unanalyzed, in which case the closest reading produced by the algorithm is every(m, and(man(m),","some(d, and(donkey(d), own(m, d)))),","the(x, it(x), beat(m, x))) In fact, this is not bad if we take it(x) to mean that x is nonhuman and that x is mentioned in the prior discourse in a position determined by whatever coreference resolution process is used. There is a problem if we take the quantifier the to mean that there is a unique such x and take the sentence to mean that a man who owns many donkeys will beat every donkey he owns. But we can get around this if, following the approach taken by Hobbs (1983), we take a donkey to be generic, take it to refer to the unique generic donkey that m owns, and assume that to beat a generic donkey is to beat all its instances.","In any case, modifications to the algorithm would be needed to handle such anaphora phenomena in all their complexity. 5 CONCLUSION We have presented an algorithm for generating exactly those quantifier scopings that are consistent with the logical structure of English. While this algorithm can sometimes result in a significant savings over the naive approach, it by no means solves the entire quantifier scoping problem, as we have already pointed out. There has already been much research on the problem of choosing the preferred reading among these allowable ones, but the methods that have been suggested need to be specified in an implementation-free fashion more precisely than they have been previously, and they need to be evaluated rigorously on large bodies of naturalistic data. More important, methods need to be developed for using pragmatic considerations and world knowledge - particularly reasoning about quantities and dependencies among entities - to resolve quantifier scope ambiguities, and these methods need to be integrated smoothly with the other kinds of syntactic, semantic, and pragmatic processing required in the interpretation of natural language texts. ACKNOWLEDGMENTS We have profited from discussions about this work with Paul Martin and Fernando Pereira, and from the comments of the anonymous reviewers of the paper.","This research was supported by NIH Grant LM03611 from the National Library of Medicine, by Grant IST-8209346 from the National Science Foundation, and by a gift from the System Development Foundation. REFERENCES","Barwisc, Jon and Coopcr, Robin 1981 Generalized Quantificrs and Natural Language. Linguistics attd Philosophy 4(2): 159-219.","Cooper, Robin 1983 Quant~[Tcation and Syntactic Theory. Rcidcl, Dordrecht.","Cushing, Stevcn 1976 Thc Formal Semantics of Quantification. Ph.D. dissertation. Univcrsity of California, Los Angclcs.","Grosz, Barbara J.; Appclt, Douglas E.; Martin, Paul; Pcreira, Fcrnando C.N.; and Shinkle, Lorna 1985 The TEAM Natural-Language Interface System. Final Report, Project 4865. Artificial Intclligcnce Center, SRI International, Menlo Park, California.","Hobbs, Jcrry R. 1983 An Improper Treatment of Quantification in Ordinary English. In Proceedings 9[\" the 21st Annual Meeting ¢~/\" the Association for Computational Linguistics. Cambridge, Massachusetts: 57-63.","Keller, William 1986 Nested Cooper Storage. Paper presented at thc Workshop on Word Order and Parsing in Unification Grammars, Friedcnweiler, West Germany (7- I I April).","Montaguc, Richard 1973 The Propcr Trcatmcnt of Quantification in Ordinary English. In Thomason, R., Ed., Formal Philosopl¢y. Selected Papers of Richard Montague. Yale University Press, Ncw Haven, Connecticut.","Moore, Robert C. 1981 Problems in Logical Fornl. In Proceedings ¢~/\" the 19th Annual Meet#lg of the Association .[br Computational Linguistics. Stanford, California: 117-124.","Pcreira, Fernando C.N. 1983 Logic for Natural Language Analysis. Technical Note 275. Artificial Intelligence Center, SRI International, Menlo Park, California.","Woods, William 1977 Semantics and Quantification in Natural Language Question Answering. Adwmces in Computers. Vohtme 17. Academic Press, New York: 1-87. Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 55 Jerry R. Hobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Scopings APPENDIX A. PROLOG IMPLEMENTATION OF THE ALGORITHM The following is the core of a Prolog implementation of the nondeterministic algorithm which includes all but the lowest level of routines. The syntax is that of Edinburgh Prologs, e.g., DEC-20 Prolog. Prolog Implementation of Scope Generation Algorithm","/ ............................................................................ Representation of wffs: A wff of the form 'p(argl,...,argn)' is represented as the Prolog term wff(p,[arg1', .... argn']) where argi' is the encoding of the subexpression argi. A constant term is represented by the homonymous Prolog constant. A complex term is represented by the Prolog term term(quant,var,restrict') where restrict' is the encoding of the wff that forms the restriction of the quantifier. .............................. • / Z gen(Form,ScopedForm)","Z Form ==> a wff with in-place complex terms ScopedForm <== a full scoping of Form","gen(Form, ScopedForm) -- pull(Form, true, ScopedForm). Z pull(Form, Complete?, ScopedForm) Z Form Complete? ScopedForm ==> a wff with in-place complex terms ==> true iff only full scopings are allowed <== a full or partial scoping of Form Applies terms at various level of embedding in Form, including applying to the entire Form, and to opaque argument positions inside Form.","pull(Form, Complete, ScopedForm) -- pull_opaque_args(Form, PulledOpaque), apply terms(PulledOpaque, Complete, ScopedForm). Z pull opaque_args(Form, ScopedForm) % Form =:> a term or a wff with in-place complex terms Z ScopedForm <== Form with opaque argument positions recursively scoped Z Scopes arguments of the given Form recursively.","pull_opaque args(wff(Pred,Args), wff(Pred, ScopedArgs)) :- !, pull_opaque args(Pred, I, Args, ScopedArgs). pull_opaque_args(Term, Term). 56 Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 Jerry R. tlobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Scopings Z pull_opaque_args(Pred, ArgIndex, Args, ScopedArgs) Pred ==> the predicate of the wff whose args are being scoped ArgIndex ==> the index of the argument currently being scoped Args :=> list of args from ArgIndex on ScopedArgs <:= Args with opaque argument positions recursively scoped Scopes a given argument if opaque; otherwise, scopes its subparts recursively. Z No more arguments. pull_opaque_args(_Pred,_ArgIndex,[],[]) -- ! .","Z Current argument position is opaque; scope it.","pull opaque_args(Pred, ArgIndex,","[FirstArgJRestArgs],","[ScopedFirstArgJScopedRestArgs]) -- opaque(Pred,ArgIndex), !, pull(FirstArg,false,ScopedFirstArg), NextIndex is ArgIndex+1, pull_opaque args(Pred, NextIndex, RestArgs, ScopedRestArgs).","Z Current argument is not opaque; don't scope it.","pull opaque_args(Pred, ArgIndex,","[FirstArglRestArgs],","[ScopedFirstArglScopedRestArgs]) -- pull opaque args(FirstArg,ScopedFirstArg), NextIndex is ArgIndex+1, pull opaque_args(Pred, NextIndex, RestArgs, ScopedRestArgs). Z apply terms(Form, Complete?, ScopedForm) Z Z Form =:> a wff with in-place complex terms Z Complete? :=> true iff only full scopings are allowed Z ScopedForm <:: a full or partial scoping of Form Z Z Applies one or more terms to the Form alone (not to any embedded Z forms.","apply terms(Form, _Complete, Form) -- not(term(Form,_Term)), !. applyterms(Form, false, Form).","apply terms(Form, Complete, ScopedForm) -- applicableterm(Form, Term), apply(Term, Form, AppliedForm), apply terms(AppliedForm, Complete, ScopedForm). Z apply(Term,Form,NewForm) Z Term :=> a complex term Z Form =:> the wff to apply Term to Z NewForm <== Form with the quantifier wrapped around it","apply(term(Quant,Var,Restrict), Body, wff(Quant,[Var,PulledRestrict,OutBody])) --","pull(Restrict, false, PulledRestrict),","subst(Var,term(Quant,Var,Restrict),Body,OutBody). Z applicable_term(Form, Term) Z Form ==> an expression in the logical form language Z Term <=: a top-level term in Form (that is, a term embedded in Z no other term) which is not free in any variable bound Z along the path from Form to the Term. Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 57 Jerry R. Hohbs and Stuart M. Shieber An Algorithm for Generating Quantifier Scopings","applicable_term(Form, Term) -- applicable_term(Form, Term, []). Z applicable term(Form,Term,BlockingVars) g Z g Form :=> an expression in the logical form language Z Term <=: a top-level term in Form (that is, a term embedded in Z no other term) which is not free in any variable bound Z along the path from Form to the Term. g BlockingVars ::> Z a list of variables bound along the path so far","Z A term is an applicable top-level term...","applicable term(term(Q,V,R),term(Q,V,R), BVs) .-","Z if it meets the definition.","not(free in(BVs, R)).","Z An applicable term of the restriction or body of a quantifier is applicable","Z only if the variable bound by the quantifier is not free in the term.","applicable term(wff(Quant,[Var,Restrict,Body]),Term, BVs) --","quantifier(Quant), !,","(applicable_term(Restrict,Term,[VarlBVs]);","applicable term(Body,Term,[VarlBVs])). Z An applicable term of an argument list is an applicable term of the wff. applicable_term(wff( Pred,Args),Term, BVs) --","applicable term(Args, Term, BVs). Z An applicable term of any argument is an applicable term of the whole % list. applicable term([FIR],Term, BVs) --","applicable term(F,Term,BVs) ;","applicable term(R,Term,BVs).","Z Note the absence of a rule looking for applicable terms inside of complex terms. This limits applicable terms to be top-level. APPENDIX B. COMMON LISP IMPLEMENTATION OF THE ALGORITHM The following is the core of a COMMON LISP implementation of the deterministic algorithm which includes all but the lowest level of routines. ; ; ;,~***~,~,~*****~,~*******~*****~***~**~*************~**~***~*~*~**e ;;; ;;; COMMON LISP Implementation of Scope Generation Algorithm ;;; ****************************************************************************** ;;; ;;; Representation of Wffs ;;; ;;; A wff of the form 'p(argl,...,argn)' is represented as the ;;; s-expression (p arg1' .. argn') where argi' is the encoding of the ;;; subexpression argi. ;;; ;;; A constant term is represented by the homonymous LISP atom. ;;; ;;; A complex term is represented by the s-expression (:term quant ;;; var restrict') where restrict' is the encoding of the wff that forms ;;; the restriction of the quantifier. ;;; 58 Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 Jerry R. Hobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Scopings ;;; Implementation notes: ;;; ;;; The following simple utility functions are assumed: ;;; ;;; map-union -- implements the binary function UNION ;;; cross-product -- implements the function CROSS-PRODUCT ;;; opaque -- implements the binary function OPAQUE ;;; integers -- implements the binary function INTEGERS ;;; ;;; The infix union is implemented with CL function UNION. ;;; The binary prefix union is implemented under the name MAP-UNION ;;; to avoid conflict with the CL function UNION. ;;; The function APPLY is implemented under the name APPLY-Q to avoid ;;; conflict with the CL function APPLY. ;;;","(defun gen (form) (pull. form t))","(defun pull (form complete?)","(map-union (pull-opaque-args form)","(function lambda (pulled-opaque)","(apply-terms pulled-opaque complete?)))))","(defun pull-opaque-args (form)","(if (not (wff? form))","(list form)","(let ((predicate (first form))","(args (rest form)))","(map-union (cross-product","(mapcar (function (lambda (arg-index)","(if (opaque predicate arg-index)","(pull (nth (- arg-index I) args)","nil)","(pull-opaque-args (nth (- arg-index I)","args))))","(integers I (length args))))","(function (lambda (args-possibility) (list (cons predicate args-possibility)))))))","(defun apply-terms (form complete?)","(if (null (terms form))","(list form)","(let ((scoped-forms (map-union (applicable-terms form) (function (lambda (term)","(map-union","(apply-q term form)","(function (lambda (applied-form)","(apply-terms applied-form","complete?)))))","(if complete?","scoped-forms (adjoin form scoped-forms))))) )))","(defun apply-q (term form)","(let ((quant (second term)) (var (third term)) (restrict (fourth term)))","(map-union (pull restrict nil)","(function (lambda (pulled-restrict)","(list","(list quant var pulled-restrict","(subst var term form))))))))","(defun applicable-terms (form) (applicable-termsl form ' ())) Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 59 Jerry R. Hobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Scopings","(.defun applicable-termsl (form blocking-vars)","(cond (atom form) '()) (and (term? form)","(not-free-in blocking-vars (fourth form )) (list form)) (term? form) '()) (and (wff? form)","(quantifier? (first form))) (union (applicable-termsl (third form)","(cons (second form) blocking-vars))","(applicable-termsl (fourth form)","(cons (second form) blocking-vars)))) (t (mapcan (function (lambda (arg)","(applicable-termsl arg blocking-vats)))","(cdr form))))) APPENDIX C. PROOFS OF ALGORITHM PROPERTIES This appendix includes informal proofs of some important properties of the nondeterminisitc version of the presented algorithm. First, we present a proof of the termination of the algorithm. Several criteria of the partial correctness of the algorithm are also informally shown, especially, that the algorithm does not generate wffs with unbound variables.","However, we do not prove correctness in the sense of showing that the algorithm is semantically sound, i.e., that it.yields wffs with interpretations consistent with the interpretation of the input expression, simply because we do not provide a semantics for the input language. (The output language, of course, has a standard logical semantics.)","We do not attempt to prove completeness for the algorithm, as the concept of completeness is open to interpretation, depending as it does on just which scopings one deems possible, but we expect that the algorithm is complete in the sense that every permutation of quantifiers respecting the considerations in the introduction is generated. We also do not prove the nonredundancy of the nondeterminism in the algorithm, i.e., that the algorithm will not generate the same result along different nondeterministic paths, although we believe that the algorithm is nonredundant. C.l NOTATION We will use lower Greek letters (a, /3 .... ) as variables ranging over expressions in the logical form language.","We inductively define a metric p on expressions in the logical form language as follows:"]},{"title":"t 2 + p(r)","paragraphs":["if a is a complex term < q vr >","n","n"]},{"title":"O(a) ~ 1 + i_ZtO(ai)","paragraphs":["if a is a wfff(al, ... ,"]},{"title":"a,) and_EtO(a i) > 0","paragraphs":["0 otherwise Informally, p is a measure of the embedding depth of the complex terms in an expression. c.2 TERMINATION We will give an informal proof of termination for the nondeterministic algorithm by induction on this metric p. But first, we present without proof three simple but useful properties of the metric. Lemmal If a is a wff, then"]},{"title":"p(a)","paragraphs":["= 0if and only if a contains no complex terms. Lemma 2 If a is a wff and/3 is a subexpression of a and"]},{"title":"p(a) > O,","paragraphs":["then p(/3) <"]},{"title":"p(a) Lemma","paragraphs":["3 If a is a wff and/3 is a subexpression of a and"]},{"title":"p(a)","paragraphs":["= O, then p(/3) = O. We now prove the following theorem, and its corollary which gives the termination of the algorithm. We assume that calls to the auxiliary functions"]},{"title":"wff, term, wff?, term?, predicate, arguments, opaque, map, exists, not, applicable-term, subst,","paragraphs":["and so forth always terminate if the computation of their arguments terminates. Theorem 1. For all expressions a, the following six conditions hold':"]},{"title":"Condition 1: pull-opaque-args(a)","paragraphs":["terminates with result/3 such that p(/3) _<"]},{"title":"p(a), Condition 2:","paragraphs":["for all complex terms t in"]},{"title":"a, apply(t,a)","paragraphs":["terminates with result/3 such that p(/3) < p(a),"]},{"title":"Condition 3: apply-terms(a,true)","paragraphs":["terminates with result /3 such that p(/3) = O,"]},{"title":"Condition 4: apply-terms(a false)","paragraphs":["terminates with result/3 such that p(/3) _<"]},{"title":"p(a), Condition 5: pull(a,true)","paragraphs":["terminates with result /3 such that p(/3) = O,"]},{"title":"Condition 6: pull(a~false)","paragraphs":["terminates with result /3 such that p(/3) _<"]},{"title":"p(a). 60 Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 Jerry","paragraphs":["R. Hobbs and Stuart M. Shieber An Algorilhm for Generating Quanlifier Scopings","Proof.\" We first prove the base case, for p(a) = 0. By Lemma 1, a must contain no complex terms. Three of the conditions are easily proved.","Condition 2: Since, by Lemma 1, there are no complex terms in a, this condition holds vacuously. Condition 3: Again, the absence of complex terms in a causes the call to apply-terms to return with result a, and p(a) = 0, so the condition holds. Condition 4: Similarly, and p(a) < p(a) trivially.","Conditions 1,5, and 6: These conditions follow directly from Lemma 4 given below.","Lemma 4 For all expressions a such that p(a) = 0, pull(a,x) and pull-opaque-args(a) terminate with result a.","Proof sketch: The proof is by a simple induction on the length of the expression, and uses the base case for conditions 3 and 4 proved above.","For the induction step for Theorem 1, we assume the induction hypotheses that the six conditions hold for all a such that p(a) < n and prove the conditions for p(a) = n, for n>0. The conditions are proved sequentially. In particular, earlier conditions for the case p(a) = n are used in the proofs of later ones. (Since there is no use of later conditions in earlier ones, this does not introduce any circularity in the proof.)","Condition 1: We must show that pull-opaque-args(a) terminates with result/3 such that 0([3) < o(a). If a is not a wff, then the condition holds vacuously, so we assume that a = f(a I ..... a~). By definition of p, k","p(/3) ___ 1 + ~P(/3i)\" i= 1 (The inequality is necessary because p(/3) may be zero.) Now/3~ is either a~ or pull(a~false). In the first case, p(/3) < p(a~) trivially. In the second case, since a~ is a subexpression of a, by Lemma 2 we have that p(a~) < p(a) and we can use the induction hypothesis to show the termination of the call to pull. Also by the induction hypothesis, p(fl,) < p(a~). Thus, we see that in either case, p(/3~) < p(a~). So k k","p(fl) < 1 + Zp(fli) < 1 + Zp(ai)= p(a). i= I i= 1","Condition 2: We must show that for all terms t in a, apply(t,a) terminates with result /3 such that p(/3) < p(a). Suppose t= <qvr>. Then /3 = apply(<q v r>, a) = q(v, 3\", 6) where 3' = pull(r, false) and 6 = subst(v, <q v r>, a).","Now, let p(r) = m. By Lemma 2, m < n. So by the induction hypothesis, the computation of 3, terminates and"]},{"title":"p(3')","paragraphs":["< m. Also, the computation of 6 is assumed to terminate (as mentioned above) with 6 missing the complex term t that occurs in a (and possibly other complex terms embedded within t). So p(a) _< p(a)--p(t) =n- (2+p(r)) =n--2--m. Finally, by definition of p we have p(fl) < 1 + p(3,) + p(6) < 1 +m+n-2-m=n-1 <n.","We will use the two conditions just proved in the proofs of the final four conditions.","Cond#ion 3: We must show that apply-terms(a,true) terminates with result /3 such that 0(/3) = 0. By Lemma 1, we know that complex terms exist in a so the else clause is taken. Let t = applicable-term(a) and 3, = apply(t,a). By the second condition just proved above, the latter computation terminates with P(3,) _< p(a) - 1 < n. Now let e = apply-terms(3,, true). Again, by the induction hypothesis, this computation terminates with p(¢) = 0. Since complete? = true, we return ¢ as/3, so p(/3) = 0 as required.","Condition 4: We must show that apply-terms(a false) terminates with result /3 such that p(/3) < p(a). By Lemma 1, we know that complex terms exist in a so the else clause is taken. Let t = applicable-term(a) and 3' = apply(t,a). By the second condition just proved above, this computation terminates with p(3') < p(a) - 1 < n. Now let ¢ = apply-terms(3'false). Again by the induction hypothesis, this computation terminates with p(e) < p(3') < n. Since complete? = false, we return • or a as /3. In either case, 0(/3) < p(a) as required.","We will use the four conditions just proved in the proofs of the final two conditions.","Condition 5: We must show that pull(a,true) terminates with result/3 such that p(/3) = 0. Let 3' = pull-opaque-args(a). By the first condition just proved above, we know this computation terminates and 0(3') < n. Now, let e = apply-terms(3\",true). Again by the third condition just proved above, this computation terminates with p(e) = 0. Since complete? = true, we return ¢ as/3, so p(/3) = 0 as required.","Condition 6: We must show that pull(a false) terminates with result fl such that p(/3) < p(a). The argument is similar to that for condition 5. Let 3' = pull-opaque-args(a). By the first condition just proved above, we know this computation terminates and P(3,) < n. Now, let c = apply-terms(3\", false). Again by the fourth condition just proved above, this computation terminates with p(¢) < p(3') _< n. Since complete? = false, we return either E or a as /3. In either case, p(/3) < p(a) as rquired.","This completes the proof of the six conditions, given the induction hypotheses, and thus completes the inductive proof of the theorem.","Corollary 1 For all wffs a, gen(a) terminates with result /3 such that/3 has no complex terms as subexpressions.","Proof: This follows immediately from the fifth condition in Theorem 1 and Lemma 1. Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 61 Jerry R. Hobbs and SIuart M. Shieber An Algorithm for Generaling Quantifier Scopings C.3 CORRECTNESS We consider several criteria for correctness of the algorithm. Let U(a) = the set of variables that are unbound in a and V(a) = the set of variables that are vacuously quantified in a. 6 We show that if input expression a is well-formed, that is, has no unbound variables and no vacuous quantifiers (U(a) = V(a) = ~), and if /3 = gen(a), then Criterion 1:/3 has no complex terms; Criterion 2:/3 has no unbound variables (U(/3) = ~); Criterion 3:/3 has no vacuous quantifiers (V(/3) = ~);","Criterion 4: for every complex term t in a, there is a quantifier in /3 that binds the same variable as t and has the position held by t in a in its body; and","Criterion 5: for every quantifier q in /3, there is either a quantifier in a or a complex term in a that binds the same variable.","Proof of these five statements does not constitute a proof of correctness, but provides motivation for assuming the correctness of the algorithm. As unbound variables in the output are the prime symptom of problems with previous algorithms, we take these criteria to be the most critical for indicating correctness.","The first criterion follows directly from Corollary 1.","The second and third criteria are a consequence of the following theorem which we prove informally.","Theorem 2 For all expressions such that U(a)= u= {u I ..... u,,,} and V(a)=v= {v I ..... v~}, and for b E {true, false} and for/3 any of gen(a), pull(a, b), pull-opaque-args( a ), apply-terms(a, b ) , and apply(applicable-term(a), a), U(/3) = u and V(/3) = v.","Proof: Again, the proof is by induction on O(a), but we will be less formal in demonstrating the well-foundedness of the induction. The base case is trivial because, as shown in the proofs of Theorem 1 and Lemma 4, the functions all return their argument unchanged when p(a) = 0. For the induction step, we will merely show that each function maintains the unbound variables and vacuous quantifiers, assuming that all the others do. The previous proof of termination provides the well-foundedness of this proof.","apply(applicable-term(a),a): We must show that if t = < qxr > is an applicable term in a and U(a) = u and V(a) = v then U(apply(t,a)) = u and V(apply(t,a)) = v as well.","The unbound variables u in a can be divided into two (possibly overlapping) sets u~ and u, where u, consists of those variables in u that occur in r and U, consists of those variables in u that occur outside of t in a. Note that u = u, U u~. Now assume x occurs in r. Then U(r) = {x} O u~ O u 0 where u 0 is the set of variables bound within a but outside of t and which occur free in r. But t is an applicable term, and by the definition of \"applicable term\" Uo must be empty. So U(r) = {x} U ur. (If x does not occur in r, a similar argument shows that U(r) = Ur .)","Let r t = pull(r, false) and s = subst(x,t,a). By the induction hypothesis, U(/)= {x} U ur. Since s does not include t (which binds x) but does include x, U(s) = {x} U u~. In forming the quantified wff /3 = q(x, r t, s), the unbound variables in /3 consist of those in r r and those in s except for x, that is u(/3) = [({x} u u~) u ({x} u ur)] - {x} = u~ u u~ = u. (If x does not occur in r, similar arguments show that U(r')=u r, U(s)= {x}Uu s, and U(/3)= [({x} UU,) o u~] - {x} = u, u Ur = U.)","Vacuous quantified variables can be divided similarly into v~ (those bound vacuously in r) and v~ (those bound vacuously outside of t in a). Again, v = vr U v,. Trivially, V(r) = Vr. By induction, V(r') = Vr also. Since s does not include t, V(s) = v~. V(/3) = V(r) U V(s) = v unless the quantification of x in 13 is vacuous. Since x is guaranteed to occur in s (as it replaces t in s), the quantification is clearly not vacuous. So I/(/3) = v.","apply-terms(a,b): This follows straightforwardly from the previous subproof for apply and the induction hypothesis for apply-terms.","pull-opaque-args(a): If a is not a wff, then the proof is trivial. Otherwise, there are two cases, depending on whether the predicate in a, p, is or is not a quantifier. If p is not a quantifier, then the result follows immediately from the induction hypothesis for pull and pull-opaque-args.","If p is a quantifier, then let a = p(x,r,s). The output /3 then is wff(p, pull-opaque-args(x), pull-opaque-args(r), pull-opaque-args(s)). The first call to pull-opaque-args merely returns x. Now by an argument similar to that given in the subproof for apply, the unbound variables in a can be exhaustively divided into Ur and U, depending on whether they occur in r and s. Depending on whether x occurs in r, U(r) = {x} U u, or U(r) = u, Similarly, U(s) = {x} U U, or U(s)= u~. Suppose the second and third calls to pull-opaque-args return r ~ and s t respectively. By the induction hypotheses U(r t) = U(r) and U(J) = U(s). If the quantification of x in a is not vacuous, then x occurs free in either r or s (and by induction in r r or s t) so U(/3) = {x} U ur U U~ - {x} = u. If the quantification of x is vacuous, then U(r t)=u~ and U(J)=U, and U(/3) = u.","Vacuous quantified variables can be divided into vr and v~ similarly. Suppose the quantification of x is vacuous (i.e., x does not occur free in r or s). Then V V(a) = {x} U v, Uv,. By the induction hypothesis, V(r t) = V(r) = v~ and V(s t) = V(s) = v~. Also by induction, x does not occur free in r t or s t, Therefore, the quantification of x in /3 is also vacuous and V(/3) = {X} U V r U V s = V(a).","If the quantification of x is not vacuous, then v -- vr O v~ and x occurs free in either r or s. By induca-62 Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 Jerry R. Hobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Scopings tion, x .Occurs free in either r p or s p so the quantification of x in/3 is also non-vacuous. Also by induction as before, V(r ~) = Vr and V(J) = v~, so"]},{"title":"V(fl) = V(r') U V(s') = v r U v s = V(a).","paragraphs":["pull(a,b): This follows directly, using the previously","proved induction steps for apply-terms and pull-","opaque-args. gen(a): This follows directly, using the previously proved","induction step for pull.","This concludes the proof of the induction step and the theorem.","The second and third criteria follow from the presumed well-formedness of a and Theorem 2 which demonstrates that gen maintains well-formedness.","The fourth and fifth criteria we argue informally as follows: Since no complex terms occur in/3 (by Corollary 1), we can assume that every complex term t in a was applied (i.e., the first argument of apply) at some time in the processing of a. But if it was applied, then it must have been an applicable term occurring in the wff it was applied to (as the only call to apply is of this form). Then the call to subst in apply will not be vacuous, the quantifier will bind the same variable as t and will outscope the position held by t in a. Thus the fourth criterion holds. Also note that all quantifiers in /3 are either the result of such an application or were in a originally. Thus the fifth criterion follows immediately as well. NOTES","1. William Keller (1986) has also noted this problem with Cooper's method. His independent solution to the problem, stated in terms of \"nested Cooper storage\", resembles the one presented here.","2. These heuristics should themselves be made available in a public forum.","3. A nondeterministic version of the algorithm, formulated by both authors, was presented by Hobbs (1983).","4. Note that this term is applicable according to the criterion discussed above, whereas the embedded term binding y is not. The fact that we still get both scopings even without the possibility of applying the embedded term first demonstrates that the restriction on applicable terms does not affect completeness of the algorithm.","5. This problem was pointed out to us by Fernando Pereira.","6. A variable v is vacuously quantified in an expression ~ if and only if v is bound in a subexpression of a, a quantified wff of the form q(v, r, s) and v does not occur free in r or s. This definition implies that variables bound by complex terms are never vacuously quantified. Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 63"]}]}