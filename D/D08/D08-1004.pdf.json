{"sections":[{"title":"","paragraphs":["Proceedings of the 2008 Conference on Empirical Methods in Natural Language Processing, pages 31–40, Honolulu, October 2008. c⃝2008 Association for Computational Linguistics"]},{"title":"Modeling Annotators: A Generative Approach to Learning from Annotator Rationales","paragraphs":["∗"]},{"title":"Omar F. Zaidan and Jason Eisner Dept. of Computer Science, Johns Hopkins University Baltimore, MD 21218, USA {ozaidan,jason}@cs.jhu.edu Abstract","paragraphs":["A human annotator can provide hints to a machine learner by highlighting contextual “rationales” for each of his or her annotations (Zaidan et al., 2007). How can one exploit this side information to better learn the desired parameters θ? We present a generative model of how a given annotator, knowing the true θ, stochastically chooses rationales. Thus, observing the rationales helps us infer the true θ. We collect substring rationales for a sentiment classification task (Pang and Lee, 2004) and use them to obtain significant accuracy improvements for each annotator. Our new generative approach exploits the rationales more effectively than our previous “masking SVM” approach. It is also more principled, and could be adapted to help learn other kinds of probabilistic classifiers for quite different tasks."]},{"title":"1 Background","paragraphs":["Many recent papers aim to reduce the amount of annotated data needed to train the parameters of a statistical model. Well-known paradigms include active learning, semi-supervised learning, and either domain adaptation or cross-lingual transfer from existing annotated data.","A rather different paradigm is to change the actual task that is given to annotators, giving them a greater hand in shaping the learned classifier. After all, human annotators themselves are more than just black-box classifiers to be run on training data. They possess some introspective knowledge about their own classification procedure. The hope is to mine this knowledge rapidly via appropriate questions and use it to help train a machine classifier. How to do this, however, is still being explored. 1.1 Hand-crafted rules An obvious option is to have the annotators directly express their knowledge by hand-crafting rules. This","∗","This work was supported by National Science Foundation grant No. 0347822 and the JHU WSE/APL Partnership Fund. Special thanks to Christine Piatko for many useful discussions. approach remains “data-driven” if the annotators repeatedly refine their system against a corpus of labeled or unlabeled examples. This achieves high performance in some domains, such as NP chunk-ing (Brill and Ngai, 1999), but requires more analytical skill from the annotators. One empirical study (Ngai and Yarowsky, 2000) found that it also required more annotation time than active learning. 1.2 Feature selection by humans More recent work has focused on statistical classifiers. Training such classifiers faces the “credit assignment problem.” Given a training example x with many features, which features are responsible for its annotated class y? It may take many training examples to distinguish useful vs. irrelevant features.1","To reduce the number of training examples needed, one can ask annotators to examine or propose some candidate features. This is possible even for the very large feature sets that are typically used in NLP. In document classification, Raghavan et al. (2006) show that feature selection by an oracle could be helpful, and that humans are both rapid and reasonably good at distinguishing highly useful n-gram features from randomly chosen ones, even when viewing these n-grams out of context.","Druck et al. (2008) show annotators some features f from a fixed feature set, and ask them to choose a class label y such that p(y | f ) is as high as possible. Haghighi and Klein (2006) do the reverse: for each class label y, they ask the annotators to propose a few “prototypical” features f such that p(y | f ) is as high as possible. 1.3 Feature selection in context The above methods consider features out of context. An annotator might have an easier time examining 1","Most NLP systems use thousands or millions of features, because it is helpful to include lexical features over a large vocabulary, often conjoined with lexical or non-lexical context. 31 features in context to recognize whether they appear relevant. This is particularly true for features that are only modestly or only sometimes helpful, which may be abundant in NLP tasks.","Thus, Raghavan et al. (2006) propose an active learning method in which, while classifying a training document, the annotator also identifies some features of that document as particularly relevant. E.g., the annotator might highlight particular unigrams as he or she reads the document. In their proposal, a feature that is highlighted in any document is as-sumed to be globally more relevant. Its dimension in feature space is scaled by a factor of 10 so that this feature has more influence on distances or inner products, and hence on the learned classifier. 1.4 Concerns about marking features Despite the success of the above work, we have several concerns about asking annotators to identify globally relevant features.","First, a feature in isolation really does not have a well-defined worth. A feature may be useful only in conjunction with other features,2","or be useful only to the extent that other correlated features are not selected to do the same work.","Second, it is not clear how an annotator would easily view and highlight features in context, except for the simplest feature sets. In the phrase Apple shares up 3%, there may be several features that fire on the substring Apple—responding to the string Apple, its case-invariant form apple, its lemma apple- (which would also respond to apples), its context-dependent sense Apple2, its part of speech noun, etc. How does the annotator indicate which of these features are relevant?","Third, annotating features is only appropriate when the feature set can be easily understood by a human. This is not always the case. It would be hard for annotators to read, write, or evaluate a descrip-tion of a complex syntactic configuration in NLP or a convolution filter in machine vision.","Fourth, traditional annotation efforts usually try to remain agnostic about the machine learning methods","2","For example, a linear classifier can learn that most training examples satisfy A → B by setting θA = −5 and θA∧B = +5, but this solution requires selecting both A and A∧B as features. More simply, a polynomial kernel can consider the conjunction A ∧ B only if both A and B are selected as features. and features to be used. The project’s cost is justified by saying that the annotations will be reused by many researchers (perhaps in a “shared task”), who are free to compete on how they tackle the learning problem. Unfortunately, feature annotation commits to a particular feature set at annotation time. Subsequent research cannot easily adjust the definition of the features, or obtain annotation of new features."]},{"title":"2 Annotating Rationales","paragraphs":["To solve these problems, we propose that annotators should not select features but rather mark relevant portions of the example. In earlier work (Zaidan et al., 2007), we called these markings “rationales.”","For example, when classifying a movie review as positive or negative, the annotator would also highlight phrases that supported that judgment. Figure 1 shows two such rationales.","A multi-annotator timing study (Zaidan et al., 2007) found that highlighting rationale phrases while reading movie reviews only doubled annotation time, although annotators marked 5–11 rationale substrings in addition to the simple binary class. The benefit justified the extra time. Furthermore, much of the benefit could have been obtained by giving rationales for only a fraction of the reviews.","In the visual domain, when classifying an image as containing a zoo, the annotator might circle some animals or cages and the sign reading “Zoo.” The Peekaboom game (von Ahn et al., 2006) was in fact built to elicit such approximate yet relevant regions of images. Further scenarios were discussed in (Zaidan et al., 2007): rationale annotation for named entities, linguistic relations, or handwritten digits.","Annotating rationales does not require the annotator to think about the feature space, nor even to know anything about it. Arguably this makes annotation easier and more flexible. It also preserves the reusability of the annotated data. Anyone is free to reuse our collected rationales (section 4) to aid in learning a classifier with richer features, or a different kind of classifier altogether, using either our procedures or novel procedures."]},{"title":"3 Modeling Rationale Annotations","paragraphs":["As rationales are more indirect than explicit features, they present a trickier machine learning problem. 32 We wish to learn the parameters θ of some classifier. How can the annotator’s rationales help us to do this without many training examples? We will have to exploit a presumed relationship between the rationales and the optimal value of θ (i.e., the value that we would learn on an infinite training set).","This paper exploits an explicit, parametric model of that relationship. The model’s parameters φ are intended to capture what that annotator is doing when he or she marks rationales. Most importantly, they capture how he or she is influenced by the true θ. Given this, our learning method will prefer values of θ that would adequately explain the rationales (as well as the training classifications). 3.1 A generative approach For concreteness, we will assume that the task is document classification. Our training data consists of n triples {(x1, y1, r1), ..., (xn, yn, rn)}), where xi is a document, yi is its annotated class, and ri is its rationale markup. At test time we will have to predict yn+1 from xn+1, without any rn+1.","We propose to jointly choose parameter vectors θ and φ to maximize the following regularized conditional likelihood:3 n ∏ i=1 p(yi, ri | xi, θ, φ) · pprior(θ, φ) (1) def = n ∏ i=1 pθ(yi | xi) · pφ(ri | xi, yi, θ) · pprior(θ, φ) Here we are trying to model all the annotations, both yi and ri. The first factor predicts yi using an ordinary probabilistic classifier pθ, while the novel second factor predicts ri using a model pφ of how annotators generate the rationale annotations.","The crucial point is that the second factor depends on θ (since ri is supposed to reflect the relation between xi and yi that is modeled by θ). As a result, the learner has an incentive to modify θ in a way that increases the second factor, even if this some-what decreases the first factor on training data.4 3","It would be preferable to integrate out φ (and even θ), but more difficult. 4","Interestingly, even examples where the annotation yi is wrong or unhelpful can provide useful information about θ via the pair (yi, ri). Two annotators marking the same movie review might disagree on whether it is overall a positive or nega-","After training, one should simply use the first factor pθ(y | x) to classify test documents x. The second factor is irrelevant for test documents, since they have not been annotated with rationales r.","The second factor may likewise be omitted for any training documents i that have not been annotated with rationales, as there is no ri to predict in those cases. In the extreme case where no documents are annotated with rationales, equation (1) reduces to the standard training procedure. 3.2 Noisy channel design of rationale models Like ordinary class annotations, rationale annotations present us with a “credit assignment problem,” albeit a smaller one that is limited to features that fire “in the vicinity” of the rationale r. Some of these θ-features were likely responsible for the classification y and hence triggered the rationale. Other such θ-features were just innocent bystanders.","Thus, the interesting part of our model is pφ(r | x, y, θ), which models the rationale annotation process. The rationales r reflect θ, but in noisy ways.","Taking this noisy channel idea seriously, pφ(r | x, y, θ) should consider two questions when assess-ing whether r is a plausible set of rationales given θ. First, it needs a “language model” of rationales: does r consist of rationales that are well-formed a priori, i.e., before θ is considered? Second, it needs a “channel model”: does r faithfully signal the features of θ that strongly support classifying x as y?","If a feature contributes heavily to the classification of document x as class y, then the channel model should tell us which parts of document x tend to be highlighted as a result.","The channel model must know about the particular kinds of features that are extracted by f and scored by θ. Suppose the feature not . . . gripping,5 with weight θh, is predictive of the annotated class y. This raises the probabilities of the annotator’s highlighting each of various words, or combinations of words, in a phrase like not the most gripping banquet on film. The channel model parameters in φ tive review—but the second factor still allows learning positive features from the first annotator’s positive rationales, and negative features from the second annotator’s negative rationales.","5","Our current experiments use only unigram features, to match past work, but we use this example to outline how our approach generalizes to complex linguistic (or visual) features. 33 should specify how much each of these probabilities is raised, based on the magnitude of θh ∈ R, the class y, and the fact that the feature is an instance of the template <Neg> . . . <Adjective>. (Thus, φ has no parameters specific to the word gripping; it is a low-dimensional vector that only describes the annotator’s general style in translating θ into r.)","The language model, however, is independent of the feature set θ. It models what rationales tend to look like in the input domain—e.g., documents or images. In the document case, φ should describe: How frequent and how long are typical rationales? Do their edges tend to align with punctuation or major syntactic boundaries in x? Are they rarer in the middle of a document, or in certain documents?6","Thanks to the language model, we do not need to posit high θ features to explain every word in a rationale. The language model can “explain away” some words as having been highlighted only because this annotator prefers not to end a rationale in mid-phrase, or prefers to sweep up close-together features with a single long rationale rather than many short ones. Similarly, the language model can help explain why some words, though important, might not have been included in any rationale of r.","If there are multiple annotators, one can learn different φ parameters for each annotator, reflecting their different annotation styles.7","We found this to be useful (section 8.2).","We remark that our generative modeling approach (equation (1)) would also apply if r were not rationale markup, but some other kind of so-called “side information,” such as the feature annotations discussed in section 1. For example, Raghavan et al. (2006) assume that if feature h is relevant—a bi-","6","Our current experiments do not model this last point. How-ever, we imagine that if the document only has a few θ-features that support the classification, the annotator will probably mark most of them, whereas if such features are abundant, the annotator may lazily mark only a few of the strongest ones. A simple approach would equip φ with a different “bias” or “threshold” parameter φx for each rationale training document x, to modulate the a priori probability of marking a rationale in x. By fitting this bias parameter, we deduce how lazy the annotator was (for whatever reason) on document x. If desired, a prior on φx could consider whether x has many strong θ-features, whether the annotator has recently had a coffee break, etc.","7","Given insufficient rationale data to recover some annotator’s φ well, one could smooth using data from other annotators. But in our situation, φ had relatively few parameters to learn. nary distinction—iff it was selected in at least one document. But it might be more informative to observe that h was selected in 3 of the 10 documents where it appeared, and to predict this via a model pφ(3 of 10 | θh), where φ describes (e.g.) how to derive a binomial parameter nonlinearly from θh. This approach would not how often h was marked and infer how relevant is feature h (i.e., infer θh). In this case, pφ is a simple channel that transforms relevant features into direct indicators of the feature. Our side information merely requires a more complex transformation—from relevant features into well-formed rationales, modulated by documents."]},{"title":"4 Experimental Data: Movie Reviews","paragraphs":["In Zaidan et al. (2007), we introduced the “Movie Review Polarity Dataset Enriched with Annotator Rationales.”8","It is based on the dataset of Pang and Lee (2004),9","which consists of 1000 positive and 1000 negative movie reviews, tokenized and divided into 10 folds (F0–F9). All our experiments use F9 as their final blind test set.","The enriched dataset adds rationale annotations produced by an annotator A0, who annotated folds F0–F8 of the movie review set with rationales (in the form of textual substrings) that supported the gold-standard classifications. We will use A0’s data to determine the improvement of our method over a (log-linear) baseline model without rationales. We also use A0 to compare against the “masking SVM” method and SVM baseline of Zaidan et al. (2007).","Since φ can be tuned to a particular annotator, we would also like to know how well this works with data from annotators other than A0. We randomly selected 100 reviews (50 positive and 50 negative) and collected both class and rationale annotation data from each of six new annotators A3–A8,10","following the same procedures as (Zaidan et al., 2007). We report results using only data from A3–A5, since we used the data from A6–A8 as development data in the early stages of our work.","We use this new rationale-enriched dataset8","to determine if our method works well across annotators. We will only be able to carry out that comparison","8","Available at http://cs.jhu.edu/∼ozaidan/rationales.","9","Polarity dataset version 2.0.","10","We avoid annotator names A1–A2, which were already used in (Zaidan et al., 2007). 34 Figure 1: Rationales as sequence annotation: the annotator highlighted two textual segments as rationales for a positive class. Highlighted words in ⃗x are tagged I in ⃗r, and other words are tagged O. The figure also shows some φ-features. For instance, gO(,)-I is a count of O-I transitions that occur with a comma as the left word. Notice also that grel is the sum of the underlined values. at small training set sizes, due to limited data from A3–A8. The larger A0 dataset will still allow us to evaluate our method on a range of training set sizes."]},{"title":"5 Detailed Models 5.1 Modeling class annotations with","paragraphs":["pθ We define the basic classifier pθ in equation (1) to be a standard conditional log-linear model: pθ(y | x) def =","exp(⃗θ · ⃗f (x, y)) Zθ(x) def = u(x, y) Zθ(x) (2) where ⃗f (·) extracts a feature vector from a classified document, ⃗θ are the corresponding weights of those features, and Zθ(x) def =","∑","y u(x, y) is a normalizer.","We use the same set of binary features as in previous work on this dataset (Pang et al., 2002; Pang and Lee, 2004; Zaidan et al., 2007). Specifically, let V = {v1, ..., v17744} be the set of word types with count ≥ 4 in the full 2000-document corpus. Define fh(x, y) to be y if vh appears at least once in x, and 0 otherwise. Thus θ ∈ R17744",", and positive weights in θ favor class label y = +1 and equally discourage y = −1, while negative weights do the opposite.","This standard unigram feature set is linguistically impoverished, but serves as a good starting point for studying rationales. Future work should consider more complex features and how they are signaled by rationales, as discussed in section 3.2. 5.2 Modeling rationale annotations with pφ The rationales collected in this task are textual segments of a document to be classified. The document itself is a word token sequence ⃗x = x1, ..., xM . We encode its rationales as a corresponding tag sequence ⃗r = r1, ..., rM , as illustrated in Figure 1. Here rm ∈ {I, O} according to whether the token xm is in a rationale (i.e., xm was at least partly highlighted) or outside all rationales. x1 and xM are special boundary symbols, tagged with O.","We predict the full tag sequence ⃗r at once using a conditional random field (Lafferty et al., 2001). A CRF is just another conditional log-linear model:","pφ(r | x, y, ⃗θ) def =","exp(⃗φ · ⃗g(r, x, y, ⃗θ)) Zφ(x, y, ⃗θ) def = u(r, x, y, ⃗θ) Zφ(x, y, ⃗θ) where ⃗g(·) extracts a feature vector, ⃗φ are the corresponding weights of those features, and Zφ(x, y, ⃗θ) def","=","∑","r u(r, x, y, ⃗θ) is a normalizer.","As usual for linear-chain CRFs, ⃗g(·) extracts two kinds of features: first-order “emission” features that relate rm to (xm, y, θ), and second-order “transition” features that relate rm to rm−1 (although some of these also look at x).","These two kinds of features respectively capture the “channel model” and “language model” of section 3.2. The former says rm is I because xm is associated with a relevant θ-feature. The latter says rm is I simply because it is next to another I. 5.3 Emission φ-features (“channel model”) Recall that our θ-features (at present) correspond to unigrams. Given (⃗x, y, ⃗θ), let us say that a unigram w ∈ ⃗x is relevant, irrelevant, or anti-relevant if y · θw is respectively ≫ 0, ≈ 0, or ≪ 0. That is, w is relevant if its presence in x strongly supports the annotated class y, and anti-relevant if its presence strongly supports the opposite class −y. 35 Figure 2: The function family Bs in equation (3), shown for s ∈ {10, 2, −2, −10}.","We would like to learn the extent φrel to which annotators try to include relevant unigrams in their rationales, and the (usually lesser) extent φantirel to which they try to exclude anti-relevant unigrams. This will help us infer ⃗θ from the rationales.","The details are as follows. φrel and φantirel are the weights of two emission features extracted by ⃗g:","grel(⃗x, y, ⃗r, ⃗θ) def = M ∑ m=1 I(rm = I) · B10(y · θxm)","gantirel(⃗x, y, ⃗r, ⃗θ) def = M ∑ m=1 I(rm = I) · B−10(y · θxm) Here I(·) denotes the indicator function, returning 1 or 0 according to whether its argument is true or false. Relevance and negated anti-relevance are respectively measured by the differentiable nonlinear functions B10 and B−10, which are defined by Bs(a) = (log(1 + exp(a · s)) − log(2))/s (3) and graphed in Figure 2. Sample values of B10 and grel are shown in Figure 1.","How does this work? The grel feature is a sum over all unigrams in the document ⃗x. It does not fire strongly on the irrelevant or anti-relevant unigrams, since B10 is close to zero there.11","But it fires positively on relevant unigrams w if they are tagged with I, and the strength of such firing increases approximately linearly with θw. Since the weight φrel > 0 in practice, this means that raising a relevant unigram’s θw (if y = +1) will proportionately raise its log-odds of being tagged with I. Symmetrically, since φantirel > 0 in practice, lowering an anti-relevant unigram’s θw (if y = +1) will proportionately lower","11","B10 sets the threshold for relevance to be about 0. One could also include versions of the grel feature that set a higher threshold, using B10(y · θxm − threshold). its log-odds of being tagged with I, though not necessarily at the same rate as for relevant unigrams.12","Should φ also include traditional CRF emission features, which would recognize that particular words like great tend to be tagged as I? No! Such features would undoubtedly do a better job predict-ing the rationales and hence increasing equation (1). However, crucially, our true goal is not to predict the rationales but to recover the classifier parameters θ. Thus, if great tends to be highlighted, then the model should not be permitted to explain this directly by increasing some feature φgreat, but only indirectly by increasing θgreat. We therefore permit our rationale prediction model to consider only the two emission features grel and gantirel, which see the words in ⃗x only through their θ-values. 5.4 Transition φ-features (“language model”) Annotators highlight more than just the relevant unigrams. (After all, they aren’t told that our current θ-features are unigrams.) They tend to mark full phrases, though perhaps taking care to exclude anti-relevant portions. φ models these phrases’ shape, via weights for several “language model” features.","Most important are the 4 traditional CRF tag transition features gO-O, gO-I, gI-I, gI-O. For example, gO-I counts the number of O-to-I transitions in ⃗r (see Figure 1). Other things equal, an annotator with high φO-I is predicted to have many rationales per 1000 words. And if φI-I is high, rationales are predicted to be long phrases (including more irrelevant unigrams around or between the relevant ones).","We also learn more refined versions of these features, which consider how the transition probabilities are influenced by the punctuation and syntax of the document ⃗x (independent of ⃗θ). These refined features are more specific and hence more sparsely trained. Their weights reflect deviations from the simpler, “backed-off” transition features such as gO-I. (Again, see Figure 1 for examples.) Conditioning on left word. A feature of the form gt1(v)-t2 is specified by a pair of tag types t1, t2 ∈ {I, O} and a vocabulary word type v. It counts the","12","If the two rates are equal (φrel = φantirel), we get a simpler model in which the log-odds change exactly linearly with θw for each w, regardless of w’s relevance/irrelevance/anti-relevance. This follows from the fact that Bs(a) + B−s(a) simplifies to a. 36 number of times an t1–t2 transition occurs in ⃗r conditioned on v appearing as the first of the two word tokens where the transition occurs. Our experiments include gt1(v)-t2 features that tie I-O and O-I transitions to the 4 most frequent punctuation marks v (comma, period, ?, !). Conditioning on right word. A feature gt1-t2(v) is similar, but v must appear as the second of the two word tokens where the transition occurs. Again here, we use gt1-t2(v) features that tie I-O and O-I transitions to the four punctuation marks mentioned above. We also include five features that tie O-I transitions to the words no, not, so, very, and quite, since in our development data, those words were more likely than others to start rationales.13 Conditioning on syntactic boundary. We parsed each rationale-annotated training document (no parsing is needed at test time).14","We then marked each word bigram x1-x2 with three nonterminals: NEnd is the nonterminal of the largest constituent that contains x1 and not x2, NStart is the nonterminal of the largest constituent that contains x2 and not x1, and NCross is the nonterminal of the smallest constituent that contains both x1 and x2.","For a nonterminal N and pair of tag types (t1, t2), we define three features, gt1-t2/E=N , gt1-t2/S=N , and gt1-t2/C=N , which count the number of times a t1-t2 transition occurs in ⃗r with N matching the NEnd, NStart, or NCross nonterminal, respectively. Our experiments include these features for 11 common nonterminal types N (DOC, TOP, S, SBAR, FRAG, PRN, NP, VP, PP, ADJP, QP)."]},{"title":"6 Training: Joint Optimization of θ and φ","paragraphs":["To train our model, we use L-BFGS to locally maximize the log of the objective function (1):15","13","These are the function words with count ≥ 40 in a random sample of 100 documents, and which were associated with the O-I tag transition at more than twice the average rate. We do not use any other lexical φ-features that reference ⃗x, for fear that they would enable the learner to explain the rationales without changing θ as desired (see the end of section 5.3).","14","We parse each sentence with the Collins parser (Collins, 1999). Then the document has one big parse tree, whose root is DOC, with each sentence being a child of DOC.","15","One might expect this function to be convex because pθ and pφ are both log-linear models with no hidden variables. How-ever, log pφ(ri | xi, yi, θ) is not necessarily convex in θ. n ∑ i=1 log pθ(yi | xi) − 1 2σ2 θ ∥θ∥2 +C( n ∑ i=1 log pφ(ri | xi, yi, θ)) − 1 2σ2 φ","∥φ∥2 (4)","This defines pprior from (1) to be a standard diago-","nal Gaussian prior, with variances σ2","θ and σ2","φ for the","two sets of parameters. We optimize σ2 θ in our experiments. As for σ2","φ, different values did not affect the results, since we have a large number of {I,O} rationale tags to train relatively few φ weights; so we simply use σ2","φ = 1 in all of our experiments.","Note the new C factor in equation (4). Our initial experiments showed that optimizing equation (4) without C led to an increase in the likelihood of the rationale data at the expense of classification accuracy, which degraded noticeably. This is because the second sum in (4) has a much larger magnitude than the first: in a set of 100 documents, it predicts around 74,000 binary {I,O} tags, versus the one hundred binary class labels. While we are willing to reduce the log-likelihood of the training classifications (the first sum) to a certain extent, focusing too much on modeling rationales (the second sum) is clearly not our ultimate goal, and so we optimize C on development data to achieve some balance between the two terms of equation (4). Typical values of C range from 1","300 to 1","50 .16","We perform alternating optimization on θ and φ: 1. Initialize θ to maximize equation (4) but with","C = 0 (i.e. based only on class data). 2. Fix θ, and find φ that maximizes equation (4). 3. Fix φ, and find θ that maximizes equation (4). 4. Repeat 2 and 3 until convergence.","The L-BFGS method requires calculating the gradient of the objective function (4). The partial derivatives with respect to components of θ and φ involve calculating expectations of the feature functions, which can be computed in linear time (with respect to the size of the training set) using the forward-backward algorithm for CRFs. The partial derivatives also involve the derivative of (3), to determine how changing θ will affect the firing strength of the emission features grel and gantirel.","16","C also balances our confidence in the classifications y against our confidence in the rationales r; either may be noisy. 37"]},{"title":"7 Experimental Procedures","paragraphs":["We report on two sets of experiments. In the first set, we use the annotation data that A3–A5 provided for the small set of 100 documents (as well as the data from A0 on those same 100 documents). In the second set, we used A0’s abundant annotation data to evaluate our method with training set sizes up to 1600 documents, and compare it with three other methods: log-linear baseline, SVM baseline, and the SVM masking method of (Zaidan et al., 2007). 7.1 Learning curves The learning curves reported in section 8.1 are generated exactly as in (Zaidan et al., 2007). Each curve shows classification accuracy at training set sizes T = 1, 2, ..., 9 folds (i.e. 200, 400, ..., 1600 training documents). For a given size T , the reported accuracy is an average of 9 experiments with different subsets of the entire training set, each of size T : 1 9 8 ∑ i=0 acc(F9 | Fi+1 ∪ . . . ∪ Fi+T ) (5) where Fj denotes the fold numbered j mod 9, and acc(F9 | Y ) means classification accuracy on the held-out test set F9 after training on set Y .","We use an appropriate paired permutation test, detailed in (Zaidan et al., 2007), to test differences in (5). We call a difference significant at p < 0.05. 7.2 Comparison to “masking SVM” method We compare our method to the “masking SVM” method of (Zaidan et al., 2007). Briefly, that method used rationales to construct several so-called contrast examples from every training example. A contrast example is obtained by “masking out” one of the rationales highlighted to support the training example’s class. A good classifier should have more trouble on this modified example. Hence, Zaidan et al. (2007) required the learned SVM to classify each contrast example with a smaller margin than the corresponding original example (and did not require it to be classified correctly).","The masking SVM learner relies on a simple geometric principle; is trivial to implement on top of an existing SVM learner; and works well. However, we believe that the generative method we present here is more interesting and should apply more broadly. Figure 3: Classification accuracy curves for the 4 methods: the two baseline learners that only utilize class data, and the two learners that also utilize rationale annotations. The SVM curves are from (Zaidan et al., 2007).","First, the masking method is specific to improving an SVM learner, whereas our method can be used to improve any classifier by adding a rationale-based regularizer (the second half of equation (4)) to its objective function during training.","More important, there are tasks where it is unclear how to generate contrast examples. For the movie review task, it was natural to mask out a rationale by pretending its words never occurred in the document. After all, most word types do not appear in most documents, so it is natural to consider the non-presence of a word as a “default” state to which we can revert. But in an image classification task, how should one modify the image’s features to ignore some spatial region marked as a rationale? There is usually no natural “default” value to which we could set the pixels. Our method, on the other hand, eliminates contrast examples altogether."]},{"title":"8 Experimental Results and Analysis 8.1 The added benefit of rationales","paragraphs":["Fig. 3 shows learning curves for four methods. A log-linear model shows large and significant improvements, at all training sizes, when we incorporate rationales into its training via equation (4). Moreover, the resulting classifier consistently out-performs17","prior work, the masking SVM, which starts with a slightly better baseline classifier (an SVM) but incorporates the rationales more crudely.","17","Differences are not significant at sizes 200, 1000, and 1600. 38","size A0 A3 A4 A5 SVM baseline 100 72.0 72.0 72.0 70.0 SVM+contrasts 100 75.0 73.0 74.0 72.0 Log-linear baseline 100 71.0 73.0 71.0 70.0 Log-linear+rats 100 76.0 76.0 77.0 74.0 SVM baseline 20 63.4 62.2 60.4 62.6 SVM+contrasts 20 65.4 63.4 62.4 64.8 Log-linear baseline 20 63.0 62.2 60.2 62.4 Log-linear+rats 20 65.8 63.6 63.4 64.8 Table 1: Accuracy rates using each annotator’s data. In a given column, a value in italics is not significantly different from the highest value in that column, which is boldfaced. The size=20 results average over 5 experiments.","To confirm that we could successfully model annotators other than A0, we performed the same comparison for annotators A3–A5; each had provided class and rationale annotations on a small 100-document training set. We trained a separate φ for each annotator. Table 1 shows improvements over baseline, usually significant, at 2 training set sizes. 8.2 Analysis Examining the learned weights ⃗φ gives insight into annotator behavior. High weights include I-O and O-I transitions conditioned on punctuation, e.g., φI(.)-O = 3.55,18","as well as rationales ending at the end of a major phrase, e.g., φI-O/E=VP = 1.88.","The large emission feature weights, e.g., φrel = 14.68 and φantirel = 15.30, tie rationales closely to θ values, as hoped. For example, in Figure 1, the word w = succeeds, with θw = 0.13, drives up p(I)/p(O) by a factor of 7 (in a positive document) relative to a word with θw = 0.","In fact, feature ablation experiments showed that almost all the classification benefit from rationales can be obtained by using only these 2 emission φ-features and the 4 unconditioned transition φ- features. Our full φ (115 features) merely improves our ability to predict the rationales (whose likelihood does increase significantly with more features).","We also checked that annotators’ styles differ enough that it helps to tune φ to the “target” annotator A who gave the rationales. Table 3 shows that a φ model trained on A’s own rationales does best at predicting new rationales from A. Table 2 shows that as 18 When trained on folds F4–F8 with A0’s rationales.","φA0 φA3 φA4 φA5 Baseline θA0 76.0 73.0 74.0 73.0 71.0 θA3 73.0 76.0 74.0 73.0 73.0 θA4 75.0 73.0 77.0 74.0 71.0 θA5 74.0 71.0 72.0 74.0 70.0 Table 2: Accuracy rate for an annotator’s θ (rows) obtained when using some other annotator’s φ (columns). Notice that the diagonal entries and the baseline column are taken from rows of Table 1 (size=100).","Trivial","φA0 φA3 φA4 φA5 model −L(rA0) 0.073 0.086 0.077 0.088 0.135 −L(rA3) 0.084 0.068 0.071 0.068 0.130 −L(rA4) 0.088 0.084 0.075 0.085 0.153 −L(rA5) 0.058 0.044 0.047 0.044 0.111 Table 3: Cross-entropy per tag of rationale annotations ⃗r for each annotator (rows), when predicted from that annotator’s ⃗x and ⃗θ via a possibly different annotator’s φ (columns). For comparison, the trivial model is a bigram model of ⃗r, which is trained on the target annotator but ignores ⃗x and ⃗θ. 5-fold cross-validation on the 100-document set was used to prevent testing on training data. a result, classification performance on the test set is usually best if it was A’s own φ that was used to help learn θ from A’s rationales. In both cases, however, a different annotator’s φ is better than nothing."]},{"title":"9 Conclusions","paragraphs":["We have demonstrated a effective method for eliciting extra knowledge from naive annotators, in the form of lightweight “rationales” for their annotations. By explicitly modeling the annotator’s rationale-marking process, we are able to infer a better model of the original annotations.","We showed that our method performs significantly better than two strong baseline classifiers, and also outperforms our previous discriminative method for exploiting rationales (Zaidan et al., 2007). We also saw that it worked across four annotators who have different rationale-marking styles.","In future, we are interested in new domains that can adaptively solicit rationales for some or all training examples. Our new method, being essentially Bayesian inference, is potentially extensible to many other situations—other tasks, classifier architectures, and more complex features. 39"]},{"title":"References","paragraphs":["Eric Brill and Grace Ngai. 1999. Man [and woman] vs. machine: A case study in base noun phrase learning. In Proceedings of the 37th ACL Conference.","Michael Collins. 1999. Head-Driven Statistical Models for Natural Language Parsing. Ph.D. thesis, University of Pennsylvania.","G. Druck, G. Mann, and A. McCallum. 2008. Learning from labeled features using generalized expecta-tion criteria. In Proceedings of ACM Special Interest Group on Information Retrieval, (SIGIR).","A. Haghighi and D. Klein. 2006. Prototype-driven learning for sequence models. In Proceedings of the Human Language Technology Conference of the NAACL, Main Conference, pages 320–327, New York City, USA, June. Association for Computational Linguistics.","John Lafferty, Andrew McCallum, and Fernando Pereira. 2001. Conditional random fields: Probabilistic models for segmenting and labeling sequence data. In Proceedings of the International Conference on Machine Learning.","Grace Ngai and David Yarowsky. 2000. Rule writing or annotation: Cost-efficient resource usage for base noun phrase chunking. In Proceedings of the 38th Annual Meeting of the Association for Computational Linguistics, pages 117–125, Hong Kong.","B. Pang and L. Lee. 2004. A sentimental education: Sentiment analysis using subjectivity summarization based on minimum cuts. In Proc. of ACL, pages 271– 278.","B. Pang, L. Lee, and S. Vaithyanathan. 2002. Thumbs up? Sentiment classification using machine learning techniques. In Proc. of EMNLP, pages 79–86.","Hema Raghavan and James Allan. 2007. An interactive algorithm for asking and incorporating feature feedback into support vector machines. In Proceedings of SIGIR.","Hema Raghavan, Omid Madani, and Rosie Jones. 2006. Active learning on both features and instances. Jour-nal of Machine Learning Research, 7:1655–1686, Aug.","Luis von Ahn, Ruoran Liu, and Manuel Blum. 2006. Peekaboom: A game for locating objects. In CHI ’06: Proceedings of the SIGCHI Conference on Human Factors in Computing Systems, pages 55–64.","Omar Zaidan, Jason Eisner, and Christine Piatko. 2007. Using “annotator rationales” to improve machine learning for text categorization. In NAACL HLT 2007; Proceedings of the Main Conference, pages 260–267, April. 40"]}]}