{"sections":[{"title":"Computing Declarative Prosodic Morphology Markus Walther","paragraphs":["Seminar ftir Allgemeine Sprachwissenschaft","Heinrich-Heine-Universit~it Dtisseldorf","Universit~itsstr. 1, D-40225 Dtisseldorf, Germany","wal ther@ling, uni-duesseldor f. de"]},{"title":"Abstract","paragraphs":["This paper describes a computational, declarative approach to prosodic morphology that uses inviolable constraints to denote small finite candidate sets which are filtered by a restrictive incremental optimization mechanism. The new approach is illustrated with an implemented fragment of Modern Hebrew verbs couched in MicroCUF, an expressive constraint logic formalism. For generation and parsing of word forms, I propose a novel off-line technique to eliminate run-time optimization. It produces a finite-state oracle that efficiently restricts the constraint interpreter's search space. As a byproduct, unknown words can be analyzed without special mechanisms. Unlike pure finite-state transducer approaches, this hybrid setup allows for more expressivity in constraints to specify e.g. token identity for reduplication or arithmetic constraints for phonetics. 1"]},{"title":"Introduction","paragraphs":["Prosodic morphology (PM) circumscribes a number of phenomena ranging from 'nonconatenative' root-and-pattern morphology over infixation to various cases of reduplication, where the phonology strongly influences the shape of words by way of obedience to structural constraints defining wellformed morae, syllables, feet etc. These phenomena have been difficult to handle in earlier rule-based treatments (Sproat 1992, 159 ft.). Moreover, as early as Kisseberth (1970) authors have noted that derivational accounts of PM are bound to miss important linguistic generalizations that are best expressed via constraints. Kisseberth showed that verb stems in Tonkawa, a Coahuiltecan language, display a complex V/~ alternation pattern when various affixes are added (fig. 1). This leads to more and more complicated vowel deletion rules as the fragment is enlarged. In contrast, a straightforward constraint that bans three consecutive consonants offers a unified account of the conditions under which vowels must surface. Later devel- 'to cut' \"to lick' picn-o? we-pcen-o? picna-n-o? netl-o? ( 3sg.obj.stem-3sg.subj. ) we-ntal-o?"]},{"title":"( 3pl.obj.-stem-3sg.subj. )","paragraphs":["netle-n-o?"]},{"title":"( 3sg.obj.stem-prog.-3sg.subj. )","paragraphs":["p(i)c(e)n(a) n(e)t(a)l(e) stems Figure 1: Tonkawa verb forms with V/~ effects opments have refined constraints such as ,CCC to refer to syllable structure instead: complex codas and onsets are disallowed. At least since Kahn (1976), Selkirk (1982), such segment-independent reference to syllable structure has been standardly assumed in the generative literature.","Astonishing as it may be, even the latest computational models of PM phenomena apparently eschew the incorporation of real prosodic representations, syllabification and constraints. Kiraz (1996) uses multi-~tape two-level morphology to analyze some Arabic data, but - despite the suggestive title - must simulate prosodic operations such as 'add a mora' by their extensionalized rule counterparts, which refer to C or V segments instead of moras. There is no on-line syllabification and the exclusive use of lexically prespecified syllable-like symbols on a separate templatic pattern tape renders his approach vulnerable to postlexical resyllabification effects. Similarly, Beesley (1996) seems content in employing a great number of CV templates in his large-scale finite-state model of Arabic morphology, which are intersected with lexical roots and then transformed to surface realizations by various epenthesis, deletion and assimilation rules. Beesley states that further application of his approach to e.g. Hebrew is foreseen. On the downside, however, again there is no real prosody in his model; the relationship between template form and prosody is not captured.","Optimality Theory (OT, Pnnce & Smolensky 1993), as applied to PM (McCarthy & Prince 1993), does claim to capture this relationship, using a 11 ranked set of violable prosodic constraints together with global violation minimization. However, to date there exist no sufficiently formalized analyses of nontrivial PM fragments that could be turned into testable computational models. The OT framework itself has been shown to be expressible with weighted finite-state automata, weighted intersection and bestpath algorithms (Ellison 1994) if constraints and OT's GEN component - the function from under-lying forms to prosodified surface forms - are regular sets. A recent proposal by Karttunen (1998) dispenses with the weights while still relying on the same regularity assumption. Published PM analyses, however, frequently make use of constraint Â• parametrizations from the ALIGN family, which requires greater than regular power (Ellison 1995). Further developments of OT such as correspondence theory - extensively used in much newer work on PM - have not received a formal analysis so far. Finally, although OT postulates that constraints are universal, this metaconstraint has been violated from the outset, e.g. in presenting Tagalog -um- as a language-specific parameter to ALIGN in Pnnce & Smolensky (1993). Due to the convincing presentation of a number of other forceful arguments against constraint universality in Ellison (to appear), the case for language-specific constraints must clearly be seen as reopened, and - as a corollary - the case for constraint inviolability as well.","Declarative Phonology (DP, Bird 1995, Scobbie 1991 ) is just such a constraint-based framework that dispenses with violability and requires a monostratal conception of phonological grammar, as compared to the multi-level approaches discussed above. Both abstract generalizations and concrete morphemes are expressed by constraints. DP requires analyses to be formally adequate, i.e. use a grammar description language with formal syntax and semantics. As a consequence, Chomsky's crteda for a generative grammar which must be \"perfectly explicit\" and \"not rely on the intelligence of the understanding reader\" (Chomsky 1965, 4) are automatically fulfilled. DP thus appears to be a good starting point for a restrictive, surface-true theory of PM that is explicitly computational.","The rest of this paper reviews in informal terms the theory of Walther (1997) (section 2), showing in formal detail in section 3 how to implement a concrete analysis of Modern Hebrew verbs. Section 4 explains a novel approach to both generation and parsing of word forms under the new theory. The paper concludes in section 5."]},{"title":"2 Declarative Prosodic Morphology","paragraphs":["Focussing on cases of 'nonconcatenative' root-and-pattern morphology, Declarative Prosodic Morphology (DPM) starts with an intuition that is opposite to what the traditional idea of templates or fixed phonological shapes (McCarthy 1979) suggests, namely that shape variance is actually quite common and should form the analytical basis for theoretical accounts of PM. Besides the Tonkawa case (fig.l), shape variance is also at work in Modern Hebrew (MH) inflected verb forms (Glinert 1989), see fig. 2.1 Here we see a systematic V/O alternation of both","past future","l sg gamar-ti","2sg.m"]},{"title":"gamar-ta","paragraphs":["2sg.f gamar-t 3sg.m gamar 3sg.f gamr-a lpl gamar-nu 2pl gamar-tem 3pl gamr-u ?e-gmor ti-gmor ti-gmer-i ji-gmor ti-gmor ni-gmor ti-gmer-u ji-gmer-u Figure 2: Modern Hebrew xfg.m.r ~nish' (B1) stem vowels, depending on the affixation pattern. This results in three stem shapes CVCVC, CVCC and CCVC. Any analysis that simply stipulates shape selection on the basis of specific inflectional categories or phonological context (e.g. 3sg.f V 3pl or -V .-~"]},{"title":"CVCCstem","paragraphs":["/ B 1 past) misses the fact that the shapes, their alternating behaviour and their proper selec-tion are derivable. Derivational repairs by means of 'doubly open syllable' syncope rules (/ga.ma.r-a./ /.gam.ra./) are similarly ad hoc.","Â• A first step in developing an alternative DPM analysis of MH verbs is to explicitly recognize alternation of an element X with zero - informally written (X) - as a serious formal device besides its function as a piece of merely descriptive notation (cf. Hudson 1986 for an earlier application to Arabic). In contrast to nonmonotonic deletion or epenthesis, (X) is a surface-true declarative expression (Bird 1995, 93f.). The reader is reminded","tRegular MH verbs are traditionally divided into seven verbal classes or binyanim, B I-B7. Except for B4 and B6, which regularly act as passive counterparts of B3 and B4, the semantic contribution of each class is no longer transparent in the modem language. Also, in many cases the root (written ~/'C~ .C~.Cs) is restricted to an idiosyncratic subset of the binyanim.","An a-templatic treatment of MH prosodic morphology was first proposed by Bat-El (1989, 40ff.) within an unformalized, non-surface-tree, non-constraint-based setting."]},{"title":"12","paragraphs":["that DP sees grammar expressions as partial formal"]},{"title":"descriptions of sets","paragraphs":["of phonological objects. The former reside on a different ontological level from the latter, in contrast to traditional object-to-object transformations on the same level. Hence a preliminary grammar expression"]},{"title":"g(V1)m(V2)r","paragraphs":["for a Hebrew stem (with abstract stem vowels) denotes the"]},{"title":"set","paragraphs":["{gmr,"]},{"title":"gVlmr,","paragraphs":["gmV2r,"]},{"title":"gVlmV2r).","paragraphs":["Note that the (X) property as attributed to segmental positions is distinctive - in contrast to stem vowels root segments do not normally alternate with zero, and neither do affix segments in an important asymmetry with stems. This point is reinforced by the exceptions that do exist: phonologically unpredictable C/~ alternation occurs in some MH stems, e.g."]},{"title":"natan/lakax","paragraphs":["'he gave/took'"]},{"title":"vsfi-ten/ji-kax","paragraphs":["'he will give/take'; by surface-true"]},{"title":"(n/l)","paragraphs":["encoding we can avoid diacritical","solutions here.","Â• Step two uses concatenation to combine indi-","vidual"]},{"title":"descriptions","paragraphs":["of stems and affixes, besides connecting segmental positions"]},{"title":"within","paragraphs":["these linguistic entities. Since, as we have just seen, a single description can denote several objects of varying surface stnng length, concatenation ()̂ at the description level is actually powerful enough to describe 'nonconcatenative' morphological phenomena. In DPM these do not receive independent ontological status (cf. Bird & Klein 1990 and Gafos 1995 for other formal and articulatory-phonological arguments leading to the same conclusion). A more detailed description of the 3pl.fut. inflected form of"]},{"title":"x~g.m.r","paragraphs":["might therefore be"]},{"title":"jîĝ'(V1)m̂(̂V2)rû.","paragraphs":["In order to allow for paradigmatic 2 generalizations over independent entities such as root and stem vowel pattern"]},{"title":"within","paragraphs":["concatenated descriptions, a hierarchical lexicon conception based on multiple inheritance of named abstractions can be used (cf. Riehemann 1993).","Â• Step three conjoins a word form description with declarative syllabification and syllable structure constraints in order to impose prosodic well-formedness conditions. For Modem Hebrew (and Tonkawa), the syllable canon is basically CV(C). Expressed in prosodic terms, complex codas and onsets are banned, while an onset must precede each syllable nucleus. These syllable roles are established in the first place by syllabification constraints that exploit local sonority differences between successive segments (Walther 1993). Alltogether, the ensemble","2See Walther (1997) for a discussion of various ways to derive rather than stipulate the syntagmatic pattern of alternating and non-alternating segmental positions within stems. of prosodic Constraints indeed succeeds in narrow-ing down the set for the 3sg.m past tense form to {*.9mr.,"]},{"title":"*.9amr., *.9mar., !.9a.mar.} = /gamar/.","paragraphs":["For 3pl. future tense B1, how-ever, an unresolved ambiguity remains: in"]},{"title":"{.jig.me.ru.,.ji.gam.ru.},","paragraphs":["only the first element is grammatical. 3 An important observation is that in general there can be no purely phonological constraint to disambiguate this type of situation. The reason lies in the existence of minimal pairs with different category. In our case, homophonous /.ji.gam.ru./ is grammatical as 3pl. fut."]},{"title":"B2","paragraphs":["'they will be finished'. We will return to the analysis of such cases after proposing a specific disambiguation mechanism in the next step.","Â• Step four eliminates the remaining ambiguity by invoking an Incremental Optimization Principle (IOP): \"For all (X) elements, prefer the zero altemant as early as possible\". \"Early\" corresponds to traditional left-to-right directionality, but is meant to be understood w.r.t, the speech production time arrow. \"As possible\" means that IOP application to a (X) position nevertheless realizes X if its omission would lead to a constraint conflict. Hence, the IOP correctly rules out the second element of"]},{"title":"{.jig.me.ru.,*.ji.9ara.ru.}.","paragraphs":["This is because"]},{"title":".ji.gam.ru.","paragraphs":["represents a missed chance to leave out /a/, the earlier one of the two stem vowels. The reader may verify that the IOP as it stands also accounts for the Tonkawa data of fig. I. Tonkawa lends even clearer support to IOP's left-to-right nature due to the larger number of V/O vowels involved. As a limit-ing case, the IOP predicts the possibility of vowel-less surface stems, e.g. formed by two root consonants combined with vowel-final prefix and suffix. This prediction is strikingly confirmed by MH forms like"]},{"title":"te-lx-i","paragraphs":["'you (sg.f.) will go'"]},{"title":"~/(h).l.x, ti-kn-u","paragraphs":["'you/they (pl.) will buy'"]},{"title":"~/'k.n.O, ti-tn-i","paragraphs":["'you (sg.f.) will give' ~/(n).t.n; similar cases exist in Tigdnya. There can be no meaningful prosodic characterization of isolated"]},{"title":"CC stem","paragraphs":["shapes; only a wordformbased theory like the present one may explain why these forms exist.","Note that, conceptually, IOP is piggybacked on autonomous DP-style constraint interaction. It merely filters the small finite set of objects described by the conjunction of all constraints. From another an-gle, IOP can be seen as a single context-free sub-","3Note that the prosodic view explains the pronounced influ-ence of (C)V affixes on the shape of the whole word: they provide a nonalternating syllable nucleus which can host adjacent stem consonants. 13 stitute for the various syncope rules employed in former transformational analyses. The claim is that fixed-directionality-IOP is the only such mechanism needed to account for PM phenomena.","A distinguishing feature of the IOP is its potential for an economical procedural implementation in incremental production. If constraint contexts are sufficiently local, the pnnciple can locally decide over (X) nonrealizations and there will be very limited backtracking through delayed detection of constraint violation. Because the IOP stops after find-ing the first (X) realization pattern that violates no constraints, it has less formal power than global optimization which must always consider all candidates. Moreover, the IOP supports economic communica-tion, as it leads to shortest surface forms wherever possible. Finally, at least for root-and-pattern morphologies it can be argued to aid in speech perception as well. This is because the closed class of stem vowel patterns is less informative than open-class root segments. Since IOP-guided vowel omission causes root segments to (statistically) appear at an earlier point in time from the acoustic onset of the word, the IOP hypothesis actively prunes the size of the cohort of competing lexical candidates. As a result, unambigous recognition will generally be achieved more quickly during continous lexical access. In sum, the IOP hypothesis not only possesses overall psycholinguistic plausibility but actually gives some processing advantage to shape variance. If future research provides the necessary experimental confirmation, we have yet another case of performance shaping competence.","Â• Step five returns to the minimal pairs problem highlighted in step three: what to do with anti-IOP realizations such as that of/a/in/.ji.gam.ru./for B2 fut.? The answer is (prosodic) prespecification. A surface-true constraint demands that B2 future and infinitive as well as all of B3, B4 must have an onset role for the first stem element. Thus, the possibility of IOP eliminating the first stem vowel is blocked by the constraint inconsistency that arises for the first stem element: either syllabification licenses an in-compatible coda or first and second stem segment together form an illformed onset cluster. Note that if the constraint is lexicalized as part of the grammatical description of first stem position, it will have a maximally local context, referring to just the position itself. In general, DPM analyses pay much attention to proper attachment sites of constraints in order to maximize their locality.","The MH verbal suffix -et (fem.sg.pres.) illustrates that sometimes another, segmental mode of prespecification is useful. This suffix is always preceded by a syllable ending in /el, although IOP application alone would e.g. prefer */gom.ret/over/go.me.ret/ 'she finishes'. The effect is morpheme-specific since other -VC suffixes behave as expected here: gomrim/ot 'they (masc./fem.) finish'. One solution is to let part of the suffix definition be a constraint statement which demands that the segment two positions to its left must be a front vowel. This move captures both the stability and the quality of this vowel at the same time. (Apophony constraints ensure that the second stem vowel is never/i/except in B5, which significantly has a different suffix -a in place of -et). Note that prespecifying the presuffixal segment to be in an onset position would not work. 3 On implementing analyses In the following I show how to implement a toy fragment of MH verbs using the MicroCUF formalism, a typed, feature-based constraint-logic programming language suitable for natural language modelling. MicroCUF implements a subset of CUF (D6rre & Dorna 1993), inheriting its formal semantics. It was initially delevoped by the author to overcome efficiency problems with CUF's original type system. Additionally, its simpler implemenation provides an open platform for experimental modifications, as needed e.g. for parsing and generation with DPM. After briefly introducing the essentials of MicroCUF first, the MH analysis is developed and explained. 3.1 The MicroCUF constraint formalism This section assumes a basic knowledge of Prolog. Like in Prolog, MicroCUF variables start with upper-case letters or _ , whereas relational symbols, features and simplex types start in lowercase; % marks a comment (fig. 3a). Relations like member are written in functional notation, with a notationally distinguished result argument on the nghthand side of : = and the relation symbol plus its (optional) arguments on the lefthand side. Subgoals like member (Elem) Can occur anywhere as subterms. Instead of Prolog's fixed-arity first order terms, MicroCUF has typed feature terms as its basic data structures. As illustrated in fig. 3b, subterms are explicitly conjoined with & or disjunctively combined with ;, while only type terms may be prefixed by the negation operator ,-.,. Features like left, cat are separated from their righthand value terms by :. Terms may be tagged by conjunction with a variable (vl), allowing for the expression of structure sharing through mul-14 tiple occurences of the same variable. Feature appropriateness declarations ( : : ) ensure that both the term in which a feature occurs and its value are typed. For comparison, the result value of fs appears in HPSG-style notation under fig. 3c. a. % MicroCUF member(Elem) := [ElemI_]. member(Elem) := [_Imember(Elem)]. %Prolog member(Elem, [Eleml_]). member(Elem, [_IRest]) :- member(Elem, Rest). b. fs:=cat: (~((b2;b3;b5)&past)&Vl)&left:cat:Vl. phonlist::[cat:categories]. segmental positions to the left - a frequent situation in phonological contexts - we supplement it with a new feature left to yield bidirectional lists. For this doubly-linked list encoding to be wellbehaved, a step right followed by a step left is constrained to return to the same position Self (3), thus yielding cyclic feature structures. Next, the value of the feature cat at the current position is connected with its right neighbour (3-4). In the face of our recursively structured lists this makes morphological and other global categorial information locally accessible at each segmental position. Finally, relations to incrementally classify each segmental position as word-initial, medial or wordfinal and to impose prosodic constraints are added in (5-6).","Basic concatenation is used in (10-12) to define X/O positions. C. fs plzotzlist"]},{"title":"]","paragraphs":["eat ~ ~ ( (b2 v b3 v b5) ̂past ) left r phOnlist ]","[cat D] Figure 3: MicroCUF vs Prolog and HPSG notation 3.2 Modern Hebrew verbs in MicroCUF Below I present a concrete MicroCUF grammar in successive pieces. It encodes a toy fragment of MH verbs and represents a simplified excerpt from a much larger computational grammar. For lack of space, the type hierarchy - specifying syllable roles, segments, morphological categories and word-peripheral position - and the definition of syllabi fy (formalized in Walther 1995) have been omitted.","Let us start the explanation with a basic concatenation relation which adds a position Self in front of some string of Segments (1-6). 1 conc(Self, Segments) := 2 Self & 3 right:(Segments&left:Self&cat:Cat) 4 cat:Cat & 5 classify_position_in_word & 6 constraints. 7 8 classify_position_in_word := 9 right:self:'-ini' & left:self:'-fin'. Here, the familiar recursive first-rest encoding of lists translates into self-right features. This alone makes self and (arbitrarily long) right-context references possible. To support looking one or more i0 ii 12 13 14 15 16 17 x_0(_, Segments) := segments. x_0(X, Segments) := mark:marked &","conc(X, Segments).","obl(X, Segments) := mark:unmarked & conc(X, Segments). is(Segment) := self:seg:Segment. The first clause of x_0 (10) realizes the zero alternant by equating in its second argument the Segments to follow with the result argument; the first argument holding x is unused. It gets used in the second clause (11-12), however, where it is prefixed to the following Segments by ordinary concatenation. The value of an additional feature mark specifies that realiz-ing an X position is marked w.r.t, the IOP, whereas no such value is prescribed in the first clause. Instead, the marking there will be supplied later by adjacent instances of either the second x_0 clause or obl (14-15). The latter is the version of concatenation used for specifying obligatory, i.e. nonalternating positions, which consequently are specified as unmarked. Alltogether these means yield fully specified strings w.r.t, markedness information. We will see below how this simplifies an implementation of the IOP.","As can be seen in the accessor relation is (17), phonological segments are actually embedded under a further feature seg. This treatment enables structure-sharing of segments independent of their syllable roles.","The syllable shape constraint (18-25) shows first of all that syllable roles are modelled as O,pes under self. 15 18 shape := 19 ( self:(nucleus & seg:vowel) & 20 left:self:onset 21 ; self:(-nucleus) & 22 ( self:onset & left:self: (-onset) 23 ; self:coda & left:self:(-coda) 24 ) 25 ). 26 27 constraints := syllabify & shape. Lines (19-20) capture the fact that syllable nuclei in MH are always vowels and that every syllable nucleus is preceded by an onset. In (21-22) a nonnuclear position that is an onset may only license preceding non-onsets, thus disallowing complex onsets; similarly for codas in (23). In (27) genetic"]},{"title":"syllabify is intersected with shape, since segmental positions must be prosodified and conform to language-specific shape restrictions. The constraints under (28-30), included for completeness, merely ensure proper termination of segmental strings at the word periphery.","paragraphs":["28 word 29 end 30 := self:('+ini' & prom:up & onset). := left:self:('+fin' & -onset) &","self:'-fin' Prosodic prespecification (31-36) faithfully models what was stated in prose in section 2. 31 prosodic_prespecification := 32 (cat:((b2&(-(past;pres)));b3;b4) & 33 self:onset 34 ; 35 cat:(~((b2& (-(past;pres)));b3;b4)) 36 ). We proceed in (37-41) with a rudimentary definition of first (vl) and second (v2) stem vowel which is sufficient for our toy fragment. 37 vl := is(low) & cat:(past & bl;b7). 38 vl := is(round & '-hi') & 39 cat:(bl & ~ past). 40 v2 := is(low). 41 v2 := is(front & '-hi'). The larger grammar mentioned above contains a full binary decision tree for each vowel. Still, even here one can see the use of type formulae like round & ' -hi' to classify segments phonologically.","Next come a number of exemplary inflectional affixes (42-79), again simplified. The zero affixes (42-45, 47-54) are phonologically just like the zero alternant in (10) in taking up no segmental space. 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60","% initial \"0\" prefix","'#'(More) := More & self:'+ini' &","cat:(- fut & - infinitive &","( bl ; (~ pres & (b3 ; b4))","% final \"0\" suffix","'#'(More) := More &","self:'-ini' & left:self:'+fin' &","( cat:(sg & masc & third & past) & left:left:is(-front)","; cat:(sg & masc & third & pres) & left:left:is(front) ).","% overt prefix","ji(More) := self:'+ini' &","obl(is(i),obl(is(i), More)) &","cat:(fut & third & ((sg&masc) (bl ; b2)). )). ; pl) & The segmental content of all other affixes is specified via possibly repeated instances of obl, since affixes are nonalternating. Apart from the respective categotial information, positional type information ' +ini', ' +fin' ensures that prefixes and suffixes are properly restricted to wordinitial and wordfinal position. Note that the glide-initialji- prefix specifies an initial/i/(58) which will be prosodified as onset by means of"]},{"title":"syllabify. This representational as-sumption is in line with other recent work in phonological theory which standardly analyzes glides as nonsyllabic high vowels. Hence, even in MH we have a case where segmental classes and prosodic rolesdon't align perfectly. To control second stem vowel apophony, some suffixes demand (53,73) or forbid (51) front vowels two positions to their left.","paragraphs":["61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79","u(More) := obl(is(u)&self:'+fin',More)& left:left:is(- (vowel & -front)) & cat:(pl & ( (past & third)","; (fut & - first) )).","a(More):=obl(is(a)&self:'+fin',More)& left:left:is(- (vowel & -front)) & cat:((past & third & sg & fem)","; (pres & sg & fem & b5)).","et(More) := obl(is(e),obl(is(t)&self:'+fin',More))& left:left:is(front) & cat:(pres & sg & fem & -b5).","im(More) := obl(is(i),obl(is(m)&self:'+fin',More))& left:left:is(- (vowel & -front)) & cat:(pres & pl & masc). 16 Others posit the weaker demand vowel -+ front (62,67,78), thus not forbidding consonantal fillings of the position adressed by left : left.","The stem definition (80-82) for a regular triliteral is parametrized for the three root segments and the inflectional Suffixes to follow. 80 stem(el, C2, C3, Suffixes) := 81 obl(is(Cl),x O(vl,obl(is(C2), 82 x_0(v2,obl(is(C3), Suffixes))))). 83 84 affixes(Stem, '#'(end)) := '#'(Stem). 85 affixes(Stem, a(end)) := '#'(Stem). 86 affixes(Stem, et(end)) := '#'(Stem). 87 affixes(Stem, im(end)) := '#'(Stem). 88 affixes(Stem, u(end)) := yi(Stem). 89 90 verbform([Cl & consonant,C2 & consonant, 91 C3 & consonant], Category) := 92 root_letter_tree([Cl,C2,C3]) & word & 93 affixes( prosodic_prespecification & 94 stem(Cl,C2,C3, Suffixes), 95 Suffixes) & cat:Category. Given the informal description in section 2, the succession of obligatory root and altel\"nating stem vowel positions now looks familiar. It should be obvious how to devise analogous stem definitions for quadriliterals (e.g."]},{"title":"mixfev)","paragraphs":["and cluster verbs (e.g."]},{"title":"flirtet).","paragraphs":["A rather simple tabulation of affixes lists (a subset of) the allowable prefix-suffix cooccurrences in the MH verbal paradigm (84-88) be-fore everything is put together in the definition for verbform, parametrized for a list of root segments and Category (90-95). Note how prosodic_prespeci fication is intersected with stem in (93-94), exploiting the power of the description level to restrict stem realizations without diacritical marking of stem vs affix domains on the object level. The subgoal root_letter_tree (92) will be discussed below.","When proving a goal like verbform( [g, m, r],"]},{"title":"bl&third&pl&fut),","paragraphs":["the MicroCUF interpreter will enumerate the set of all candidate result feature structures, including one that describes the grammatical surface string"]},{"title":"jigmeru.","paragraphs":["An implementation of the IOP, to be described next, must therefore complement the setup established sofar to exclude the suboptimal candidates. While the subtle intertwining of zero alternant preference and constraint solving described above has its theoretical merits, a much simpler practical solution was devised. In a first step, the small finite set of all candidate solutions for a goal is collected, together with numerical 'disharmony' values representing each candidate's degree of optimality. Disharmony is defined as the binary number that results from application of the mapping {unmarked ~ 012, marked ~ 102} to the left-to-right markedness vector of a segmental string: e.g., jolioxgolal0moxroluol yields the disharmony value 010101100101012 = 552510 > 54771o = 010101011001012 from joli01golmoleloroluol. Step two is a straightforward search for the candidate(s) with minimal disharmony."]},{"title":"4 Parsing and generation","paragraphs":["The preceding paragraph described how to compute surface forms given roots and categories. How-ever, this generation procedure amounts to an inefficient"]},{"title":"generate-and-minimize","paragraphs":["mechanism which must compute otherwise useless suboptimal candidates as a byproduct of optimization. More importantly, due to the nonmonotonicity of optimization it is not obvious how to invert the procedure for"]},{"title":"efficient parsing","paragraphs":["in order to derive root and category given a surface form.","A first solution which comes to mind is to implement parsing as"]},{"title":"analysis-by-synthesis.","paragraphs":["A goal like ParseString&verbform (Root, Category) is submitted to a first run of the MicroCUF constraint solver, resulting in instantiations for Root and Category iff a proof consistent with the grammar was found. With these instantiations, a second run of MicroCUF uses the full"]},{"title":"generate-and-minimize","paragraphs":["mechanism to compute"]},{"title":"optimal","paragraphs":["strings OptStringl ..... OptStringN. The parse is accepted iff ParseString&(OptStringl; ... ;OptStringN) is consistent. Note that for this solution to be feasible it is essential that constraints are inviolable, hence their evaluation in the first run can disregard optimization. The main drawbacks of"]},{"title":"analysis-by-synthesis are","paragraphs":["that two runs are required and that the inefficiencies of"]},{"title":"generate-and-minimize","paragraphs":["are not avoided.","The new solution recognizes the fact that bidirectional processing of DPM would be easy without optimization. We therefore seek to perform all optimization at compile time. The idea is this: exploiting the finiteness of natural language paradigms we compute - using"]},{"title":"generate-and-minimize -","paragraphs":["each paradigm cell of e.g. the verbal paradigm of MH for a suitable root. However, while doing so we record the proof sequence of relational clause invocations employed in the derivation of each optimal form, using the fact that each clause has a unique index in internal representation. Such proof sequences have 17 two noteworthy properties. By definition they first of all record just clause applications, therefore naturally abstracting over all non-relational parameter fillings of top-level goals. In particular, proving a goal like verbform ( [g, m, r] , bl ; b2 ) normally looses the information associated with the root and category parameters in the proof sequence represen-tation (although these parameters"]},{"title":"could","paragraphs":["indirectly in-fluence the proof if relationally encoded choices in the grammar were dependent on it). Secondly, we can profitably view each proof sequence as a linear finite state automaton (FSAc~u). Since a paradigm is the union of all its cells, a complete abstract paradigm can therefore be represented by a unique Â• minimal deterministic FSAp=r~ which is computed as the union of all"]},{"title":"FSAcett","paragraphs":["followed by determiniza-tion and minimization. At runtime we just need to run FSAp~,.~ as"]},{"title":"afinite-state oracle","paragraphs":["in parallel with the MicroCUF constraint solver. This means that each proof step that uses a clause k must be sanctioned by a corresponding k-labelled FSA transition. With this technique we are now able to efficiently restrict the search space to just the optimal proofs; the need for run-time optimization in DPM processing has been removed. However, a slight caveat is necessary: to apply the technique it must be possible to partition the data set into a finite number of equivalence classes. This condition is e.g. automatically fulfilled for all phenomena which exhibit a paradigm structure.","What are the possible advantages of this hybrid FSA-guided constraint processing technique? First of all, it enables a particularly simple treatment of"]},{"title":"ttnkaowtl words","paragraphs":["for root-and-pattern morphologies, surely a necessity in the face of ever-incomplete lexicons. If the grammar is set up properly to abstract from segmental detail of the Root segments as much as possible, then these details are also absent in the proof sequences. Hence a single"]},{"title":"FSApara","paragraphs":["merging these sequences in effect represents an abstract paradigm which can be used for a large number of concrete instantiations. We thus have a principled way of parsing words that contain roots not listed in the lexicon. However, we want the system not to overgenerate, mistakenly analyzing known roots as unknown. Rather, the system should return the semantics of known roots and also respect their verbal class affiliations as well as other idiosyncratic properties. This is the purpose of the root_letter_tree clauses in (96-123).","96","97 98","99 i00 I01 102 103 104 105 106 107 108 109 ii0 iii 112 113 114 115 116 117 118 119 120 121 122 123 root_letter_tree([glRest]) := root_letter_tree_g(Rest). root_letter_tree([-gl_]) := cat:sem:'UNKNOWN'. root_letter_tree g([m[Rest]) := root_letter_tree_gm(Rest). root_letter_tree g([d[Rest]) := root_letter_tree_gd(Rest). root_letter_tree g([-m&~dI_]) := cat:sem:'UNKNOWN'.","root_letter_tree gm([r]) :=","cat: (bl & sem:'FINISH' ; b2 & sem:'BE FINISHED').","root_letter_tree gm([-rl_]) :=","cat :sem: 'UNKNOWN' .","root_letter_tree_gd( [r] ) :=","cat: ( bl & sem:'ENCLOSE' ; b2 & sem: 'BE ENCLOSED' ; b3 & sem: 'FENCE IN' ; b4 & sem: 'BE FENCED IN' ; b5 & sem:'DEFINE' ; b6 & sem: 'BE DEFINED' ; b7 & sem: 'EXCEL' ).","root_letter_tree_gd( [-rl_] ) :=","cat :sem: 'UNKNOWN' . For each level in the letter tree a new terminal branch is added that covers the complement of all at-tested root segments at that level (99,106,112,123). This terminal branch is assigned an 'UNKNOWN' semantics, whereas known terminal branches record a proper semantics and categorial restrictions. During off-line creation of the proof sequences we now simply let the system backtrack over all choices in the root_letter_tree by feeding it a totally underspecified Root parameter. The resulting FSApar= represents both the derivations of all known roots and of all possible unknown root types covered by the grammar. While this treatment results in a homogenous grammar integrating lexical and grammatical aspects, it considerably enlarges"]},{"title":"FSApara.","paragraphs":["It might therefore be worthwhile to separate lexical access from the grammar, running a separate proof of root_letter_tree (Root) to enforce root-specific restrictions"]},{"title":"after","paragraphs":["parsing with the abstract paradigm alone. It remains to be seen which approach is more promising w.r.t, overall space and time efficiency.","A second advantage of separating FSA guidance from constraint processing, as compared to pure finite-state transducer approaches, is that we are free to build sufficient expressivity into the constraint language. For example it seems that one needs token identity, i.e. structure sharing, in phonology to cover 18 instances of antigemination, assimilation, dissimila-tion and reduplication in an insightful way. It is well-known that token identity is not finite-state representable and cumbersome to emulate in practice (cf. Antworth 1990, 157 on a FST attempt at reduplication vs the DPM treatment of infixal reduplication in Tigrinya verbs described in Walther 1997, 238-247). Also, it would be fascinating to extend the constraint-based approach to phonetics. However, a pilot study reported in Walther & Krrger (1994) has found it necessary to use arithmetic constraints to do so, again transcending finite-state power. Finally, to the extent that sign-based approaches to grammar like HPSG are on the right track, the smooth integra-tion of phonology and morphology arguably is better achieved within a uniform formal basis such as MicroCUF which is expressive enough to cover the recursive aspects of syntax and semantics as well.","In conclusion, some notes on the pilot implementation. The MicroCUF system was modified to produce two new incarnations of the MicroCUF interpreter, one to record proof sequences, the other to perform FSA-guided proofs. FSApara was created with the help of finite-state tools from AT&T's freely availablefsm package (http: //www. research. art. com /sw /tools /fsm/).Ihavemeasured speedups of more than 102 for the generation of MH forms (< l second with the new technique), although parse times in the range of 1... 4 seconds on a Pentium 200 MHz PC with 64 M_Byte indicate that the current prototype is still too slow by a factor of more than l02. However, there is ample room for future improvements. Besides drawing from the wealth of optimizations found in the logic programming literature to generally accelerate MicroCUF (e.g., term encoding of feature structures, memoization) we can also analyze the internal structure of FSAvara to gain some specific advantages. This is due to the fact that each maximal linear sub-FSA of length k > i corresponds to a deterministic proof subsequence whose clauses should be partially executable at compile time, subsequently saving k - 1 proof steps at run-time. 5 Conclusion This paper has described a computational, declarative approach to prosodic morphology which uses inviolable constraints formulated in a sufficiently expressive formalism (here: MicroCUF) together with a restrictive incremental optimization component. The approach has been illustrated by implementing an a-templatic analysis of a fragment of Modern Hebrew verbs. The full grammar behind the illustrative fragment covers additional detail such as antigemination effects (noded-im, *nod d-im 'they (masc.) wander'), spirantization, B7 sibilant metathesis, etc. Also, the formalization of X/~ presented here is actually a special case of the more powerful notion of resequencing, whose application to Tigrinya vowel coalescence and metathesis was demonstrated in Walther (1997).","Despite the initial emphasis on incremental optimization, a compilation technique was later proposed to remove the need for run-time optimization and guarantee fully bidirectional processing of prosodic morphology. Although the general idea of using a finite-state oracle to guide a parser has been previously proposed for context-free grammars (Johnson 1996), both the details of our implementation of the idea and its specific application to prosodic morphology are believed to be novel. It was emphasized how the proposed technique aided in a simple treatment of unknown words. Note that unknown words are not normally integrated into finite-state transducer models of prosodic morphology, although the necessary extensions appear to be possible (K. Beesley, p.c.). Finally, the fact that a hybrid setup rather than a pure finite-state approach was chosen has been motivated inter alia by reference to additional phenomena such as antigemina-tion and reduplication that require the richer notion of token identity. Future research will especially focus on detailed analyses of reduplication phenomena to secure the relevance of the present approach to prosodic morphology at large.","References","Antworth, E. (1990). PC-KIMMO: A Two-Level Processor for Morphological Analysis. Dallas: SIL.","Bat-El, O. (1989). Phonology and Word Structure in Modern Hebrew. Ph.D. thesis, UCLA.","Beesley, K. R. (1996). Arabic Finite-State Morphological Analysis and Generation. In: Proceedings of COLING-96, vol. I, 89-94.","Bird, S. (1995). ComputationalPhonology. Cambridge University Press.","Bird, S. & E. Klein (1990). Phonological events. Journal of Linguistics 26, 33-56.","Chomsky, N. (1965). Aspects of the Theory of Syntax. Cambridge, MA: MIT Press.","Drrre, J. & M. Dorna (1993). CUF - A Formalism for Linguistic Knowledge Representation. In: J. Drrre (Ed.), Computational Aspects of Constraint-Based Linguistic Description. IMS, Universit/it Stuttgart. 19 Deliverable R1.2.A, DYANA-2 - ESPRIT Basic Research Project 6852.","Ellison, T. M. (1994). Phonological Derivation in Optimality Theory. In: Proceedings of COLING '94, vol. II, 1007-1013. (ROA-75, CMP-LG 9504021).","Ellison, T. M. (1995). OT, Finite-State Representations and Procedurality. In: Proceedings of the Confer-ence on Formal Grammar, Barcelona.","Eilison, T. M. (to appear). The Universal Constraint Set: Convention, not Fact. In: J. Dekkers, E van der Leeuw & J. van de Weijer (Ed.), Conceptual Studies in Optimality Theory. Oxford University Press.","Gafos, A. (1995). On the Proper Characterization of 'Nonconcatenative' Languages. Ms., Department of Cognitive Science, The Johns Hopkins University, Baltimore. (ROA-106).","Glinert, L. (1989). The grammar of Modern Hebrew. Cambridge University Press.","Hudson, G. (1986). Arabic root and pattern morphology without tiers. Journal of Linguistics 22, 85-122.","Johnson, M. (1996). Left Corner Transforms and Finite State Approximations. Tech report ML'Iq'-026, Rank Xerox Research Centre, Grenoble.","Kahn, D. (1976). Syllable-Based Generalizations in English Phonology. Bloomington: Indiana University Linguistics Club. (= MIT Ph.D. dissertation).","Karttunen, L. (1998). The Proper Treatment of Optimality in Computational Phonology. In: Proceedings of FSMNLP'98. International Workshop on Finite-State Methods in Natural Language Processing, Bilkent University, Ankara, 1-12.","Kiraz, G. A. (1996). Computing Prosodic Morphology. In: Proceedings of COLING '96, vol. II, 664.-669.","Kisseberth, C. (1970). On the functional unity of phonological rules. Linguistic Inquio' 1, 291-306.","McCarthy, J. (1979). Formal Problems in Semitic Phonology and Morphology. Ph.D. thesis, MIT.","McCarthy, J. & A. Prince (1993). Prosodic Morphology I: Constraint Interaction and Satisfaction. Tech report RuCCS-TR-3, Rutgers University Center for Cognitive Science.","Prince, A. & P. Smolensky (1993). Optimality Theory. Constraint Interaction in Generative Grammar. Tech report RuCCS-TR-2, Rutgers University Center for Cognitive Science.","Riehemann, S. (1993). Word Formation in Lexical Type Hierarchies: A Case Study of bar-Adjectives in German. Master's thesis, Universit~it Tiibingen. (also: SfS-Report-02-93, Seminar f'tir Sprachwissenschaft, Universit~it Tiibingen).","Scobbie, J. M. (1991). Towards Declarative Phonology. In: S. Bird (Ed.), Declarative Perspectives on Phonology, vol. 7 of Edinburgh Working Papers in Cognitive Science, 1-26. Centre for Cognitive Sci-ence, University of Edinburgh. 20","Selkirk, E. (1982). The syllable. In: H. van der Hulst & N. Smith (Ed.), The structure of phonological representations, vol. II, 337-383. Dordrecht: Foris.","Sproat, R. (1992). Morphology and Computation. Cambridge, Mass.: MIT Press.","Walther, M. (1993). Declarative Syllabification with Applications to German. In: T. M. Ellison & J. M. Scobbie (Ed.), ComputationalPhonology, vol. 8 of Edinburgh Working Papers in Cognitive Science, 55-79. Centre for Cognitive Science, University of Edinburgh.","Walther, M. (1995). A Strictly Lexicalized Approach to Phonology. In: J. Kilbury & R. Wiese (Ed.), Proceedings of DGfS/CL'95, 108-113. Diisseldorf: Deutsche Gesellschaft f'tir Sprachwissenschaft, Sektion Computerlinguistik.","Walther, M. (1997). Deklarative prosodische Morphologie - constraintbasierte Analysen und Computermodelle zum Finnischen und Tigrinya. Ph.D. thesis, Philosophische Fakultfit der Heinrich-Heine-Universit~it Di.isseldorf.","Walther, M. & B. Kr6ger (1994). Phonologie-Phonetik-Kopplung in einem constraintbasierten gesturalen Modell. In: H. Trost (Ed.), Tagungsband KONVENS '94, Nummer 6 in Informatik Xpress, 387-396. Wien: Osterreichische Gesellschaft fiir Artificial Intelligence."]}]}
