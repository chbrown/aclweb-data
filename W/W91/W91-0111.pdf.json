{"sections":[{"title":"COMMON HEURISTICS FOR PARSING, GENERATION, AND WHATEVER... HASIDA. K6iti Ir/stitute for New Generation Computer Technology (ICOT) Mita Kokusai Bldg. 21F. 1-4-28 Mita, Minato-ku, Tokyo 108 JAPAN Tel: -4-81-3-3456-3069, E-mail: hasida@icot.or.jp ABSTRACT","paragraphs":["This paper discussers general hem'istics to control computation on symbolic constraints represented in terms of first-order logic programs. These heuristics are totally independen! of specific domains and tasks. Efficient computation for sentence parsing and generation naturally emerge fi'om these heuristics, capturing the essence of standar d parsing procedures and semantic head-driven generat:ion. Thus. the same representation of knowledge, inclfiding grammar and lexicon, can be exploited in a multi-directional manner in various aspects of language use.","r"]},{"title":"1 Introduction","paragraphs":["One lesson to learn from the repeated failure to design","large AI systems in general is that the information flow","in the cognitive systems is too complex and diverse to","stipulate in the design of these AI systems. To capture","this diversity of information flow. therefore. At systeins","must be designed at a more abstract level where direc-","tion of information flow is not explicit,. This is where constrai~t paradigm comes in. Since","constraints do not stipulate the direction of informa-","tion flow or processing Order, constraint-based systems","could be tailored to halve tractable complexity, unlike","procedural systems, which stipulate information flow","and thus quickly become too colnplex for human de-","signers to extend or maintain. Naturally, the key issue in the constraint-based ap-","proach is how to control information flow. A very gen-","eral control schema independent of any specific domain","or task is vitally Ile('essal'y for the success of this ap-","proach. The present paper introduces a system of constraint","in a [o,-m of logic progi'am, and a set of very general","heuristics to control symbolic operation on the con-","straints. The sS'mboli( I operations herr are r('gar(h'd","as Iransforming logic programs. \"lhcv are quite per-","missivr operations as a whole, allowing very diverse","information processing involving top-down, bottom-up","and other directions of informal ion flow. The heuristics","control this computation so that only relevant infor-","mation should be exploited and the resuhing represen-","tation should be compact. Parsing and generation of","sentences are shown to be efficiently done under these","heuristics, and a standard parsing algorithm and the","semantic head-driven generation [8] naturally emerge","thereof.","The rest of the paper is organized as follows. Section 2 describes the syntax of our system of constraint. Section 3 defines the symbolic computation on these constraints, and proposes a set of general heuristics to control computation. Section 4 and Section 5 show how sentence parsing and generation are executed efficiently by those heuristics. Finally, Section 6 concludes the paper. 8.1."]},{"title":"2 Constraint Network","paragraphs":["A program is a set of clauses. A clause is a set of literals. A literal is an atomic constraint with a sign in front, of it. The sign is a '+', '-', or nil. A literal with a sign '+' or nil is called a positive literal and one with a sign \"-' is a negative literal. An atomic constraint is an atomic formula such as p(X,Y,Z), a bindin 9 such as X=f(Y), a feature specification such as a(X,Y), or an equality such as X=Y. Names beginning with capital let-ters represent variables, and the other names predicates and functions. A feature specification may be regarded as an atomic formula with a special binary predicate called a feature. A feature is a partial function from the first argument to the second argument: that is, if a is a feature and both a(X,Y) and a(X,Z) hold, then Y=Z must also hold. The other atomic constraints may be understood in the standard fashion. The atomic constraints other than equalities are called proper atomic constraints.","A clause is written as a sequence of literals it contains followed by a semicolon. The order among literals is not significant. So (1) is a clause, which may also be written as (2)."]},{"title":"(I) -p(U,Y) +q(Z) -U=f(X) -X=Z; (2) +q(Z) -p(f(Z),Y);","paragraphs":["A clause containing a literal with null sign is a definition clause of the predicate of that literal. A predicate having definition clauses are called defined predicate, and its meaning is defned in terms of completion based on the definition clauses. For instance, if the definition clauses of predicate p are those in (3), the declarative meaning of p is given by (4)."]},{"title":"(3) p(X) -q(X,a); p(f(X)) -r(X);","paragraphs":["(4) VA{p(A) Â¢0 {3Y(q(A,Y) AY = a)V 3X(A = f(X) A r(X))}} A predicate which is not a defined predicate is called a free'"]},{"title":"predicate.","paragraphs":["There is a special 0-ary defined predicate true. Its definition clauses are called"]},{"title":"top clauses. A","paragraphs":["top clause corresponds to the query clause of Prolog. although the latter has false instead of true.","Programs are regarded as constraint networks. For instance, the following program is a network as in Figure 1. (i) true -member(a,X); (ii) member(A, [AIS] ) ; (iii) member(A, [B IS]) -member(A,S) ; Figure 1: Constraint Network In graphical representations like Figure 1, a ',\" often represents an argument, of an atomic constraint. There are two types of"]},{"title":"nodes:","paragraphs":["arguments, and proper atomic constraints, An argument is involved in at most one proper atomic constraint, but in any number of equalities. An argument bound to a constant is identified with that constant. That is, the first argument of a binding ,=a. for instance, is represented simply by a."]},{"title":"A link,","paragraphs":["represented as a curve, connects two nodes. For any two (possibly the same) nodes, there is at most one link connecting them. A link connecting two arguments is an equality between them. A link connecting two proper atomic constraints is called an"]},{"title":"inference link.","paragraphs":["No link connects an argument and an atomic constraint. Although often not explicitly shown, an inference link accompanies equalities between the corresponding arguments of the two proper atomic constraints. A"]},{"title":"clausal domain","paragraphs":["of clause ~ is the part of the constraint network consisting of the atomic constraints referred to as literals in Â• except equalities concerning constants. A clausal domain is depicted by a closed curve enclosing the included atomic constraints. The short thick arrows indicate the references to the atomic constraints as positive literals in clauses. A"]},{"title":"predicate domain","paragraphs":["of predicate 7r consists of all the proper atomic constraints with r (binding X=f (Y) is regarded as having binary free predicate =:f, for instance), inference links among them, and equalities accompanying these inference links.","The"]},{"title":"instantiation possibilities","paragraphs":["of the constraint network is defined by regarding nodes and links as sets. Those sets are disjoint of each other. An instance of an argument corresponds to an individual in the domain of interpretation, and an instance of an atomic constraint corresponds to an atomic proposition. Constants (bindings to constants) and 0-ary atomic formulas are singleton sets. A link ~ between nodes o and stands for a symmetric relation. That is, ,~ = R U R -1 for some relation R C o x'8. We call {z 6"]},{"title":"ol3y x6y}","paragraphs":["the"]},{"title":"o-domain","paragraphs":["of 6. Every link in a clausal domain or the predicate domain of a defined predicate is of the form R U R -1 for some bijection R. Let ~ be the transitive closure of the union of all the links,"]},{"title":"x~y","paragraphs":["means that x and y correspond to the same object in the domain of interpretation if x and y belong to arguments, and that they correspond to the same atomic proposition if they belong to proper atomic constraints. We say that node o"]},{"title":"subsumes","paragraphs":["node/9 when"]},{"title":"a/~","paragraphs":["D '8/,~; that is, for every y 6 j3 there exists x 6 o such that"]},{"title":"xAy.","paragraphs":["For each pair of a proper atomic constraint o and an argument '3 of o, there is a bijection p from o to ,8, such that"]},{"title":"xpy","paragraphs":["holds iff y 6 '3 is an argument of x 6 o. p is called a"]},{"title":"role assignment.","paragraphs":["Consider a part T' of the constraint network and","the minimum equivalence relation including the links","and the role assingments in \"P. A"]},{"title":"layer","paragraphs":["of T' is an equivalence class with respect to this relation. A"]},{"title":"splitting domain","paragraphs":["is a part S of the network in which every link is of the form R [3 R -1 where R is the union of (o n f) x (,8 n Â£) over all the layers f of S and o and ,8 are the two endnodes of that link. Thus, if a link in a splitting domain splits into two links sharing an endnode o and having disjoint s-domains, then the entire splitting domain splits into two separate splitting domains each containing one of these two links. The clausal domains and predicate domains are assumed to be splitting domains."]},{"title":"A joint","paragraphs":["is a part of a node which connects the node with a link or more. Figure 2 shows some joints. The figures below illustrate the instantiation possibilities of the networks shown above by depicting each node as an ellipse enclosing its instances, and each link as a bundle of curves representing the pairs belonging to the link. A joint J of node o is depicted as an arc convex towards o crossing the links involved in J. A joint involving just one link, as in (a) and (b), is called a"]},{"title":"unitary joint,","paragraphs":["and one containing several links, as in (c) and (d), is called"]},{"title":"a multiple joint.","paragraphs":["Distinct links involved in the same multiple joint on node o have disjoint a-domains. A joint is"]},{"title":"partial","paragraphs":["if it stretches out of the involved links, as in (b) and (d). and"]},{"title":"total","paragraphs":["otherwise, as in (a) and (c). The union of o-domains of the links involved in the same joint on node o is equal to o. A total unitary joint as in (a) is not explicitly shown as an arc. Partial joints on node o are"]},{"title":"complementary","paragraphs":["when the union of the a-domains of the links involved in them is o. Complementary joints are indicated by a dashed arc crossing these links. So the union of the s-domains of the three links is o in (e), When node o and ~3 are connected by link 6 and the joint of '8 involving 6 is total and unitary, o and 6 are said to"]},{"title":"dominate ~.","paragraphs":["The initial structures of predicate domains are shown in Figure 3. Such structures, as well as the other structures, will change as computation proceeds."]},{"title":"3 Computation","paragraphs":["Here we introduce a method of symbolic computation together with some general control heuristics for controlling computation. There are two types of symbolic operation:"]},{"title":"subsumption","paragraphs":["and"]},{"title":"deletion.","paragraphs":["Here we chiefly 82 O~ CE CE Ct Ct"]},{"title":"j )","paragraphs":["(a) (b) (c) (d) (e) Figure 2: Joints between Nodes and Links"]},{"title":"p(...) )(...) p(...) / p(...) )(...) p(...)","paragraphs":["Bound Predicate Free Predicate","Figure 3: Predicate Domains ! concern ourselves with subsumption."]},{"title":"3.1 Subsumpti0n","paragraphs":["'Subsumption\" means two things: subsumption relation. which we defined above, and subsumption operation. which we discuss below.","The purpose of a subsumption is to let information flow from a node. A node o may have probes, c~ is called the origin of these probeR. Each probe is placed on a link and directed tbwards an endnode. The origin of a probe subsumes the' node behind the probe. Probes transmit information of their origins across the network via subsumptions. The origin of probes has its scope. The scope of node o is the part S of the constraint network satisfying the following conditions. Â• $ is a connected graph containing a. Â• A node 13 is behind a probe r on link 6 and with","origin a, iff/3 is in 5\" but 6 is not. Â• (~ subsumes every node in $. So the scope of a may be illustrated as in Figure 4, where arrows are probes, which just cover the boundary Figure 4: Scope of Node of the scope.","Every node a can just once create probes on all the links connected to a so that a is behind these probes. Subsumption extends the scope of a node by advancing probes, while preserving the instantiation possibilities of the network described above. We consider a subsumption from node iota to node ~ along link 6. ~, ~, and 6 are called the input node, the target node, and the axis, respectively, of this subsumption. The joint J of","involving/f is called the target joint. This subsumption extends the scopes of the origins of the probes on 6 directed towards ~. It proceeds as follows.","First, the set II of the probes on 6 towards ~ is detached from 6, and 6 is shifted from J to another joint J', as illustrated in Figure 5. J! is a copy of J and is on a node ~' which is a copy of ~. J' and ~' may be created here and now, but may also have been made in a previous subsumption, as mentioned below. Below we proceed so as to make ~0 = ~1 O ~' A ~1 n ~' = @ 83 "]},{"title":"Oit.-J","paragraphs":["\"..~.Â°.. 8 ......... Z G2 02-Z"]},{"title":"(","paragraphs":["Figure 5: Shifting of Link and Augmentation of Foldability true, where ~0 and (1 stand for ~ before and after this subsumption, respectively.","A joint may be"]},{"title":"foldable","paragraphs":["to another joint by a set of origins of probes. Each joint, involved here, called a"]},{"title":"foldable joint,","paragraphs":["is one obtained by copying zero or more times a multiple joint in the initial state of computation. Typically, a foldable joint is one involving links in the predicate domain of a defined predicate. No joint. just created is foldable to any joint. For any joint G and set. O of nodes, there is at most one joint H such that (; is foldable to H by O.","Let E be the set of origins of the probes in II. If J is foldable, then for each joint G the foldability relation extends in the following way, as illustrated in Figure ,5, where the foldability relation is depicted by dashed arrows. Â• .l is foldable to J' by E. Â• If G is foldable to J by O, then G is foldable to","J' by O U E. Â• If ,1 is foldable to G by O such that O D Z, then","J' is foldable to G by O - E. If there has already been a joint to which d is fold-"]},{"title":";Lble","paragraphs":["by E. then J' is that joint, ~' is the node on"]},{"title":"J',","paragraphs":["J' becomes a total multiple joint, and tile foldability relation remains unchanged. Otherwise, J' and ~' are newly created, 6 dominates ~', and the foldability relation is augmented. We call the former case"]},{"title":"folding,","paragraphs":["and the latter"]},{"title":"unfolding.","paragraphs":["If c~ is a proper atomic constraint or an argument of a proper atomic constraint, then & stands for the set whose elements are this proper atomic constraint and its arguments; otherwise dr = {a}.","In the case of unfolding, each node v in ~ is copied to v', and each link a (a y~ ~) connecting v and r/is copied to a' connecting v' and some node r/'. 71' is the copy of r/ if r/ E ~ and r/' = r I otherwise. Relevant Joints are copied accordingly so a~s to preserve the instantiation possibilities of the network.","There are two cases,"]},{"title":"splittin 9","paragraphs":["and"]},{"title":"non-splitting,","paragraphs":["about how to create ~r'. In the former, it is guaranteed that no layer of the splitting domain including a before the copy overlaps with both v and v' after the copy. Such a guarantee is obtained iff c~ = R U R -1 for some bijection R or (inclusive) 6 and a belong to the same splitting domain. There is no such guarantee in the non-splitting case.","In the splitting case. as is illustrated in Figure 6, the r/-domains of a and a' are disjoint when r/' = r/. v 13"]},{"title":"~O! ~-~OI e V V t n","paragraphs":["Figure 6: Copy of Links (Splitting)","In the non-splitting case, as is illustrated in Figure 7, if a was a loop, v and v' is connected by an addi-V"]},{"title":"o/","paragraphs":["T"]},{"title":"v) (v' n","paragraphs":["Figure 7: Copy of Links (Non-Splitting) tional link representing a relation pertaining to the layers overlapping both v and v'. Further if a was involved in a multiple joint of 7/, then a subsumption along o\" to 7/must be done before creating o\"; otherwise the right instantiation possibilities cannot be represented.","In both splitting and non-splitting cases, the probes that v had, if any, are deleted, and v and v' are licensed to generate new probes. Then every remaining probe on a is copied to a probe on a', towards v', and the same origin. Further, each probe in II is advanced through ~' onto every link r (# ~5) connected with ~' so that ~' should be behind the probe. If there is another probe on r towards ~' and with the same origin, then both probes are deleted.","Finally, in both folding and unfolding, if ~5 dominated","before this subsumption, ~ is deleted because it has become the empty set now. This deletion propagates across links and nodes until possibly non-empty sets 84 are encountered: that is. until you come across partial or multiple joints of remaining nodes. 1 Now the subsumption is done.","To properly split splitting domains, we must augment this subsumption procedure so that. a probe may carry, instead of origin., some information about which layers of the relevant splitting domain are involved in the node behind the probe. Such probes are transmitted from proper atomic constraints to their arguments and vice versa. A link is deleted if it contains two probes with opposite directions and associated with disjoint sets of layers. Further details are omitted due to the space limitation.","So far we have dischssed subsumption in general. Below we describe thee particularities of subsumptions along equalities and subsumptions along inference links.","A subsumption along an equality is triggered by a dependency between arguments. We say that there is a dependency between two arguments, when they compete with each other and are connected by a dependency path. Nodes o and '3 Compete with each other when the5\" are the first arguments of Â• two bindings (as in (=f(,) and q=g(,)). Â• a binding and a feature specification, or Â• two feature specifications with the same feature. A dependency path connecting o and 3 is a sequence 61~2 '\"/5, of strong equhlities such that the endpoints of ~i are a,-a and c~i (1 <_ i <_ n), 6i and ~i+x are involved in different joihts of c~; one of which is total (1 _< i < n). a0 = a and o,, = '3. An equality is strong when it belongs to a claiuse or the predicate domain of a defined predicate, or g'hen a subsumption has taken place along that equality.","A probe r on an equality ~ might trigger a subsumption to advance rr, when: there is a dependency between the origin c~ of rr and another node/3 and 3 is included in a dependency path connecting ~ and /3.","Suppose the scope of o includes another node L3 competing with a. If the proper atomic constraints A and B, each involving ~ and '3 as the first argument, respectively, are connected by an inference link 6. then/5 absorbs B, as shown in, Figure 8. That is, the joint"]},{"title":"o~=f(.) ~=f(-) 13=f(,) 13=f(.)","paragraphs":["Figure 8: Absorption by Link of B involving /~ is modified so that, /3 dominates /3, because A has turned out to subsume B. Any other inference link involved in this joint is deleted, because","IThis combination of copy and deletion is vacuous and thus may be omitted in actual implementation for the unfolding cases. The deletion of probes in the splitting case may also be avoided in such a situation. it has turned out to be the empty set. Of course each equality accompanying 6 must absorb its endnode in B at the same time. If there is no inference link between A and B, then B is deleted. Deletions of links and nodes propagate so long as the empty set is encountered, as said before.","A subsumption along an inference link may be triggered by cost assigned to the input node. Each literal in a clause may be assigned a cost. Similarly to the as-sumability cost of Hobbs et al. [5], the cost of a literal corresponds to the difficulty to abductively assume its negation. For instance, if you want to assume atomic constraint ~ by using a clause backwards whereas the cost of the literal -~ in this clause is not zero, then you are to do something in order to cancel the cost. In this sense, an atomic constraint with a cost is regarded as a goal to achieve, and the abductive usage of the clause which gives rise to the goal is regarded as the motiva-tion to set up that goal. A cost may be canceled by making the atomic constraint subsume another which is more readily believable. That is, a goal is fulfilled when it is established by some reason other than its motivation.","The input node of a subsumption along an inference link is th e goal atomic constraint in the rest of the paper. 2 Such a subsumption eliminates the cost if the target node has been derived from the top clause without recourse to that very subsumption. Otherwise the cost is inherited into the clause which contains the output node. In a Horn clause normally used with all the atomic constraints therein being true, the head literal inherits the cost from a body atomic constraint, and the body atomic constraints inherit the cost from the head literal. We neglect the cost inheritance among body atomic constraints."]},{"title":"3.2 Heuristics","paragraphs":["Subsumptions along equalities and those along inference links both encompass top-down and bottom-up information flow. Some heuristics are necessary to control such an otherwise promiscuous system of computation so that more relevant pieces of information should be exploited with greater preferences.","Each heuristic for a subsumption along an equality is that one of the following conditions raises the preference of such a subsumption.","(H1) The origin of a probe on the axis is close to (typically included in) the top clause or is a constant.","(tI2) A dependency path involving the axis and connecting an argument with the origin of a probe on the axis is short. Both these conditions are regarded as indicating that the transmitted information (about the origin) is highly relevant to the destination of this transmission. In this connection, a subsumption along an equality is unlikely to happen if the axis belongs to the predicate domain of a free predicate and the target joint is partial, since the conveyed information would not be very relevant to the target node.","~Subsumptions for checking consistency need not be triggered by cost. 85","As for subsumptions along inference links, the following conditions each raise the preference.","(H3) Corresponding arguments of the input node and the target node are connected via short dependency paths with the same node. (That is, those arguments are 'shared.')","(H4) The target node has already been derived from the top clause. (H3) raises the possibility for instances of the two arguments to coincide in the domain of interpretation. (H3) amounts to a generalization (or relaxation) of the condition on which an inference link absorbs one of its endnodes. (I-14) guarantees that the subsumption in question will lead to an immediate elimination of the cost. of the input node. Probably (H4) could be relaxed to be a graded condition."]},{"title":"4 Parsing","paragraphs":["Let us consider a simple case of context-free parsing based on the following grammar."]},{"title":"P~a p---~ pp","paragraphs":["A parsing based on this grammar is formulated by the program as follows. (5) true"]},{"title":"-p(Ao,B) -Ao=[alA1] -Ai=[aIA2]","paragraphs":[".-'; (Â¢) p([alX] ,X) ; (q/) p(X,Z) -p(X,Y) -p(Y,Z); I)epicted in Figure 9 are the four types of clauses cre- (a) (b) (c) (d) Figure 9: Clauses Produced through Parsing ated by this parsing process. A *= [a"]},{"title":"I","paragraphs":["*] is a shorthand representation for a .=[*l*] plus an equality between the second argument and (the argument bound by) a. (a) is a copy of clause Â¢ in (5), and the other clauses are copies of ~. A label i of a link means that the relevant part of the network is in the scope of argument Ai. The reason why only these types of clauses are generated is that in this case every dependency arises between a *= [a I *] in the top clause and another .= [a I*] some-where else and the first argument of the former is the origin of the subsumptions to resolve that dependency. A strict proof will be obtained by mathematical induc-tion. Since the number of these clauses is O(n 3) due to (d) and each of them may be generated in a constant time, the time complexity of the entire parsing is"]},{"title":"0(773).","paragraphs":["where n is the sentence length. Each clause is guaranteed to be generated in a constant time, because each foldability test can be performed in a constant time, as discussed later. By employing a general optimization technique, we can eliminate the clauses of type (d), so that the space complexity is reduced to"]},{"title":"O(n2).","paragraphs":["Thus, our general control scheme naturally gives rise to standard parsing procedures such as Eaxley's algorithm and chart parsing.","(5) is graphically represented as Figure 10. We"]},{"title":",,,...--\"' -P-true ~.","paragraphs":["Figure 10: Parsing (1) omit the links involved in the predicate domain of a free predicate, until they are modified as in Figure 8. Thus no links among ,=[ale]s axe shown in Figure 10. Here is a dependency between the first .=[alo] in the top clause and the o=[alo] in ~, as indicated by the dependency paths, which consist of thick links. To let information flow from the top clause following the above heuristic (H1), we are to do the two subsumptions indicated by the two thin arrows.","Those subsumptions copy # to ~1 and Â• to ~l, resuiting in Figure 11. For expository convenience, we -h-true Figure lh Parsing (2) 86 assume here without loss of generality that copying of a clause produces a separate clause rather than one sharing atomic constraints with the original clause. Note that the first argument of the *=[al*] in Â¢1 is subsumed by h0.","Computation goes on into the same direction, and the two subsumptions are to happen as shown in Figure 11. Folding takes place this time, and the result is to shift the two inference links upwards, as in Figure 12. Now the first *=[al*] in the top clause dominates"]},{"title":"/......f'-\"~ ..m.-true","paragraphs":["0 1"]},{"title":"Â¢ : L2M rLY '","paragraphs":["Figure 42: Parsing (3) the *=[al*] in ~1 as indicated by the inference link between them. becaus e, as indicated by number 0 in ~l, the first argument of the former is within the scope of the first argument of the latter. Now the equality in the right-hand side of ~1 is within the scope of A1, as indicated in the figure. This subsumption also engenders a new set of dependencies between the first argument of the second .= [a I*] in the top clause and that of .= [a ] o3 in ~, as indicated again by thick links in Figure 12. By executing the indicated subsumption following (H1), 31 is copied to q\"2. so that we obtain Figure 13. Further advancing subsumptions as shown there, we get Figure 14. Computation goes on in the similar way.","As mentioned above, we are able to assume that each foldability test is perfo~:med in a constant time. This assumption is justified by, for instance, sorting the foldability information from each joint in the chronical order of the first subsumption which advanced probes with the relevant origin. In the present parsing exampie. this order happens to be the increasing order of the suffix i of Ai.","It. is straightforward to integrate such a phrase-structure parsing with computation on internal structures of grammatical ca~tegories represented in terms of feature bundles, for instance. See [2, 3] for further details in this regard. Note that the above derivation of the parsing process is more general than the parsing-as-deduction approaches [6, 7], because it is free from stipulation of the left-to-right and to-down processing direction and also from task-dependency with regard to parsing or context-free grammar. 87 i"]},{"title":"/......i--\"~-- -D-true Figure 13: Parsing (4) Figure 14: Parsing (5) 5 Generation","paragraphs":["Here we consider how to verbalize the following semantic content in English. S~laughed,kim~ This means that Kim laughed, based on Situation Theory [1]. That is, in some situation S there is an event which is of the sort laughed and whose agent is kira. So a sentence we might want to generate is 'Kim laughed.\" S may be interpreted as, for instance, the speaker's model of the hearer's model of the world. A state of affairs ((laughed, kira)) will be regarded as variable L1 constrained by two feature specifications"]},{"title":"rel (Ll,laughed) and agt (Li ,kim).","paragraphs":["The initial state of computation could be formulated in terms of a program including the following clauses. among much more others. (A)"]},{"title":"true -s(SEM,WO,WI) -S~SEM -say(WO)","paragraphs":["-SELl $,"]},{"title":"-rel(Ll,laughed) $ -agt(Ll,kim) $ ...; (B) s(SEM,X,Z) -np(SBJSEM,X,Y) vp(SEM,SBJSEM,Y,Z) ; (C) np(kim,X,Y) -X=['kim 'IY]$; (D) vp(L,AGT,X,Y) -X=['laughed'IY] $ -rel (L, laughed) -agt (L, AGT) ;","paragraphs":["say(W0) means that the utterance beginning at W0 should be actually uttered. S~SEM and SELl seper-at, ely exist, in (A), because the next utterance need not directly refer to L1. For instance, one can mean that Kim laughed by saving \"Do you know that. Kim laughed?' instead of just 'Kim laughed,' or by doing something other than utterance. One might even just give up the goal and say something quite different.","A '$\" attached to an atomic constraint represents a cost, so that the atomic constraint is a goal. The three goals in (A) altogether amount to a macroscopic goal to make a state of affairs ((laughed, kim)) hold in situation S.","What we would like to demonstrate below is again that the control heuristics described in Section 3 tend to trigger the right operations depending upon the computational context, provided that the current goal is to be reached by some linguistic means; that is, by eventually uttering some sentence. Below we pay attention to only one maximal consistent structure of the sentence at a time just for the sake of simplicity, but the actual generation process may involve OR-parallel computation similar to that in parsing of the previous section.","Figure 15 graphically represents clauses (A) and (C). A proper atomic constraint with a binary predicate, possibly together with equalities involving the two arguments, is represented here as an arrow from (an argument equalized with.) the first argument to (an argument equalized with) the second argument. Links in predicate domains are selectively displayed for expository simplicity.","The most. probable operations to take place here are subsumptions involving one of these three goals. There should be innumerable combinations for such"]},{"title":"~Â¥. ~/ .......","paragraphs":["subsumli~n ..."]},{"title":"\"laughed'","paragraphs":["Figure 15: Generation (1) subsumptions, because the speaker's lexicon must in-clude a large number of atomic constraints of the form Â• ~Â•, rel(.,.) and agt(Â•,Â•), even though subsumptions with extralinguistic parts of the constraints are excluded due to the above provision that the current goal is to be fulfilled by linguistic means.","However, two of such subsumptions are preferred to the others. One is the subsumption concerning the two Â•~Â•s in (A), and the other is from the rel(#,Â•) in (A) to that in (D). In both cases, the two atomic constraints share the same argument for the same argument place, which raises the preference due to (H3). Let us tentatively choose just the latter subsumption in this particular presentation. No big difference would follow in the long run, even if the former subsumption or both were chosen instead.","By the subsumption concerning the two rel(.,e)s, we obtain the structure shown in Figure 16. We have i rpdÂ°n subsumption- ...... ~"]},{"title":"\"laughed'","paragraphs":["Figure 16: Generation (2) 88 i copied clause (D) to (D!). because the rel(, ,,) in (A) is a goal. Now in Figure 16. vp(,,,,,,,) in (D') is a goal. by inheriting the cost from rel(,,,) of (A). The cost of ,=[,[,] in (D') is inherent, as indicated in (D). Now the most probable next computation is the sequence of subsumptlons along the thick hnk(s) constituting a dependency path. Following the heuristic (Hi). those subsumptions propagate from the top clause. After that. the inference link between the two agt(,,,)s absorbs the 6tie in (B).","This gives us Figure '17. (D') has not. been dupli-"]},{"title":"i","paragraphs":["kim"]},{"title":"laughed)","paragraphs":["n ') \"laughed' Figure 17; Generation (3) cated here. because thd above subsumptions did not actually duplicate any clause. In this context, the subsumption concerning the two vp (.,.,., .) s is possible, since the one in (D') is a goal. Due to (H3), this subsumption is more prefera~ble than the others concerning two vp(.,.,., e)s, because their first arguments are both connected to kim (that is, the first argument of Â• =kim) via. short dependency paths. As a result, (B) is copied to (B') and the vp(.,.,.,.) in (B') is dominated by that. in (D'), aS in Figure 18.","Now that s(.,.,.) in (B') is anew goal, it is caused to subsume another s(*,*,*) in (A). According to (H4), this subsumption:, is particularly preferable because (A) is the top clause. On tile other hand. the subsumption from the first argument of np(.,.,.) in (B') to the first argument of np(.,.,.) in (C) could take place here, to resolve the cyclic dependency about. kim referred to from (N) and (C). This subsumption","is the most probable operation concerning this depen-","dency in this context, because it is along the shortest","relevant dependency patch. We assume that the direc-","tion of this subsumption~ is downwards, as indicated in Figure 18. It will be the'same in the long rnn if it were","in the opposite direction'. The mentioned computation in Figure 18 takes us","to Figure 19. We have a new top clause (A'), which","shares most part of itself with (A). except, the copy","of s(*,*,*). Some of the previous goals have disap-","peared due to the subsumption concerning s(.,.,.)s.","Now the remaining goals are .=[. I*]s in (C') and (D') suhgumntinn"]},{"title":"Figure 18: Generation (4)","paragraphs":["execution subsumption"]},{"title":"Figure 19: Generation (5)","paragraphs":["89 and the .~. in the intersection of (A) and (C'). We might do a subsumption concerning the two .~.s, because they share both the arguments. This subsumption could have happened earlier, of course, particularly ever since both arguments came to be shared in Figure 16 via (B) and (D'). As mentioned before, how-ever, it would have caused no essential difference even-tually. At the same time we could execute the procedure say(*) to realize the goal *=[*1.] in (C'). It is reasonable to assume that this computation is triggered by the fact that the argument of say(.) subsumes the first argument of this .=[.I,]. This heuristic for fir-ing procedures looks generally applicable not only to utterance but also to every other output procedure.","Thus we move to a new computational context in Figure 20. The execution of say(.) has created a new execution .......... . Figure 20: Generation (6) Â• =[. I.]. so that 'Kim' has been spoken aloud. This Â• -- [* I o] dominates the ,--- [. I o] in (C'), as indicated by the thick link. Generation of 'Kim laughed' completes if say(,) is executed one step further.","Note that this generation process captures the bottom-up feature of semantic head-driven generation [8], especially when we move from Figure 15 through Figure 18. The subsumption concerning the arguments of np (., o, o)s happening between Figure 18 and Figure 19 captures the top-down aspect as well."]},{"title":"6 Concluding Remarks","paragraphs":["We have introduced a set of general heuristics for controlling symbolic computation on logic constraints, and demonstrated that sentence parsing and generation are attributed to these heuristics. In the above presenta-tion, parsing is for the most part based on truth maintenance (resolution of dependencies among arguments) 90 controlled by heuristics (H1) and (H2), whereas generation is more dependent on goal satisfaction controlled by (H3) and (H4). In more realistic cases, however. both processes would involve both kinds of computation in a more intertwined way.","A related nice feature of our framework is that, in principle, all the types of constraints -- syntactic, semantic, pragmatic and extralinguistic -- are treated uniformly and integrated naturally, though a really efficient implementation of such an integrated system requires further research. In this connection, we have undertaken to study how to implement the above heuristics in a more principled and flexible way, based on a notion of"]},{"title":"potential energy","paragraphs":["[4], but the present paper lacks the space for discussing the details.","In this paper we have discussed only task-independent aspects of control heuristics. Our conjecture is that we will be able to dispense with domain-dependent and task-dependent control heuristics altogether. The domain/task-dependent characteristics of information processing will be captured in terms of the assignment of energy functions to the relevant constraints. The resulting system will still be free from stipulation of the directions of information flow, allowing multi-directional information processing, since neither the symbolic component nor the analog component (that is, energy) of the constraint refers explicitly to information flow."]},{"title":"References","paragraphs":["[1] Barwise, J. (1990)"]},{"title":"The Situation in Logic,","paragraphs":["CSLI Lecture Notes No. 17.","[2] Hasida, K. (1990) 'Sentence Processing as Constraint Transformation,'"]},{"title":"Proceedings of ECAI '#0.","paragraphs":["[3] Hasida, K. and Tsuda, H. (1991) 'Parsing without Parser,'"]},{"title":"International Workshop on Parsing Technologies,","paragraphs":["pp. 1-10, Cancun. [4] Hasida, K. (in preparation)"]},{"title":"Potential Energy of Combinatorial Constraints.","paragraphs":["[5] Hobbs, J., Stickel, M., Martin, P., and Edwards, D. (1988) 'Interpretation as Abduction,'"]},{"title":"Proceedings of the ~O6th Annual Meeting of ACL,","paragraphs":["pp.95-103.","[6] Pereira, F.C.N. and Warren, D.H.D. (1983) 'Parsing as Deduction,'"]},{"title":"Proceedings of the 21st Annual Meeting of ACL,","paragraphs":["pp. 137-144.","[7] Shieber, S.M. (1988)'A Uniform Architecture for","Parsing and Generation,'"]},{"title":"Proceedings of the 12th COLING,","paragraphs":["pp. 614-619.","[8] Shieber, S.M., van Noord, G., and Moore, R.C. (1989) 'A Semantic-Head-Driven Generation Algorithm for Unification-Based Formalisms,'"]},{"title":"Proceedings of the 27th Annual Meeting of A CL,","paragraphs":["pp. 7-17."]}]}
