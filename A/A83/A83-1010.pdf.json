{"sections":[{"title":"","paragraphs":["PARSING WITH LOGICAL VARIABLES","Timothy W. Finln and Martha Stone Palmer","Department of Computer and Information Science","University of Pennsylvania","Philadelphia, PA 19104 ABSTRACT","Logic based programming systems have enjoyed an increasing popularity in applied AI work in the last few years. One of the contributions to Computational Linguistics made by the Logic Programming Paradigm has been the Definite Clause Grammar. In comparing DCG's wlth previous parsing mechanisms such as ATN's, certain clear advantages are seen. We feel that the most important of these advantages are due to the use of Logical Variables with Unification as the fundamental operation on them. To illustrate the power of the Logical Variable, we have implemented an experimental ATN system which treats ATN registers as Logical Variables and provides a unification operation over them. We would llke to simultaneously encourage the use of the powerful mechanisms available in DCG's, and demonstrate that some of these techniques can be captured without reference to a resolution theorem prover. [. Introduction","Logic based programming systems have enjoyed an increasing popularity in applied AI work in the last few years. One of the contributions to Computational Linguistics made by the Logic Programming Paradigm has been the Deflnite Clause Grammar. An excellent introduction to this formalism can be found in [Perelra] in which the authors present the formalism and make a detailed comparison to Augmented Transition Networks as a means of both specifying a language and parsing sentences in a language.","We feel Chat the major strengths offered by the DCG formalism arise from its use of Logical variables with Unification as the fundamental operation on them. These techniques can be abstracted from the theorem proving paradigm and adapted to other parsing systems (see [Kay] and [Bossie] ). We have implemented an experimental ATN system which treats ATN registers as Logic variables and provides a unification operation over them.","The DCG formalism provides a powerful mechanism for parsing based on a context free grammar. The grammar rule S -> NP VP can be seen as the universally quantified logical statement,","For all x, y, and z : N'P(x) /\\ VP(y) /\\ Concatenate(x,y,z) -> S(z). where \"x\" and \"y\" represent sequences of words which can be concatenated together to produce a sentence, \"S.\" Prolog, a progra~mulng language baaed on predicate calculus, allows logical statements to be input as Horn clauses in the foilowlng (reversed) form: s(Z) <- np(X),vp(Y),Concatenate(X,Y,Z).","The resolution theorem prover that \"interprets\" the Prolog clauses would take the oegatlon of S as the goal and try and produce the null clause. Thus the preceding clause can be interpreted procedurally as, \"To establish goal S, try and establish subgoals, NP, VP and Concatenate.\" DCG's provide syntactic sugar on top of Prolog so that the arrow can be reversed and the \"Concatenate\" predicate can be dispensed with. The words in the input string are looked at sequentially each time a \"[Word]\" predicate is executed which implicitly tests for concatenation (see figure [). DCG's allow grammar rules to be expressed very cleanly, while still allowing ATN-type augmentation through the addition of arbitrary tests on the contents of the variables.","Pereira and Warren argue that the DCG formalism is well suited for specifying a formal description of a language and also for use with a parser. In particular, they assert that it is a significant advance over an ATN approach on both philosophical and practical grounds. Their chief claims are that:","[. DCGs provide a common formalism for theoretlcal work in Computational Linguistics and for writing efficient natural language processors. 62","2. The rule based nature of a DCG result %n systems of greater clarity and modularity.","3. DCG's provide greater freedom in the range of structures that can be built in the course of analyzing a constituent. [n particular the DCG formalism makes it easy to create structures that do not follow the structure implied by the rules of a conscltuenc and easy Co create a structure for a constituent thac depends on items not yec encountered in the sentence. Fig. 1. A DeflniCe Clauee Grammar s(P) -> rip(X, Pl, P), vp(X, Pt).","The flrsC two points have been discussed in the past whenever the ATN formalism is compared with a rule-based grammar (see [PracC] , [Heldorn] , [Codd] , or [Bates] ). The outcome of such discussions vary. It is safe Co say chat how one feels about these points depends quite heavily on past experience in using the two formalisms.","We find the third point co be well founded, however. Ic is clear chac the DCG differs moeC from previous rule-baaed parsing systems in ice inclusion of Logical variables. These result in greater flexibility in building structures co represent constituents that do mot follow the Inherent structure determined by the rules themselves. They also allow one co create structures which refer Co Items chac have not yec been discovered in the course of analysing the sentence.","We have built an experimental ATN system which can crest ATN registers as Logical variables and, we feel, capture these important strengths offered by the DCG formalism in the ocherwlse standard ATN formalism.","The second section gives a more detailed desctpCton of DCG's and presents a simple grammar. In the third section we show am ATN grammar which is \"equivalent\" to the DCC grammar and discuss the source of Its awkwardness. The fourth section chert presence an ATN formalism extended co include viewing ATN registers as Logical variables which are subject to the standard unlficacloa operaclon. The final section concludes this note and suggests that logical variables might be fruitfully introduced into ocher parsing algorithms and systems.","rip(X, Pl, P) -> dec(X, P2, PI, P), n(X, P3), relclauee(X, P3, P2). rip(X, P, P) -> name(X). vp(X, P) -> tranev(X, Y, Pl), np(Y, Pl, P). vp(X, P) -> tncransv(X, P). relclause(X, PI, (And PI P2)) -> [chat], vp(X, P2). relclauae(X, P, P) -> [], dec(X, Pl, P2, (ForAll X (-> P! P2))) -> [everyl. dec(X, Pl, P2, (ForSome X (And Pt P2))) -> [a]. n(X, (man X)) -> [,u.]. n(X, (woun X)) -> [wom~.]. n(X, (dog X)) -> [dog]. name(John) -> [John] name(mary) -> [mary] namI(fldo) -> [fido] transv(X, Y, (loves X Y)) -> [loves]. transv(X, Y, (breaches X Y)) -> [breathesl. Incranev(X, (loves X) -> [loves]. lncransv(X, (lives X).-> [lives]. incranev(X, (breathes X) -> [breathes]. 2. Definite Clause Grammars","Figure [ shows a simple DCG grammar adapted from [Perelra] . Figure 2 gives a sentence in the language recognized by thls grammar together wlth the associated surface syntactic structure and the semantic structure built by the grammar. Fi E • 2. A Sentence, Structure and Representation SENTENCE \"John loves every woman who breathes\"","The way in which unification produces the appropriate bindings for this example ls actually quite subtle, and requires a detailed analysis of the parse, as represented by the refutation graph in Figure 3. For the the refutation graph the Prolog clauses have been put into claueal normal form. Some liberties have been taken with the ordering of the predicates in the interest of compactness.","In trying to establish the \"s(P)\" goal, the \"np(X,Pt,P)\" is first attempted. The \"PI\" is an empty variable that is a \"place-holder\" for predicate information chat will come from the verb. It will \"hold\" a place in the sentence structure that will be provided by =he determiner. \"P\" is destined to contain the sentence structure. The SYNTACTIC STRUCTURE","(S (NP (NAME john))","(VP (TRANSV loves) (NP (DET every)","(NOUN woman)","(REL (VP (INTRANSV breathes))))))) SEMANTIC REPRESENTATION","(ForAll XI (=> (And (woman XI) (breathes XI)) (loves john XI))) 63"]},{"title":"Pig. 3. Refutation Graph -..~/~ \\/ -np(X.Pt,e) \\/ -vp(X,et) \"vp(X,Pt)\\/'np(X,Pi,P) np(X.P,P) V -~,.q..~~ \\/ -[john] \"vD(to~~.,~.~\\/'transv(X,Y,Pt)\\/-n ~ _~ -np(Y,PL,P),/-transv(John.Y.Pl)~rnn.v(X-Y-love.(X.Y~\\/-[Loves]~'~l] ) flovesl [ 1 -det(X,F2,PL,P)\\/ nD(Y loves ~ohn Y) P \\/ loveq ve -n(X'P3)\\/relclause(X'P31P2)\\/n~ [~[__sry_]\\/-det(X,Pi,P2t(ForalX X ( >Pl P2))) -decCY.P2.Loves(iohn.Y).P)\\/ / -n(Y,P3)\\/-relclause(Y,P3,P2) (P is bound to \"Forall Y(=>~ lo~s(john,Y))\") [ ] \"[woman]\\/-n(X,{woma~V'relclause(Y,P3,P2) [woman] \"[woman]\\/ -relclause(Y.(woman Y).P2~ -vp(X,P2)\\/ -[that]\\/ \\ rel¢ PL .0o)). (PI is bound to \"And-(woman Y) P2\")//lause(x'PL'(And intransv(X.~eathes(X~ -Int~'~nq.(V:P2~ ~/ (P2 is bound Co \"breathes(Y)\") 64","paragraphs":["first \"np\" clause will be matched, but it will eventually fall since no determiner is present. The second \"rip\" clause will'succeed, having forever identified the contents of \"Pl\" with the contents of \"P, \" whatever they may be. Since there is no determiner in the first noun phrase, there is no quantification information. The quantlflcatlonal structure must be supplied by the verb phrase, so the structure for the sentence will be the same as the structure for the verb phrase. The variable \"X\" will be bound to \"John\".","In trying co establish \"vp(John,Pl), \" the first \"wp\" clause w(ll succeed, since \"loves\" is a transitive verb. It is important not to get the variables confused. Within the \"vp\" clause our original \"Pl\" has been renamed \"P\" and and we have a new \"PI\" variable that will be Instantlated to \"(loves John Y)\" by the success of the \"=canny\" goal. The \"Y\" Is as yet undetermined, but we can see that It will be supplied by the next \"np(Y,(loves John ¥),P)\" goal. It shows great foresight on \"transv's\" part to pass back a variable in such a way that it will correspond to a variable that has already been named. This pattern is repeated throughout the grammar, with powerfull repurcusslons. It is even clearer In the success of the \"np(Y,(loves John Y),P)\" goal, where the presence of the determiner \"every\" causes \"P\" to be bound to (Forall Y (-> PI (loves John Y)) This \"P\" is of course the \"P\" mentioned above which has been waiting for the verb phrase to supply It with a quantlflcatlonal structure.","As the relative clause for this \"up\" is processed, the \"PI\" embedded in this structure, (our second new PII), is eventually bound to \"(And (woman Y) (breaches Y))\" giving us the full structure:","(Forall Y (-> (And (woman Y) (breaches Y)) (loves John Y))) This is whac is returned as the binding to the first \"Pl\" in the original \"vp(X,Pt)\" goal. Since our \"np(X,P[,F)\" goal identified \"P\" wlth \"Pl, \" our \"s(P)\" goal succeeds with the binding of","(Forall Y (=> (And (woman Y) (breathes Y)) (loves John Y))) for \"P\" - the final structure built for the sentence.","In following the execution of this grammar it becomes clear that very ~trong predictions are made about which parrs of the parse will be supplying particular ~ypes of information. Determiners will provide the quanClElers for the propositional ~tructure of the sentence, the flrsc noun phrase and the noun phrase following the verb will be the two participants in ~he predicate implied by the verb, etc. Obviously this is a simple grammar, but the power of the logical variables can only be made use of through the encoding of these strong linguistic assumptions. DCG's seem to provide, a =echanlsm well qualified for expressing such assumptions and then executing them. Coming up with the assumptions in the first place Is, of course, something of a major task In itself. 3. Comparing DC and ATN Grammars","Figure 4 shows an ATN grammar which is the \"equivalent\" of the DCG grammar given in Figure t. The format used to specify the grammar is the one described in [flninl] and [finln2] . There are only two minor ways that this particular formalism differs from the standard ATN formalism described in [WoodsY0] or [Bates] . First, the dollar sign Character (i.a. $) followed by the name of a register stands for the contents of that register. Second, the function DEFATN defines a set of arcs, each of which is represented by a llst whose first element is the name of the state and whose remaining elements are the arcs emanating from the state.","In addition, this example uses a very simple lexical manager in which a word has (1) a set of syntactic categories to which It belongs (2) an optional set of features and (3) an optional root form for the word. These attributes are associated with a word ualng the function LEX, which supplies appropriate default values for unspecified arguments.","In the standard ATN model, a PUSH arc invokes a sub-computatlon which takes no arguments and, if successful, returns a single value. One can achieve the affect of passing parameters to a sub-computatlon by giving a register an initial value via a SENDR register setting action. There are two methods by which one can achieve the effect of returning more than one value from a sub-computatlon. The values to be returned can be packaged into a llst or the LIFTR register setting action can be used to directly set values in the higher level computation. This grammar makes use of SENDR and LIFTR to pass parameters into and ouC of ATN computations and thus the actions of the DCC example.","Consider what must happen when looking for a noun phrase. The representation for a NP will be a predicate if the noun phrase is indefinite (i.e. \"a man\" becomes (man X)) or a constant If the noun phrase is a name (l.e. \"John\" becomes John). in this simple language, a NP is dominated by a either a sentence (if it is the subject) or by a verb phrase (if It ts the object). [n either case, the NP also determines, or must agree with, the overall structure used to represent the dominating constituent. If the NP is a simple name, then Lt exerts no additional influence on the representation of its dominator. If the NP is noc a name, then It is indeflnice and will eventually result in a quantified expression for the dominating sentence or verb phrase, in this case we need to tell the dominating computation what the predicate, quantifier, connective, and variable name must be. In this ATN grammar, this ts done b? having the NP network return a value to represent the NP predicate and llft values for the quantifier, connective and variable name. 65 Fig. 4. An Equivalaut ATN Gra~ar"]},{"title":"¢lOmq~","paragraphs":["V (defatn (s (push"]},{"title":"npt (setr","paragraphs":["subj"]},{"title":"*) (to","paragraphs":["s/subJ)))","(s/subJ (push vp t (setr vp *) (sendr subJvar $var) (to s/end)))"]},{"title":"(s/end (pop (list $quanc $var (list $connect $aubJ $vp)) $subj)","paragraphs":["(pop gYp (null gsubj)))","(np (wrd a t (liftr quant \"ForSome)","(llftr connect \"And)(co np/det))","(wrd every t (liftr quant \"ForAll)","(liftr connect \"->)(to"]},{"title":"np/det))","paragraphs":["(cat name t (setr vat *) (to rip/rip)))","(np/det (cat n t (sect var (gensym)) (setr n (list * Svar)) (to np/n)))","(np/n (wrd (who that which) t (to up/n/who)) (Jump np/np t)) (np/np (pop gn C (liftr var)))"]},{"title":"(np/n/who (push","paragraphs":["vp"]},{"title":"t (sendr subJvar","paragraphs":["gvar)"]},{"title":"(serf n (list \"And","paragraphs":["gn *)) (to"]},{"title":"np/np)))","paragraphs":["(vp (cat v t (setrv *) (co vp/v)))"]},{"title":"(vp/v (push np (getf trans Sv) (sect obJ *) (seCt objvar Svar) (to vp/vp))","paragraphs":["(pop (list gv $subjvar) (gaff lntrans $v)))","(vp/vp (pop (list gquant $objvar (list $connect $obJ","(list gv $subJvar $objvar))>","$obj) (pop (flat $v gsubjvar $obJvar) (null $obJ)))~ ; (le× <word> <category> <features> <rootform>) (lex man n) (lex woman n) (lax loves v (intrans crans)) (lax breathes v (incrans trans)) (lax lives v (Intrans)) (lex john name) (lex mary name) (lex fldo name) 66","Similarly, when we are lookzn8 for a verb phrase, we must know what token (i.e. variable name or constant) represents the subject (if the verb phrase is dominated by a S) or the head noun (if the verb phrase acts as a relative clause). This is done by sanding the subJvar register in the sub-computation the appropriate value via the SENDR function. The techniques used to quancificatlon and build an overall sentence structure in chls ATN grammar are similar co those used in th~ BBN Lunar Grammar [Woods72] .","This heavy use of SENDR and LIFTR co communicate between levels in the grammar makes the ATN grammar cumbersome and difficult to unaerstand. In the next secton we investigate treating ATN registers as logic variables and providing a unification operation on them. 4. Replacing ATN Registers with ATN Variables","Although the previous &TN grammar does the Job, it is clearly awkward. We can achieve much of the elegance of the DCG example by treating the ATN registers as logical variables and including a unification operation on them. We will call such registers ATN Variables.","Since our ATN variables must not be tampered with between unifications, assignment operations such as SETR, LIFTR and SENDR are precluded. Thus the only operations on ATN Registers are access and ualfy."]},{"title":"It","paragraphs":["is possible to provide operations similar to the standard SENDR and LIFTR by defining unification operations which do the unification in the another environment, but we have not explored these possibilities.","The scheduler component of the ATN parser has been modified to be sensitive"]},{"title":"to","paragraphs":["the success or failure of attempted unifications, if a unification operation on an arc fails, the arc is blocked and may"]},{"title":"not","paragraphs":["be taken.","Figure 5 shows a grammar in the extended ATN formalism. A symbol preceded by a \"$\" represents an ATN Variable and \"*\" will again stand for ~he current constituenE. Thus in the state S in the grammar:","(S (PUSH NP (UNIFY \"($SUBJVAR gYP $S) *) (TO S/SUBJ))) the parser pushes to the state NP co parse a noun phrase. If one is found, it will pop back wi~h a value which will then be unified wi~h the expression (SSUBJVAR $VF $S). If this unification is successful, the parser will advance to state S/SUBJ. If It fails, the arc is blocked causing the parser to backtrack into the NP network.","Although our grammar succeeds in mimicking the behavlour of the DCG, there are some open questions Involvlng the use of unification [n parsing natural languages. An examination of ~his ATN grammar shows that we are really using unification as a method of passing parameters. The full power of unlficatton ls noc needed In this example since the Fig. 5. An Equivalent ATN Gra.mar with ATN Variables NP .... (defatn (s (push np (unify \"($subJvar $vp es) *)"]},{"title":"(to s/subJ)))","paragraphs":["(s/subJ (push vp t (unify \"$vp *) (tO s/s))) (s/s (pop es t))","(np (wrd a t (unify \"$np '(gorSome $var (And epred ehole))) (to np/det))","(wrd every t (unify","'Sup","\"(ForAll ever (=> epred Shole)))","(to np/det))","(cat name t (unify 'Sap '$hole)","(unify \"eYrir *)","(tO np/np)))","(np/det (cat n C (unify \"$var (gensym)) (unify \"$pred \"(* evar)) (to np/n)))","(np/n (wrd (who that which) t (to np/ulwho)) (Jump rip/rip t)) (up/up (pop (Slat evar \"$hole $np) t ))","(np/n/who","(push vp t (unify \"$subJvar '$var)","(unify \"$pred \"(And Spred *))","(to up/up)))","(vp (cat v (getf trans *) (unify \"$v \"(* esubjvar $obJvar)) (to vp/vtrans))","(cat v (getf [ntrans *) (unify \"$v '(* $subjvar)) (to vp/vp)))","(vp/vtrans (push np t (unify \"($objvar ev $vp) *) (tO vp/vp))) (vp/vp (pop evp t)) 67 grammar does not try to find \"most-general unifiers\" for complicated sets of terms. Most of the time it is simply using unification to bind a variable to the contents of another variable. The most sophisticated use involves binding a variable in a term to another copy of that term which also has a variable to be bound as in the \"a man loves a woman\" example in Figure 6. But even this binding is a simple one-way application of standard unification. St is not clear to the authors whether this is due to the simple nature of the grammars involved or whether it is an inherent property of the dlrectedneee of natural language parsing.","A situation where full unification eight be required would arise when one is looking for a constituent matching some partial description. For example, suppose we were working with a syntactic grammar and wanted to look for a singular noun phrase. We might do this with the following PUSH arc: (PUSH NP T (UNIFY * '(NP (DET eDET)"]},{"title":"(NUMBER SINGULAR)","paragraphs":["(ADJ $ADJS) ...)) If we follow the usual schedule of interpreting ATN gra.---rs the unification will not occur until the NP network has found a noun phrase and popped back with a value. This would require a fully symmetric unification operation since there are variables being bound to values in both arguments. It is also highly inefficient since we may know rlghc away that the noun phrase in the input is not singular. What we would iike is to be able to do the unification Just after the push is done, which would more closely parallel a Prolog-based DCG parse. Then an attempt to \"unify\" the number register with anything other than singular will fall immediately.","This could be done automatically if we constrain a network to have only one state which does a pop and place some additional constraints on the forms that can be used as values to be popped. Although we have not explored this idea at any length, it appears to lead co some interesting possibilities. 5. Conclusions We have found the use of logical variables and unification to be a powerful technique in parsing natural language. It [s one of the main sources of the strengths of the Definite Clause Grammar formalism. In attempting to capture this technique for an ATN grammar we have come co several interesting conclusions, First, the strength of the DCG comes as much from the skillful encoding of linguistic assumptions about the eventual outcome of the parse as from the powerful tools it relies on. Second, the notion of logical variables (with unification) can be adapted to parsing systems ouside of the theorem proving paradigm. We have successfully adapted these techniques to an ATN parser and are beginning to embed them in an existing parallel bottom-up parser [flnln3] . Third, the full power of unlfication may not be dddessary tO suddessfully u&e ldgidal variables in natural lanuage parsers. Fig. 6. Zxatple Pa~Ses with the ATW G~am~ \"John loves every woman who breathes\"","(ForAll XI (-> (And (woman Xl) (breathes XI)) (loves John Xl))) \"John loves a woman\" (ForSome Xl (And (woman Xl) (loves John XI))) \"a man loves a woman\"","(ForSome XI","(And (man X[)","(ForSome X2 (And (woman X2)","(loves Xl X2)))) \"every man who lives loves\"","(ForAll Xl (-> (And (man XI) (lives XI)) (loves Zi))) \"every man who loves mary loves a woman who loves john\"","(ForAll Xl","('> (And (man XI) (loves XI mary)) (ForSome X2 (And (And (woman X2)","(loves X2 John))","(loves XI X2))))) \"every man who loves a woman who loves every dog loves every dog\"","(ForAll XI","(=> (And (man XI)","(ForSome X2","(And (And (woman X2)","(ForAll X3","(=> (dog X3)","(loves X2 X3))))","(loves Xl X2))))","(ForAll X4 (-> (dog X4) (loves Xl X4))))) 6. References [. Bates, M., Theory and Practice or %ugmented Transition Network Grammars, in Natural Language Communication with Computers, ~7--\"~c~ Springer-Verlag, [978. 2. Bossle, S., \"A Tactical Component for Text Generation: Sentence Generation Using a Functional Grammar\", report HS-CIS-[982-26, Computer and Informatlon Science, University of Pennsylvania,"]},{"title":"1982.","paragraphs":["3. Codd, E. F., Arnold, R.S., Cad[on, J-M., Chang, C. L. and Roussopoulos, N., RENDEZVOUS Version 1: An Experimental Engllsh-Language Query Formulation System for Casual Users of Relational Data Bases, Report RJ2144, IBM Research Laboratory, San Jose, January 1978 4. Coimerauer, A., \"Metamor1~hosls Grammars\", in L. Bolt (Ed.), Natural Language Communication with"]},{"title":"Computers,","paragraphs":["Sprlnger-Verlas, I978. 5. Finln, T., An Interpreter and Compiler for Augmented Transition Networks, Coordinated Science Laboratory technical report T-48, University of Illinois, 1977. 6. Finln, T., Parsing with ATN Grammars; to appear an Leonard Bolt (ed.) Data Base question Answerin~ Systems, Sprlnger-Verlag, Berlin, [982. 7. Fin[n, T. and B. L. Webber, BUP - A Bottom Up Parser, report MS-CZS-[982-27, Computer and Information Science, University of Pennsylvania, [982. 8. ffeidorn, G., Augmented Phrase Structure Grammar, TINLAP-[, [975. 9. Kay, H., \"Functional Grammar\", Proceedings of th__ee Fifth Annual Meeting of the Berkeley Lin~uistic Sgciety , [979. [0. Pratt, V. \"LINGOL, A Progress Report\", IJCAI ~, 1975. I[. ?ereira, F. and D. Warren, \"Definite, Clause Grammars for Language Analysis - A Survey of the Formalism and a Comparison with Augmented Transition Networks\"., Artificial Intelligence [3 ([980), 231-278. [2. Winograd, T., Language as ~ Co~nitive Proce~-, Addison-Wesley Publishing Co.,Inc,[983, 349-351. 13. Woods, W., Transition Network Grammars ~ Natural Language Analysis, CACM 13:10, 1970. 14. Woods, W. A., R. M. Kaplan and B. L. Webbe \"The Lunar 3ciences Natural Language Informatio:"]},{"title":"System:","paragraphs":["F~nal Report\", BBN report 2378, [972. 68"]}]}