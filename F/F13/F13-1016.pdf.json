{"sections":[{"title":"Traitements d’ellipses : deux approches par les grammaires catégorielles abstraites Pierre Bourreau","paragraphs":["1 ∗","(1) SFB 991","Institut für Sprache und Information","Université Heinrich-Heine, 40225 Düsseldorf"]},{"title":"R","paragraphs":["ÉSUMÉ L’étude de phénomènes d’ellipses dans les modèles de l’interface syntaxe-sémantique pose certains problèmes du fait que le matériel linguistique effacé au niveau phonologique est néanmoins présent au niveau sémantique. Tel est le cas d’une ellipse verbale ou d’une élision du sujet, par exemple, phénomènes qui interviennent lorsque deux phrases reliées par une conjonction partagent le même verbe, ou le même sujet. Nous proposons un traitement de ces phénomènes dans le formalisme des grammaires catégorielles abstraites selon un patron que nous intitulons extraction/instanciation et que nous implémentons de deux manières différentes dans les ACGs."]},{"title":"A","paragraphs":["BSTRACT Treating ellipsis : two abstract categorial grammar perspectives The treatment of ellipsis in models of the syntax-semantics interface is troublesome as the linguistic material removed in the phonologic interpretation is still necessary in the semantics. Examples are particular cases of coordination, especially the ones involving verbal phrase ellipsis or subject elision. We show a way to use abstract categorial grammars so as to implement a pattern we call extraction/instantiation in order to deal with some of these phenomena ; we exhibit two different constructions of this principle into ACGs."]},{"title":"M","paragraphs":["OTS"]},{"title":"-","paragraphs":["CLÉS"]},{"title":":","paragraphs":["ellipse, coordination, interface syntaxe-sémantique, grammaires catégorielles abstraites, grammaires d’arbres adjoints, grammaires IO d’arbres."]},{"title":"K","paragraphs":["EYWORDS"]},{"title":":","paragraphs":["ellipsis, coordination, syntax-semantics interface, abstract categorial grammars, tree-adjoining grammars, IO tree-grammars.","∗. Ce travail a été financé par la DFG, dans le cadre du projet SFB 991 “Die Struktur von Repräsentationen in Sprache, Kognition und Wissenschaft”. TALN-RÉCITAL 2013, 17-21 Juin, Les Sables d’Olonne 215 c⃝ ATALA"]},{"title":"1 Introduction","paragraphs":["La description de la syntaxe du langage naturel par le biais de formalismes symboliques a donné lieu à la création de nombreux modèles tels que les grammaires non-contextuelles, comme première approximation, et plus récemment les grammaires catégorielles combinatoires (CCGs pour combinatory categorial grammars) (Steedman, 1987) ou les grammaires d’arbres adjoints (Joshi et al., 1975; Joshi, 1985) (TAGs pour tree-adjoining grammars). Tous ces formalismes partagent la propriété de ne pas effacer, et de ne pas copier de ma-tériel syntaxique ou phonologique : nous parlerons de propriété de linéarité. Cependant, certains phénomènes syntaxiques usuels semblent nécessiter des mécanismes de copie et/ou d’effacement : (1) Marie mange une pizza, et Pierre ε des pâtes. (2) Jean fait un footing et ε rattrape Marie. (3) Jean prépare ε et Marie vend des crêpes. Sur les exemples ci-dessus, des éléments phonologiques sont absents par économie de langage : le verbe “mange” en (1), et les syntagmes “Jean” en (2) et “des crêpes” en (3). Tous ces éléments sont néanmoins présents au niveau de l’arbre syntaxique (pour la correction grammaticale) ou de la sémantique. Par ailleurs, ces trois exemples partagent la présence de la conjonction de coordination “et” reliant deux phrases. Nous nous intéressons au traitement de ces phénomènes d’ellipse sous la présence de marqueurs de coordination. Plusieurs solutions à ce problème ont été proposées afin d’étendre les formalismes grammaticaux cités ci-dessus. Ainsi, (Steedman, 1990) montre comment traiter de telles coordinations dans les CCGs ; ces idées ont ensuite été implémentées par (Sarkar et Joshi, 1996) dans les TAGs, en étendant le formalisme initial afin d’enrichir les arbres de dérivation par une notion de partage de noeuds, idée ensuite reprise dans (Seddah, 2008; Seddah et al., 2010). Enfin, (Kobele, 2007) propose l’utilisation de grammaires non-contextuelles d’arbres avec copie IO (notées IO-CFTGs pour IO context-free tree grammars). Nous proposons d’utiliser un formalisme plus expressif que les précédents, à savoir les grammaires catégorielles abstraites (ACGs pour abstract categorial grammars) (de Groote, 2001; Muskens, 2001). Il est en effet possible d’encoder des grammaires de chaînes ou des grammaires d’arbres dans les ACGs. Qui plus est, la notion de dérivation y est également relativement flexible puisqu’il est possible de considérer non seulement des arbres mais aussi des λ-termes comme structures de dérivation. En utilisant ces avantages, nous implémentons le principe suivant : une phrase où une ellipse intervient est d’abord partiellement construite, en omettant le constituant commun, qui est rajouté lors de l’étape suivante. Ce principe peut être naturellement réalisé dans le λ-calcul par le biais de la substitution de termes. En suivant ce principe, nous présentons deux méthodes, la première faisant intervenir la substitution au niveau des structures de dérivation (ou tectogrammaire), la seconde au niveau de la syntaxe (ou phénogrammaire). Nous discutons des avantages de chacune des deux méthodes, et en particulier de l’existence d’algorithmes d’analyse s’exécutant en temps polynomial pour chacune d’elles. Le reste de cet article est structuré comme suit : en section 2, nous présentons les ACGs. En section 3, les deux approches que nous proposons seront détaillées et discutées. Enfin, en section 4, nous comparerons notre solution à celles existantes dans la littérature. TALN-RÉCITAL 2013, 17-21 Juin, Les Sables d’Olonne 216 c⃝ ATALA"]},{"title":"2 Grammaires Catégorielles Abstraites","paragraphs":["Les grammaires catégorielles abstraites peuvent être vues comme des grammaires de λ- termes simplement typés. Étant donné un ensemble de types atomiques , nous définissons l’ensemble ( ) des types simples sur par ( ) ::= |( ( ) → ( )) Nous adopterons la notation usuelle permettant d’omettre certaines parenthèses : un type (α1 → (α2 → α3)) sera noté α1 → α2 → α3. Une signature d’ordre supérieur est un tuple Σ =( , C, τ) où : – est un ensemble fini de types atomiques. – C est un ensemble fini de constantes. – τ est une fonction d’assignation de types de C dans ( ). Afin de construire des termes sur une telle signature, nous nous donnons un ensemble de variables typées : la notation xα","désignera une variable x de type α. Étant donnés une signature Σ =( , C, τ) et un type α ∈ ( ), l’ensemble Λα(Σ) des λ-termes de type α dans Σ se définit par induction :","1. une variable xα","appartient à Λ α(Σ). 2. une constante c de C appartient à Λα(Σ) si τ(c)=α. 3. si M est un terme de Λα2(Σ) et si α = α1 → α2, alors λxα1",".M est un terme de Λ α(Σ). 4. si M1 appartient à Λβ (Σ) et M2 à Λβ→α(Σ), alors (M1M2) appartient à Λα(Σ). L’ensemble des termes simplement typés de Σ est donné par Λ(Σ)=(Λα(Σ))α∈ ( ). Nous adopterons la convention usuelle suivante : un terme (...((M1M2)M3) ...Mn) sera écrit M1M2M3 ...Mn. De plus, nous omettrons d’écrire les types des variables lorsqu’ils ne sont pas indispensables à la compréhension. Nous supposerons que les notions de variables libres et de β-réduction sont connues ; nous noterons FV(M) l’ensemble des variables libres d’un terme M ; M1→∗","β M2 la β-réduction d’un terme M1 en M2 en un nombre arbitraire de β-contractions, et |M|β la forme β-normale d’un terme simplement typé. Pour plus de détails sur le λ-calcul simplement typé, le lecteur peut se référer à (Hindley, 1997).","L’ensemble Linα(Σ) des termes linéaires de type α dans Σ est défini par induction sur les","règles 1. et 2. ci-dessus (en remplaçant Λα(Σ) par Linα(Σ)) et : 3’. si M est un terme de Linα2(Σ), si α = α1 → α2 et si xα1","∈ FV(M), alors λxα1",".M est un terme de Linα(Σ).","4’. si M1 appartient à Linβ (Σ), M2 à Linβ→α(Σ) et que FV(M1)∩ FV(M2)=, alors (M1M2) appartient à Linα(Σ). L’ensemble QAff α(Σ) des termes quasi-affines de type α dans Σ est construit par induction sur les règles 1., 2., 3. et la règle suivante : 4”. si M1 appartient à QAff β (Σ), M2 à QAff β→α(Σ) et que pour toute variable xβ","∈ FV(M1)∩","FV(M2), β ∈ , alors (M1M2) appartient à QAff α(Σ). L’ordre (α) d’un type α se définit par induction sur α : si α ∈ alors (α)=1 ; sinon, α = α1 → α2 et (α)=max( (α1)+1, (α2)). Par extension, l’ordre d’une signature Σ =( , C, τ) se définit comme : (Σ)=maxc∈C ( (τ(c))). TALN-RÉCITAL 2013, 17-21 Juin, Les Sables d’Olonne 217 c⃝ ATALA Remarquons qu’il est possible de voir une signature d’arbre comme une signature d’ordre 2 : dans une telle signature, tout terme M de type atomique et tel que FV(M)= peut effectivement être interprété comme un arbre. Par exemple, l’arbre f (a, b, g(c)) peut être représenté par le terme f o→o→o→o","ao","bo","(go→o","co","), où o est un type atomique. De plus, si toutes les constantes d’une signature d’ordre 2 sont de type o → o (où o est un type atomique), les termes de la signature peuvent être interprétés comme des chaînes : la chaîne “Jean mange une pomme” est ainsi représentée par le terme λx o",".Jean(mange(une(pomme x))). Étant données deux signatures Σ1 =( 1, C1, τ1) et Σ2 =( 2, C2, τ2), un morphisme de Σ1 vers Σ2 est défini à partir d’un couple de fonctions [ 1; 2] vérifiant : – étant donné un type α ∈ ( 1) : – (α)= 2(α) ∈ ( 2) si α appartient à 1. – (α)= (α1) → (α2) si α = α1 → α2. – étant donné un terme M de Λ(Σ1) : – si M = xα",", (M)=x (α)","; – si M = c ∈ C1 et τ1(c)=α, (M) ∈ Λ (α)(Σ2) ; – si M = λxα",".N , (M)=λ (xα","). (N ). – si M = M1M2, alors (M)= (M1) (M2). Finalement, une ACG G est définie comme un tuple (Σ1, Σ2, , s) où Σ1 et Σ2 sont deux signatures d’ordre supérieur (appelées respectivement signature abstraite et objet de G), est un morphisme de Σ1 vers Σ2, et s est un type atomique de Σ1. Une telle grammaire définit deux langages : un langage abstrait A(G)={M ∈ Lins(Σ1) | FV(M)=} ; un langage objet O(G)={M ∈ Λ(Σ2) | ∃N ∈ A(G), | (N )|β = M}. De manière informelle, le langage abstrait correspond à l’ensemble des dérivations du langage O(G) généré par la grammaire. Une ACG G est d’ordre n ∈ si la signature abstraite de G est d’ordre n (nous écrirons que G est une n-ACG) ; de plus, une n-ACG est dite linéaire (resp. quasi-affine) si pour toute constante c de la signature abstraite de G, (c) est un terme linéaire (resp. quasi-affine). ΣDERIV ΣSYN ΣSURF ΣSEM FIGURE 1 – Exemple de modélisation de l’interface syntaxe-sémantique par des ACGs Grâce au pouvoir expressif du λ-calcul, (de Groote, 2002) et (de Groote et Pogodalla, 2004) ont montré qu’il est possible d’encoder de nombreux formalismes grammaticaux, dont les TAGs, comme des 2-ACG linéaires. Par ailleurs, lorsqu’on adopte l’hypothèse de compositionnalité, il est possible de représenter l’interface syntaxe-sémantique par l’intermédiaire de deux ACGs G1 =(ΣDERIV, ΣSYN, SYN, s) et G2 =(ΣDERIV, ΣSEM, SEM, s) (voire (de Groote, 2001; Pogodalla, 2004, 2007) pour plus de détails). Un des avantages de ce modèle est donc de représenter syntaxique et sémantique en parallèle, tout en traitant certains problèmes à des niveaux différents (par exemple, l’ordonnancement des mots peut être traité au niveau de la syntaxe, voire de la réalisation de surface, et non pas au niveau des dérivations). De plus, il est facile d’isoler les différentes représentations d’une phrase, tel que montré sur la figure 1. TALN-RÉCITAL 2013, 17-21 Juin, Les Sables d’Olonne 218 c⃝ ATALA"]},{"title":"3 Extraction et instanciation","paragraphs":["Comme énoncé en introduction, nous souhaitons séparer la construction de phrases avec ellipses en deux étapes : la première consiste à construire une représentation incomplète ; la seconde à instancier cette représentation à l’aide de l’élément partagé. Au niveau de la représentation de surface seule une de ces occurrences sera réalisée. Ainsi, pour la phrase “Jean mange une pizza et Pierre, des pâtes”, nous pouvons considérer que nous avons deux constituants incomplets, “Jean ε une pizza” et “Pierre ε des pâtes” qui sont reliés par la conjonction “et”. Le verbe “mange” est ensuite rajouté à chacun de ces deux constituants, bien que non-réalisé phonétiquement pour le second. Le fait de garder une copie du constituant commun est nécessaire dans les ACGs puisque les dérivations des représentations syntaxiques et sémantiques sont symétriques, et qu’une copie de la forme sémantique du constituant commun est nécessaire, comme illustré dans la formule logique (∃x.Pizza(x) ∧ Mange(x, Jean) ∧ (∃ y.PlatPates( y) ∧ Mange( y, Pierre)) représentant la sé- mantique de la phrase ci-dessus. La modélisation du principe extraction/instanciation est réalisée de manière relativement naturel dans le λ-calcul simplement typé. En effet, un objet incomplet peut être représenté par un terme de la forme λx.M, où x est une variable dont les occurrences libres dans M représentent des emplacements vides de l’objet M. L’instanciation de ces emplacements par un objet N est ensuite simplement réalisée par application dans le λ-calcul et le terme (λx.M)N est donc l’objet M où les occurrences (libres) de x (dans M) sont substitués par N ."]},{"title":"3.1 Enrichir les structures dérivationelles","paragraphs":["Dans ce premier modèle, nous montrons comment la construction de constituants incomplets peut se réaliser au niveau de la signature des dérivations. Cette approche nous amène à écrire des ACGs dont l’ordre est supérieur à 2 ; en effet, à une phrase à laquelle il manque un verbe transitif sera associée une dérivation de la forme λx.M, de type (np → np → s) → s ; la conjonction de deux phrases incomplètes implique de prendre deux termes de ce type en argument, et donc de manipuler des constantes d’ordre 4. En guise d’exemple, nous considérons la grammaire suivante GSURF =(ΣDERIV, ΣSURF, SURF, s), afin d’illustrer la modélisation d’ellipses verbales : – ΣDERIV =    DERIV = {np, s} cJean, cLuc, cPierre, cMohamed : np caime : np → np → s cet−TVel : α → α → α (où α =(np → np → s) → s) – ΣSURF =  SURF = {σ} Jean, Luc, Pierre, Mohamed, aime, et : σ → σ – SURF =   ","np, s := σ → σ (noté σ2",")","cJean := λxσ .JeanxcLuc := λxσ",".Lucx","cMohamed := λxσ .MohamedxcPierre := λxσ",".Pierrex caime := λPσ2 Qσ2 xσ",".Q(aime(Px))","cet−TVel := λPβ→σ2 Qβ→σ2","Rβ","xσ",".PR(et(Q(λSσ2","1 Sσ2","2 yσ",".S 2(S1 y))x))","(où β désigne le type σ2","→ σ2","→ σ2",") TALN-RÉCITAL 2013, 17-21 Juin, Les Sables d’Olonne 219 c⃝ ATALA","Le terme MDERIV = cet−TVel(λPnp→np→s .PcLuccJean)(λPnp→np→s",".PcMohamedcPierre)caime appar-","tient à Λs (Σ","DERIV). De plus, il est possible de vérifier que SURF(MDERIV) se β-réduit en λx.Jean(aime(Luc(et(Pierre(Mohamedx))))). L’ACG ainsi obtenue est une 4-ACG linéaire. Cette construction peut s’étendre à d’autres types d’ellipses, tels que les ellipses du sujet ou de l’objet : il suffit alors de rajouter des constantes cet−Sel et cet−Oel de type (np → s) → (np → s) → np → s dans ΣDERIV. Comme alternative, nous pouvons envisager la généralisation de cette constante à un type X → X → X tel que proposer dans (Steedman, 1990). Afin de construire la représentation sémantique de cet exemple, il nous suffit de créer une seconde ACG GSEM =(ΣDERIV, ΣSEM, SEM, s) comme suit : – ΣSEM =    SEM = {e, t} J, L, P, M : e A : e → e → t ∧ : t → t → t – SEM =    np :=(e → t) → t (noté γ) s := t cJean := λPe→t",".PJ c","Luc := λPe→t .PL","cMohamed := λPe→t .PM c","Pierre := λPe→t .PP","caime := λP(e→t)→t","Q(e→t)→t",".P(λx e",".Q(λ ye",".Axy)","cet−TVel := λP (γ→γ→t)→t 1 P","(γ→γ→t)→t","2 Rγ→γ→t",". ∧ (P1R)(P2R)","Cette construction nous permet d’obtenir une 4-ACG (ΣDERIV, ΣSEM, SEM, s). Nous remarque-","rons, néanmoins, que cette dernière n’est ni linéaire, ni quasi-affine : en effet, la variable R a","deux occurrences libres dans un sous-terme de SEM(cet−TVel). Commentaires : Les deux ACGs ainsi construites sont donc des n-ACGs où n > 2 ; ceci soulève un des inconvé- nients de cette méthode, puisque nous savons que, dans ce cas, le problème de l’appartenance est un problème NP-complet (Kanazawa et Yoshinaka, 2005a), lorsque l’ACG est linéaire. Du point de vue de la modélisation linguistique, notons qu’il est possible de traiter des cas d’ellipses multiples d’un même constituant sans modifier notre modèle. Ainsi, afin de pouvoir dériver la phrase : “Jean aime Luc, Pierre, Mohamed et Paul, Valérie.”, nous rajoutons la constante c,TV−el de type α → α → α (où α =(np → np → s) → s)àΣDERIV et telle que SURF(c,Tv−el)=λPβ→σ2 Qβ→σ2","Rβ","xσ",".PR(,(Q(λSσ2","1 Sσ2","2 yσ",".S","2(S1 y))x)) (en considérant les notations de types ci-dessus). Il est intéressant de remarquer que nous obtenons alors deux termes M1 et M2 dans Λs(ΣDERIV) tels que |SURF(M1)|β et |SURF(M2)|β sont égaux à λx.Jean(aime(Luc(,(Pierre(Mohamed(et(Paul(Valériex)))))))). Ces deux termes sont :","1. M1 = c,TV−el(λP.PcLuccJean)(λQ.cet−TVel(λR.RcMohamedcPierre)(λR.RcValeriecPaul)Q)caime correspondant à la dérivation de la phrase pour le parenthésage “[Jean aime Luc, [Pierre, Mohamed et Paul, Valérie]]”;","2. M2 = cet−TVel(λQ.c,TV−el(λP.PcLuccJean)(λP.PcMohamedcPierre)Q)(λR.RcValeriecPaul)caime correspondant à la dérivation de notre exemple pour le parenthésage “[[Jean aime Luc, Pierre, Mohamed] et Paul, Valérie]”; Par ailleurs, remarquons que le verbe n’est réalisé au niveau de la surface que dans le premier constituant gauche dominé par la coordination ; dans le second cas, il est remonté jusqu’au constituant correct de manière transitive. La grammaire reste alors une 4-ACG linéaire. TALN-RÉCITAL 2013, 17-21 Juin, Les Sables d’Olonne 220 c⃝ ATALA Cette construction peut s’étendre à l’analyse de phénomènes d’ellipses enchâssées comme dans la phrase suivante en Anglais : (4) After seeing John running a marathon, Paul planned to ε1, but Mary didn’t ε2.","Après avoir vu John courir un marathon, Paul a prévu de le faire, mais pas Marie. En simplifiant quelque peu la dérivation syntaxique, cette phrase est traitée dans notre modèle par l’intermédiaire d’un terme cafterM1(λP.cbutM′","1M′","2(cplanned−toP))crun ; le morphisme est ensuite construit en suivant l’exemple précédent. Il est important de remarquer la similitude entre cette construction et certains travaux antérieurs sur les ACGs. En effet, cette méthode repose sur le fait de retarder la concaténation de chaînes, de la même manière que (Pogodalla, 2007) utilise des ACGs d’ordre supérieur au niveau des dérivations afin de retarder l’ajout de matériel linguistique, permettant ainsi de modéliser les différentes portées des quantificateurs dans la représentation sémantique. Remarquons enfin, que nous avons modélisé la réalisation de surface sans décrire la réalisation de l’arbre syntaxique ; cette construction ne nous apporte effectivement aucune information supplémentaire sur l’analyse de cette première modélisation. Par ces divers exemples, nous montrons qu’il est possible de modéliser divers phénomènes d’ellipses de manière simple et élégante dans les ACGs, sans modifier le formalisme. Notre construction repose uniquement sur le fait de considérer des termes d’ordre supérieur au niveau des dérivations. Néanmoins, l’inconvénient d’une telle construction est que le traitement de ces phénomènes ne peut plus être réalisé en temps polynomial. Nous montrons à présent qu’une solution possible à ce problème consiste à considérer des ACGs d’ordre 2, et à enrichir le typage de la signature des dérivations, plutôt que la structure des termes."]},{"title":"3.2 Enrichir les types des dérivations","paragraphs":["Dans cette seconde approche, nous construisons des modèles de représentation de la structure de surface à partir des structures de dérivation de manière indirecte, par l’intermédiaire des structures syntaxiques arborescentes. Ceci nous permettra, en particulier, de mettre en avant la complexité des morphismes utilisés, cette propriété ayant un impact sur la complexité de l’analyse dans les ACGs 1",". Pour ce faire, nous introduisons un opérateur DEL d’effacement au niveau des arbres syntaxiques, à la manière de (Kobele, 2007) ou de l’opérateur de “deanchoring” sur les structures de dérivation dans (Lichte et Kallmeyer, 2010). Dans notre cas, un sous-arbre dominé par cet opérateur sera interprété comme la chaîne vide ε au niveau de la représentation de surface. Cet opérateur n’est donc pas indispensable à notre modèle, mais nous permet néanmoins de faire apparaître l’élément effacé dans l’arbre syntaxique. Nous donnons un exemple d’un tel arbre en Figure 2, dérivé par la grammaire GSURF = (ΣSYN, ΣSURF, SURF, o) définie par :","1. Nous aurions pu procéder de la même manière à l’étape précédente, mais les ACGs étant alors d’ordre 3, l’analyse n’est, a priori, déjà plus réalisable en temps polynomial TALN-RÉCITAL 2013, 17-21 Juin, Les Sables d’Olonne 221 c⃝ ATALA S S NP JEAN VP TV MANGE NP Det UNE N PIZZA Coord ET S NP PIERRE VP DEL TV MANGE NP Det DES N PÂTES FIGURE 2 – Arbre dérivé pour la phrase “Jean mange une pizza et Pierre, des pâtes.” – ΣSYN =    SYN = {o} SConj : o → o → o → o NP1, N , Det, Coord, TV, DEL : o → o S, NP2, VP : o → o → o JEAN, MANGE,PIERRE, UNE, DES, PIZZA, PÂTES, ET : o – ΣSURF =  SURF = {σ} Jean, mange, une, des, pizza, pâtes, et : σ → σ – SURF =   ","o := σ → σ","SConj := λPσ→σ","1 Pσ→σ","2 Pσ→σ","3 xσ",".P1(P2(P3 x))","S, NP2, VP := λPσ→σ","1 Pσ→σ","2 xσ",".P1(P2 x)","N , NP1, Det, Coord, TV := λPσ→σ","xσ",".Px DEL : λPσ→σ","xσ",".x","JEAN := λxσ",".Jeanx,PIERRE := λxσ",".Pierrex MANGE := λxσ",".mangex","UNE := λxσ",".unex, DES := λxσ",".desx PIZZA := λxσ",".pizzax","PÂTES := λxσ",".pâtesx ET := λxσ",".etx Nous remarquerons que l’opérateur DEL réalise l’effacement au niveau de la chaîne de carac-tères ; en effet, l’image de ce terme par le morphisme SURF est un terme quasi-affine, effaçant sur son premier argument. Ainsi, pour tout terme M, nous avons SURF(DELM)→∗","β λx.x. Nous pouvons alors vérifier que le terme MSYN correspondant à l’arbre de la figure 2 vérifie SURF(MSYN)→∗","β λx.Jean(mange(une(pizza(et(Pierre(des(pâtesx))))))) 2",". Par ailleurs, l’ACG ainsi présentée n’est pas lexicalisée : l’image de certaines constantes de ΣSYN par SURF ne contient pas de constantes. Néanmoins, nous savons qu’il est possible de construire une 2-ACG lexicalisée générant le même langage (Kanazawa et Yoshinaka, 2005b). Nous décrivons à présent, une seconde implémentation du principe d’extraction/instanciation, en créant de nouveaux types dans la signature des dérivations : le fait qu’un constituant d’une certaine catégorie syntaxique soit incomplet pour une autre catégorie syntaxique sera effectivement dénoté par un type distinct. En reprenant l’exemple de la figure 2, nous souhaitons donc pouvoir dériver un terme de la forme λx o",".M","1 et un terme λx o .M","2 représentant chacun les contextes d’arbre pour “Jean x une pizza” et pour “Pierre x des pâtes”, sachant que pour ce dernier, l’occurrence de x est dominée par une occurrence de l’opérateur DEL. Nous créons donc un type (noté sTVel) pour désigner les contextes d’arbre sur un verbe transitif, au niveau des dérivations. De plus,","2. Il est possible de lexicaliser SURF(DEL), en λPx., x par exemple, de manière à faire apparaître le signe de ponctuation “,”. TALN-RÉCITAL 2013, 17-21 Juin, Les Sables d’Olonne 222 c⃝ ATALA SYN(sTVel)=o → o, afin de rendre compte du fait que la dérivation d’un terme de type sTVel est un contexte d’arbre, tel que nous le codons dans le λ-calcul. Une constante cet est ensuite nécessaire à ΣDERIV afin de réaliser l’étape d’instanciation, mais cette fois au niveau des termes des arbres syntaxiques ; il suffit donc de typer cette constante par sTVel → sTVel → tv → s, un type d’ordre 2. On notera que pour ce faire, nous modifions le type associé aux verbes transitifs de np → np → s en tv. Intuitivement, ceci revient à associer à un verbe le plus grand sous-arbre dont l’unique racine est la réalisation phonologique associée au verbe. Afin d’illustrer notre proposition, nous donnons la grammaire GSYN =(ΣDERIV, ΣSYN, SYN, s) définie ci-dessous. Afin de mieux dissocier les deux étapes de notre méthode, nous isolons l’étape d’instanciation par l’intermédiaire d’une constante distincte, cSUB, le type de la variable cet s’en trouvant alors modifié : – ΣDERIV =    DERIV = {s, sTVel, vpTVel, n, np, v} cet : sTVel → sTVel → sTVel cSUB : sTVel → tv → s c1 : np → vpTVel → sTVel c2 : np → vpTVel c3 : n → det → np cJean, cPierre : np cmange : tv cune, cdes : det cpizza, cpates : n – SYN =   ","s, tv, n, np, det := osTVel, vpTVel := o → o","cSUB := λPo→o x o",".Px","cet := λPo→o","1 Po→o 2 x o",".S(P1 x)(Coord ET)(P2(DELx))","c1 := λto","Po→o x o",".St(Px) c2 := λto","x o",".VPx t c3 := λto","1 to","2.NP2 t2 t1 cJean := NP1JEAN, cPierre := NP1PIERRE cmange : V MANGE cune := DetUNE, cdes := DetDES cpizza : N PIZZA, cpates : N PÂTES En considérant la signature abstraite ΣDERIV, nous obtenons un terme Mderiv appartenant au langage abstrait et tel que Mderiv = cSUBM1M2 où 1. M1 = cet(c1cJean(c2(c3cunecpizza)))(c1cPierre(c2(c3cdescpates))) et 2. M2 = cmange. Nous remarquerons que SYN(M1) s’interprète alors comme un contexte d’arbre, de la forme λx o",".T , T étant l’arbre de la figure 2 où les occurrences du sous-arbre V MANGE sont remplacées par x. Commentaires Tout d’abord, remarquons que l’ACG G =(ΣDERIV, ΣSYN, SYN, s) est une 2-ACG quasi-affine. D’après (Bourreau et Salvati, 2011; Bourreau, 2011) ou (Kanazawa, 2007; Yoshinaka, 2006), nous savons que le problème de l’analyse, dans ce cas, peut être résolu en temps polynomial. Ce point différencie donc les deux approches présentées. Ensuite, nous remarquerons qu’il est à nouveau possible de généraliser le type associé à la conjonction cet au niveau des dérivations en α → α → α, avec, α ∈DERIV. TALN-RÉCITAL 2013, 17-21 Juin, Les Sables d’Olonne 223 c⃝ ATALA","Néanmoins, comme nous l’avons remarqué, l’ACG (ΣSYN, ΣSURF, SURF, o) n’est pas lexicalisée.","Le fait de considérer l’ACG lexicalisée équivalente (Σ′","SYN, ΣSURF, ′","SURF, o) de (Kanazawa","et Yoshinaka, 2005b) peut a priori avoir un certain impact sur la construction de l’ACG","(ΣDERIV, Σ′","SYN, ′","SYN, s), cette question demandant à être étudiée plus en détails.","Par ailleurs, le choix d’introduire l’opérateur DEL n’est destiné qu’à faire apparaître l’occur-","rence de constituant effacée dans l’arbre syntaxique. En effet, il est possible de modifier","notre modèle de sorte que SYN(cet)=λPo→o","1 Po→o","2 x o",".S(P1 x)(Conj ET)(P2ε), où ε est alors","une constante de ΣSYN, de type o et telle que SURF(ε)=λxσ",".xσ",". Dans cette proposition","alternative, l’ACG obtenue reste une 2-ACG linéaire. La gestion de l’effacement par enrichissement des types peut également s’étendre à l’analyse de phénomènes d’ellipses enchâssées comme dans la phrase (4) de la section précédente. Un tel cas peut-être traité dans notre proposition en rajoutant une étape supplémentaire d’extraction/instanciation, par l’intermédiaire d’une constante c′","SUB de type sV → vpVPinf → sV ,","et telle que SYN(c′ SUB)=λPo→o","1 Po→o","2 to",".P1(P2 t). L’utilisation d’une telle constante réalise","alors l’instanciation d’emplacements vides dans un arbre de type sV par un contexte d’arbre","de type vpVPinf . La dérivation de cet exemple est donc réalisée en construisant d’abord deux","contextes d’arbre : Le terme SYN(c′","SUB) permet alors de substituer les occurrences de x dans S S NP Paul x :VP Coord but S NP Mary VP Neg V does not DEL x :VP VP V planned to y :VPinf FIGURE 3 – Représentation de la dérivation pour “John planned to but Mary does not” le premier arbre par le second ; il suffit ensuite de suivre la procédure sur notre exemple initiale pour obtenir l’arbre souhaité. Nous pouvons alors voir que l’inconvénient principal de cette méthode est de devoir créer de nombreux types afin de prendre en compte les différents cas d’ellipses possibles, selon le constituant effacé. Notons également qu’il est possible de construire la sémantique associée à une phrase où une ellipse a été réalisée, de manière similaire à la construction précédente. Finalement, il apparaît que les deux constructions présentées sont liées : notre deuxième proposition repose sur le fait de décomposer les arbres syntaxiques en unité plus petite, ce qui aboutit à considérer une ACG non-lexicalisée, et à considérer un nombre de types plus grand. Cependant, il nous faudra étudier ce lien, et la possibilité d’abaisser l’ordre d’une ACG tout en préservant le langage généré. TALN-RÉCITAL 2013, 17-21 Juin, Les Sables d’Olonne 224 c⃝ ATALA"]},{"title":"4 Méthodes existantes","paragraphs":["Une première possibilité de traitement de certains phénomènes d’ellipse consiste à reprendre les idées de (Steedman, 1990) pour les grammaires catégorielles combinatoires, et à implémenter ces idées dans les ACGs. Steedman suggère, en particulier, l’utilisation d’un combinateur T de “type raising” afin de traiter des phénomènes d’élision du sujet ou de l’objet ; de plus, les ellipses verbales nécessitent l’introduction d’un combinateur supplémentaire Bx qui permet de rompre avec la directionnalité du calcul logique sous-jacent, et un opérateur de décomposition de type, permettant d’extraire le verbe d’une phrase. Dans le cadre des ACGs, l’opérateur Bx n’est pas nécessaires, puisque les types ne sont pas dirigés. l’utilisation du combinateur T revient à modifier les types assignés aux constantes de la signature des structures de dérivation. Sur un exemple, nous pouvons décrire une signature des dérivations faite des constantes cJean, cMarie : (np → s) → s, ccourt : np → s, crattrape : np → np → s et cet : (np → s) → (np → s) → (np → s). Cette signature permet de dériver un terme cMarie(λ ynp",".c","Jean(cetccourt(crattrape y))). Grâce au morphisme sem cidessous, il est ensuite possible d’associer la forme sémantique souhaitée pour la phrase “Jean court et rattrape Marie” : – sem =    np := es:= t cJean := λPe→t",".PJ c","Marie := λPe→t",".PM","crattrape := λx e","ye",".Rxy ccourt := λx e",".Cx","cet := λPe→t","1 Pe→t","2 x e",". ∧ (P1 x)(P2 x) Nous remarquerons néanmoins que, la signature des dérivations que nous décrivons ci-dessus est d’ordre supérieur à 2. Par ailleurs, il ne semble pas souhaitable, dans le cas des ACGs, de typer tous les syntagmes nominaux par un type (np → s) → s, ce qui revient à considérer des ACGs d’ordre supérieur à 2 pour des cas très simples, sans phénomènes d’ellipses. Enfin, l’opérateur de décomposition est nécessaire dans le cas d’ellipses verbales pour les langues de type SVO, car il permet d’extraire le verbe de la phrase en partie gauche de la conjonction. Cet opérateur permet en fait d’effectuer le même traitement que nous réalisons, c.a.d. de construire des constituants incomplets puis de les composer avec le constituant commun. Qui plus est, cet opérateur de décomposition semble poser un problème du point de vue calculatoire car il introduit deux nouvelles formules, ce qui va à l’encontre de la propriété de la sous-formule. Enfin, notons que les ACGs permettent l’implémentation du même principe de manière plus élégante puisque, de par l’indépendance entre dérivations et ordre des mots, nous n’avons pas eu besoin d’enrichir le formalisme initial de nouveaux opérateurs. Des extensions des TAGs ont également été proposées, tout d’abord dans (Sarkar et Joshi, 1996) qui proposent une implémentation des idées de (Steedman, 1990) dans les grammaires d’arbres adjoints, en y rajoutant une opération de conjonction. Par ailleurs, l’objectif des auteurs est de construire des structures dérivées qui sont des arbres avec partage de noeud. Qui plus est, ils rendent compte de ce partage de matériel syntaxique au niveau des dérivations, les structures de dérivation étant également des arbres avec partage de noeuds. Ceci est dû au fait que les structures de dérivation dans les TAGs sont censés être plus proches de la structure prédicat/argument de représentation sémantique d’une phrase. D’autres propositions sont celles de (Seddah, 2008) ou (Seddah et al., 2010), qui considèrent des grammaires de tuples d’arbres et requièrent des opérations plus complexes ; par exemple, le traitement d’ellipses multiples se fait en ajoutant un nombre arbitraire d’arbres non-lexicalisés (appelés “ghost trees” TALN-RÉCITAL 2013, 17-21 Juin, Les Sables d’Olonne 225 c⃝ ATALA par les auteurs). L’originalité de notre méthode, par rapport à celles-ci, est de pouvoir traiter les phénomènes d’ellipses que nous avons étudiés sans modifier le formalisme des grammaires catégorielles abstraites. Par ailleurs, le modèle de l’interface syntaxe sémantique dans les ACGs permet de séparer explicitement les structures de dérivation, de la représentation sémantique. Le partage d’information nécessaire au niveau des dérivations dans les TAGs, est donné au niveau de la signature Σsem dans notre cas. Enfin, (Kobele, 2007) décrit plusieurs méthodes possibles dont les deux suivantes : la première consiste à construire des contextes d’arbres, car du matériel syntaxique est absent aux emplacements où une ellipse a été réalisée ; l’information manquante doit alors être retrouvée dans l’arbre (dans le cas d’une ellipse verbale, dans le premier constituant dominé par une conjonction de coordination). La deuxième approche de (Kobele, 2007) consiste à utiliser des grammaires non-contextuelles d’arbres avec copie IO. Les deux approches que nous proposons semblent assez proches des propositions de Kobele, à la différence que, plutôt que de rechercher le matériel effacé dans l’arbre, nous mettons en place un mécanisme permettant de le copier. Par ailleurs, les ACGs de notre seconde approche peuvent être réduites à des grammaires IO-CFTGs. Bien que le patron de dérivation ne soit pas le même que celui utilisé par Kobele, il semblerait que nous ne puissions pas traiter plus de phénomènes que dans son approche. En particulier, Kobele montre qu’une des limites de l’approche par des IO-CFTGs est de ne pas pouvoir traiter des phénomènes tels que : (5). “John wants to climb Mt. Kilimanjaro and Mary to sail around the world, and while I","know that John will ε1 and Mary won’t ε2, Bill doesn’t ε3”","John veut grimper le Kilimanjaro et Marie naviguer autour du monde, et alors que je sais","que John le fera et pas Marie, Bill ne le sait pas D’après cette construction, il serait nécessaire de garder l’ensemble des verbes utilisés dans le constituant à gauche d’une conjonction afin de pouvoir le réutiliser dans les constituants en partie droite ; qui plus est, ce nombre de verbes est potentiellement infini, ce qui, dans notre première approche nous amène à considérer un nombre de constantes infinies cn","et, n ∈ ; dans notre seconde approche, il nous faudrait considérer un nombre de types infini dans la signature des dérivations. Ces cas d’ellipses mettent en avant la limite des traitements proposées. Par ailleurs, ce type d’ellipses paraît maladroit en Français, où les pronoms sont utilisés afin de se référer à un syntagme précédemment utilisé. Une solution à envisager est donc d’adapter des techniques de résolution d’anaphores, à partir de continuations dans le λ-calcul, par exemple (de Groote, 2006), afin de résoudre les phénomènes d’ellipse."]},{"title":"5 Conclusion","paragraphs":["Les phénomènes d’ellipses sont fréquents dans le langage naturel et sont des exemples de phénomènes non-linéaires au niveau de l’interface syntaxe-sémantique. Nous avons proposé deux approches pour le traitement d’ellipses sous coordination dans les ACGs, en utilisant le principe d’extraction pour la construction d’une phrase incomplète, suivi d’un mécanisme d’instanciation, modélisé par la substitution dans le λ-calcul. Dans la première approche, ce principe est directement codé au niveau des termes des structures de dérivation ; de manière élégante, nous pouvons alors traiter de nombreux cas d’ellipses, mais la signature des dérivations étant d’ordre supérieur à 2, le problème de l’analyse est, au meilleur des TALN-RÉCITAL 2013, 17-21 Juin, Les Sables d’Olonne 226 c⃝ ATALA cas, NP-complet. Dans la deuxième approche, nous conservons une ACG d’ordre 2, mais les mécanismes d’extraction sont encodés au niveau des types utilisés dans la signature. Ceci nous amène alors à considérer un ensemble de types très grand, mais nous permet de réutiliser des algorithmes d’analyse connus pour s’exécuter en temps polynomial. Les deux approches ainsi proposées ne nécessitent pas d’étendre le formalisme des ACGs, contrairement aux solutions proposées dans la littérature, pour les TAGs ou les CCGs. Néanmoins, les modélisations que nous proposons ne prétendent pas résoudre des phénomènes d’ellipses complexes, tels que les ellipses de verbes prenant différentes catégories en argument (dans “Jean est un républicain, et fier de l’être”), ou encore celles faisant intervenir un zeugma (dans “Napoléon a pris du poids et beaucoup de pays”, discuté dans (Seddah, 2008)). Dans ce dernier cas, une piste est de tenter de distinguer deux signatures des dérivations ΣDERIV−EXPR et ΣDERIV−STR contrôlant les dérivations de l’arbre syntaxique, la première s’assurant de la construction d’expressions figées. Par ailleurs, les modèles que nous proposons reposent essentiellement sur la présence d’une coordination dominant l’occurrence du syntagme effacé, et ne saurait résoudre des cas d’ellipses ou ce principe n’est pas vérifié. Enfin, et comme discuté dans (Kobele, 2007), les deux approches semblent trop limités afin de résoudre certains cas d’ellipses faisant intervenir de multiples verbes, et des méthodes de résolution d’anaphores pourrait se montrer plus efficaces. Finalement, cette étude demande à être approfondie afin d’étudier plus en détails le lien entre les deux propositions présentées. En particulier, il serait intéressant de savoir quand, et à quel coût, il est possible de diminuer l’ordre d’une ACG tout en préservant le langage généré. Remerciements : Je remercie les rapporteurs anonymes qui ont grandement aidé à l’amélioration de ce travail. Je tiens également à remercier Laura Kallmeyer et Timm Lichte pour les discussions qui m’ont amenées à m’intéresser à ce problème."]},{"title":"Références","paragraphs":["BOURREAU, P. (2011). Jeux de typage et analyse de λ-grammaires non-contextuelles. Thèse de doctorat, Laboratoire Bordelais d’Informatique. BOURREAU, P. et SALVATI, S. (2011). A Datalog recognizer for almost affine λ-CFGs. In (Kanazawa et al., 2011), pages 21–38. de GROOTE, P. (2001). Towards abstract categorial grammars. In Association for Computational Linguistics, 39th Annual Meeting and 10th Conference of the European Chapter, Proceedings of the Conference, pages 148–155. de GROOTE, P. (2002). Tree-adjoining grammar as abstract categorial grammar. In TAG+6, Proceedings of the sixth International Workshop on Tree Adjoining Grammars and Related Frameworks, pages 145–150. Università di Venezia. de GROOTE, P. (2006). Towards a montagovian account of dynamics. In Proceedings of Semantics and Linguistic Theory XVI. de GROOTE, P. et POGODALLA, S. (2004). On the expressive power of abstract categorial grammars : Representing context-free formalisms. Journal of Logic, Language and Information, 13(4):421–438. TALN-RÉCITAL 2013, 17-21 Juin, Les Sables d’Olonne 227 c⃝ ATALA HINDLEY, R. J. (1997). Basic Simple Type Theory. Cambridge Press University. JOSHI, A. K. (1985). Tree-adjoining grammars : How much context-sensitivity is required to provide reasonable strucutral descriptions ? Natural Language Parsing : Psychological, Computational and Theoretical Perspectives, pages 206–250. JOSHI, A. K., LEVY, L. S. et TAKAHASHI, M. (1975). Tree adjunct grammars. Journal of Comput. Syst. Sci., 10(1):136–163. KANAZAWA, M. (2007). Parsing and generation as Datalog queries. In Proceedings of the 45th Annual Meeting of the Association for Computational Linguistics, pages 176–183, Prague. Association for Computational Linguistics. KANAZAWA, M., KORNAI, A., KRACHT, M. et SEKI, H., éditeurs (2011). The Mathematics of Language - 12th Biennal Conference, MOL 12, Nara, Japan, September 2011. Proceedings, volume 6878 de Lecture Notes in Artificial Intelligence. Springer. KANAZAWA, M. et YOSHINAKA, R. (2005a). The complexity and generative capacity of lexicalised abstract categorial grammars. In (Kanazawa et al., 2011), pages 330–346. KANAZAWA, M. et YOSHINAKA, R. (2005b). Lexicalization of second-order ACGs. Rapport technique NII-2005-012E, NII, National Institute of Informatics, Tokyo. KOBELE, G. M. (2007). Parsing ellipsis. Unpublished Manuscript. LICHTE, T. et KALLMEYER, L. (2010). Gapping through TAG derivations. In Procedings of the 10th International Workshop on Tree-Adjoining Grammar and Related Formalisms. MUSKENS, R. (2001). Lambda Grammars and the Syntax-Semantics Interface. In van ROOY, R. et STOKHOF, M., éditeurs : Proceedings of the Thirteenth Amsterdam Colloquium, pages 150–155, Amsterdam. POGODALLA, S. (2004). Computing semantic representation : Towards ACG abstract terms as derivation trees. In Proceedings of the Seventh International Workshop on Tree Adjoining Grammar and Related Formalisms (TAG+7), pages 64–71. POGODALLA, S. (2007). Generalizing a proof-theoretic account of scope ambiguity. In proceedings of IWCS-7. SARKAR, A. et JOSHI, A. (1996). Coordination in tree adjoining grammars : formalization and implementation. In Proceedings of the 16th conference on Computational linguistics - Volume 2, COLING ’96, pages 610–615, Stroudsburg, PA, USA. Association for Computational Linguistics. SEDDAH, D. (2008). The use of MCTAG to process elliptic coordination. In Proceedings of the Ninth International Workshop on Tree Adjoining Grammars and Related Formalisms, TAG+9. SEDDAH, D., SAGOT, B. et DANLOS, L. (2010). Control verb, argument cluster coordination and multi component TAG. In Proceedings of the 10th International Conference on Tree Adjoining Grammars and Related Formalisms, TAG+10. STEEDMAN, M. (1987). Combinatory grammars and parasitic gaps. Natural Language & Linguistic Theory, 5:403–439. STEEDMAN, M. (1990). Gapping as constituent coordination. Linguistics and Philosophy, 13:207–264. YOSHINAKA, R. (2006). Linearization of affine abstract categorial grammars. In Proceedings of the 11th Conference on Formal Grammar, pages 185–199, Malaga, Spain. TALN-RÉCITAL 2013, 17-21 Juin, Les Sables d’Olonne 228 c⃝ ATALA"]}]}