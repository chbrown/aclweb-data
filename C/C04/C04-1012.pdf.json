{"sections":[{"title":"Restrictions on Monadic Context-Free Tree Grammars Akio Fujiyoshi Department of Computer and Information Sciences, Ibaraki University 4-12-1 Nakanarusawa, Hitachi, Ibaraki, 316-8511, Japan fujiyoshi@cis.ibaraki.ac.jp Abstract","paragraphs":["In this paper, subclasses of monadic context-free tree grammars (CFTGs) are compared. Since linear, nondeleting, monadic CFTGs generate the same class of string languages as tree adjoining grammars (TAGs), it is examined whether the restrictions of linearity and nondeletion on monadic CFTGs are necessary to generate the same class of languages. Epsilon-freeness on linear, nondeleting, monadic CFTG is also examined."]},{"title":"1 Introduction","paragraphs":["The context-free tree grammars (CFTGs) were in-troduced by W. C. Rounds (1970) as tree generating systems, the definition of which is a direct generalization of context-free grammars (CFGs) from strings to rooted, ordered, labeled trees. For the application of CFTGs to natural languages, many kinds of restrictions on CFTGs have been considered because the string languages generated by CFTGs are exactly indexed languages, whose emptiness problem and uniform membership problem are exponential time complete, i.e., nonrestricted CFTGs are formidable. One approach to define subclasses of CFTGs is to restrict the ranks of nonterminals. The rank of a nonterminal is a natural number assigned to each nonterminal by which the number of children of the node labeled by the nonterminal is fixed. Through this approach, the simplest model of CFTGs is regular tree grammars (RTGs) (Brainerd, 1969), where the ranks of nonterminals are all 0. The string languages generated by RTGs are the languages generated by context-free grammars (CFGs). Since recent research on natural languages has suggested that formalisms for natural languages need to generate a slightly larger class of languages than CFGs, this paper focuses on monadic CFTGs, where the ranks of nonterminals are either 0 or 1.","Another formalism of tree generating systems is tree adjoining grammars (TAGs) (Joshi et al., 1975; Joshi and Schabes, 1996; Abeillé and Rambow, 2000). TAGs have been widely studied relating them to natural languages, and it was shown that TAGs have the same generative power of string languages as other formalisms for natural languages developed independently such as head grammars, combinatory categorial grammars and linear indexed grammars (Vijay-Shanker and Weir, 1994). It is also noteworthy that there are recognition algorithms for the string languages generated by TAGs that run in O(n6",") and O(M (n2",")) time (Rajasekaran, 1996; Rajasekaran and Yooseph, 1998). From the view point of CFTG, the languages generated by TAGs were examined (Fujiyoshi and Kasai, 2000; Fujiyoshi, 2004; Möennich, 1997), and it was shown that linear, nondeleting, monadic CFTGs generate the same class of string languages as TAGs and a strictly larger class of tree languages than TAGs. Linearity is a restriction on CFTGs that requires the number of occurrences of every variable in the right-hand side of a rule be no more than 1, and nondeletion requires all variables in the left-hand side of a rule occur at least once in the right-hand side. In other words, linear, nondeleting, monadic CFTGs are those with nonterminals of rank 0 and 1 only and with exactly one occurrence of a variable in every right-hand side of a rule for a nonterminal of rank 1.","In this paper, the subclasses of monadic CFTGs are compared to examine whether the restrictions of linearity and nondeletion on monadic CFTGs are necessary to generate the same class of string languages as TAGs. It is shown that nondeletion is un-necessary since for any linear, monadic CFTG, there exists an equivalent linear, nondeleting, monadic CFTG. On the other hand, it is shown that linearity is necessary since there exists a non-linear, monadic CFTG which is not weakly equivalent to any linear, monadic CFTG.","For the development of parsing algorithm, the property of epsilon-freeness is very important, and in this paper, epsilon-freeness on linear, monadic CTFGs is also considered. Epsilon-freeness is a restriction on grammars that requires no use of epsilon-rules, that is, rules defined with the empty string. It is shown that for any linear, monadic CFTG, there exists an epsilon-free, linear, nondeleting, monadic CFTG that generate the same string language."]},{"title":"2 Preliminaries","paragraphs":["In this section, some terms, definitions and former results which will be used in the rest of this paper are introduced. 2.1 Ranked Alphabets, Trees and Substitution A ranked alphabet is a finiteset of symbols in which each symbol is associated with a natural number, called the rank of a symbol. Let be a ranked alphabet. For n 0, it is defined that n = fa 2 j the rank of a is ng.","The set T (trees over ) is the smallest set of strings over , parentheses and commas such that (1) 0 T and (2) if 1; 2; : : : ; n 2 T and a 2 n for some n 1, then a( 1; 2; : : : ; n) 2 T .","Let be the empty string. Let \" be the special symbol that may be contained in 0. The yield of a tree is a function from T into","defined as follows. For 2 T , (1) if = a 2 ( 0 f\"g), yield( ) = a, (1’) if = \", yield( ) = , and (2) if = a( 1; 2; : : : ; n) for some a 2 n and 1; 2; : : : ; n 2 T , yield( ) = yield( 1) yield( 2) yield( n).","Let X be the fixed countable set of variables x1; x2; : : :. It is definedthat X0 = ; and for n 1, Xn = fx1; x2; : : : ; xng. x1 is situationally denoted by x. T (Xn) is defined to be T [Xn taking the ranks of elements in X are all 0. For 2 T (Xn) and 1; 2; : : : ; n 2 T (X), [ 1; 2; : : : ; n] is definedto be the result of substituting each i (1 i n) for the occurences of the variable xi in .","A tree 2 T (Xn) is linear if no variable occurs more than once in , and nondeleting if all variables in Xn occur at least once in . The set of all linear trees and all nondeleting trees in T (Xn) are denoted by T (dXne) and T (bXnc), respectively.","In this papaer, the conventional way of illustrating trees is used. See Figure 1. The tree A(b(a); a; B(E; d)) is illustrated as (1). An arbitrary tree 2 T is illustrated as (2). When the variables of a tree 2 T (X3) occur in the order of x1; x2; x3; x1, the tree is illustrated as (3). 2.2 Context-Free Tree Grammars The context-free tree grammars (CFTGs) were in-troduced by W. C. Rounds (1970) as tree generating systems. The definition of CFTGs is a direct generalization of context-free grammars (CFGs). $ E D % (D G"]},{"title":"a b x","paragraphs":["1"]},{"title":"x","paragraphs":["2"]},{"title":"x","paragraphs":["3"]},{"title":"x","paragraphs":["1"]},{"title":"(1) (2) (3)","paragraphs":["Figure 1: Trees","A context-free tree grammar (CFTG) is a fourtuple G = (N; ; P; S), where: N and are disjoint ranked alphabets of non-","terminals and terminals, respectively. P is a finiteset of rules of the form A(x1; x2; : : : ; xn) ! with n 0, A 2 Nn and 2 TN[ (Xn). For A 2 N0, rules are written as A ! instead of A() ! .","S, the initial nonterminal, is a distinguished symbol in N0. For a CFTG G, the one-step derivation","G) is","the relation on TN[ TN[ such that for a tree","2 TN[ , if = 0","[A( 1; 2; : : : ; n)] for some","0 2 T","N[ (dX1e) \\ TN[ (bX1c), A 2 Nn and 1; 2; : : : ; n 2 TN[ , and A(x1; x2; : : : ; xn) ! is in P , then","G) 0 [ [","1; 2; : : : ; n]]. Figure 2","is an example of a one-step derivation where the rule","A(x) ! is applied to the tree = 0","[A( 00",")] and","the tree 0","[ [ 00","]] is obtained. An (n-step) derivation is a finite sequence of","trees 0; 1; : : : ; n 2 TN[ such that n 0 and","0 G) 1 G) G) n. When there exists a derivation 0; 1; : : : ; n, it is writen that 0 Gn ) n or 0 G ) n. The tree language generated by G is the set","L(G) = f 2 T j S G ) g. The string language generated by G is LS(G) = fyield( ) j 2 L(G)g. Note that LS(G) ( 0 f\"g)","."]},{"title":"a","paragraphs":["• $"]},{"title":"a","paragraphs":["•• "]},{"title":"a","paragraphs":["•"]},{"title":"a","paragraphs":["••"]},{"title":"a","paragraphs":["••"]},{"title":"b b x x","paragraphs":["$ *"]},{"title":"x","paragraphs":["Figure 2: One-step derivation","Let G and G0 be CFTGs. G and G0","are equivalent","if L(G) = L(G0 ). G and G0","are weakly equivalent if","LS(G) = LS(G0 ). 2.3 Restrictions on CFTGs A CFTG G = (N; ; P; S) is monadic if the rank of any nonterminal is 0 or 1, i.e., N = N0 [ N1 and Nn = ; for n 2. G is linear if for any rule A(x1; x2; : : : ; xn) ! in P , 2 TN[ (dXne), and nondeleting if for any rule A(x1; x2; : : : ; xn) ! in P , 2 TN[ (bXnc).","A CFTG G = (N; ; P; S) is epsilon-free if for any rule A(x1; x2; : : : ; xn) ! in P , the symbol \" doesn’t occur in .","When G is monadic, all rules are either of the form A(x) ! with A 2 N1 and 2 TN[ (X1) or of the form B ! with B 2 N0 and 2 TN[ . When G is monadic, linear and nondeleting, for any rule A(x) ! with A 2 N1 in P , there exists exactly one occurrence of x in .","For linear, nondeleting, monadic CFTGs, the following results are known. Theorem 2.1 (Fujiyoshi and Kasai, 2000) The class of string languages generated by linear, nondeleting, monadic CFTGs coincides with the class of string languages generated by TAGs. Theorem 2.2 (Fujiyoshi and Kasai, 2000) For any linear, nondeleting, monadic CFTG, there exists a weakly equivalent linear, nondeleting, monadic CFTG G = (N; ; P; S) that satisfiesthe following conditions: For any a 2 , the rank of a is either 0 or 2. For each A 2 N0, if A ! is in P , then either = a with a 2 0, or = B(C) with B 2 N1 and C 2 N0. See (1) and (2) in Figure 3. $ D $ % & $"]},{"title":"x","paragraphs":["$"]},{"title":"x","paragraphs":["% &"]},{"title":"x","paragraphs":["$"]},{"title":"x","paragraphs":["E"]},{"title":"x","paragraphs":["& E"]},{"title":"x","paragraphs":["&"]},{"title":"(1) (2) (3) (4) (5)","paragraphs":["Figure 3: Strong normal form","For each A 2 N1, if A(x) ! is in P , then is one of the following forms: = B(C(x)) with B; C 2 N1, = b(C; x) with b 2 2 and C 2 N0, or = b(x; C) with b 2 2 and C 2 N0. See (3),(4) and (5) in Figure 3. If a linear, nondeleting, monadic CFTG satisfiesthe condition of Theorem 2.2, it is said that the grammar is in strong normal form1","."]},{"title":"3 Linearity and Nondeletion on Monadic CFTGs","paragraphs":["Because linear, nondeleting, monadic CFTGs generate the same class of string languages as TAGs, the question is whether the restrictions of linearity and nondeletion on monadic CFTGs are necessary to generate the same class of languages. First, it will be shown that nondeletion is unnecessary. Theorem 3.1 For any linear, monadic CFTG G, there exists an equivalent linear, nondeleting, monadic CFTG G0",".","Proof. Let G = (N; ; P; S) be a linear, monadic","CFTG. An equivalent linear, nondeleting, monadic","CFTG G0 = (N 0","; ; P 0","; S) can be constructed as","follows.","The set of nonterminal is N 0","= N 0","0 [ N 0","1 such","that N 0","0 = N0 [ fA j A 2 N1g and N 0","1 = N1.","For the preparation of the definition of P 0",", for 2","TN[ (X1) we define ( ) TN′","[ (X1) as the","smallest set satisfying the following conditions: 2 ( )D 1 We say “strong” because a grammar in this normal form","only preserves weak equivalence. "]},{"title":"x","paragraphs":["*•"]},{"title":"P d * b (1) a","paragraphs":["•"]},{"title":"a","paragraphs":["•"]},{"title":"g x d","paragraphs":["•"]},{"title":"gP","paragraphs":["*•"]},{"title":"* b (2) ̂ a","paragraphs":["•"]},{"title":"g d","paragraphs":["•"]},{"title":"gP ","paragraphs":["*•"]},{"title":"* b (3) ̂ a","paragraphs":["••"]},{"title":"d","paragraphs":["•• Figure 4: The three different cases","If 2 ( ) and = 0","[B( 00",")] for some B 2","N1, 0 2 T","N′ [ (dX1e) \\ TN′","[ (bX1c) and","00 2 T","N′ [ , then 0","[ B ] 2 ( ). The set of rules is definedas follows.","P 0 = fA ! ̂j A 2 N 0, A ! 2 P , ̂2 ( )g","[ fA(x) ! ̂j A 2 N1, A(x) ! 2 P , ̂2 ( ) \\ TN′","[ (bX1c)g","[ fA ! ̂j A 2 N1, A(x) ! 2 P ,","̂2 ( ) \\ TN′","[ g Because of the construction of N 0","and P 0",", G0","is monadic and nondeleting. To show the equivalence of G and G0",", we prove the following statement holds for any 2 TN[ and 2 T by induction on the length of derivations:  G ) if and only if there exitsts ̂2 ( ) such that ^ G′ ) . We start with proving “on ly-if” part. Let Gk ) . If k = 0, then clearly = , 2 ( ) and ","G′",") . For k 1, assume that the statement holds for any derivation of length less than k. If a rule of the form A ! with A 2 N0 is used at the first step, the proof is rather simple, so we only prove the other case. Suppose that a rule A(x) ! with A 2 N1 is used at the first step and = 0","[A( 00",")]","G) 0 [ [ 00","]] G ) for","some 0 2 T","N[ (dX1e) \\ TN[ (bX1c) and 00","2","TN[ . By the induction hypothesis, there exist","2 ( 0","[ [ 00","]]) such that G′ ) . Here, we have to","think of the three different cases: (1) 2 ( 0","), (2)","can be written as 0","[̂] for some 0","2 ( 0",") and","̂2 ( ), and (3) can be written as 0","[̂[ 00","]] for","some 0","2 ( 0","), ̂2 ( ) and 00","2 ( 00","). See","Figure 4. In the case (1), 2 ( ) and","G′",") .","In the case (2), A ! ̂is in P 0","and therefore,","0","[ A ] 2 ( ) and 0 [ A ]","G′) 0 [̂]","G′",") . And in","the case (3), A(x) ! ̂is in P 0","and therefore,","0","[A( 00",")] 2 ( ) and 0 [A( 00",")]","G′) 0 [̂[ 00","]] G′ ) . The “if ” part is proved as follows. Let ^ G′k ) for some ̂2 ( ). If k = 0, then clearly ̂= , = ̂and","G",") . For k 1, assume that the statement holds for any derivation of length less than k. The rule used at the first step is one of the following forms: (1) A ! ̂with A 2 N0, (2) A(x) ! ̂with A 2 N1, or (3) A ! ̂with A 2 N 0","0 N0. The proof of the case (1) is similar to the proofs of the other cases, so we start proving the case (2). In the case (2), ̂= ̂0","[A( ̂00",")]","G′) ̂0 [̂[ ̂00","]] G′ ) for some ̂0","2","TN′","[ (dX1e) \\ TN′","[ (bX1c) and ̂00","2 T","N′","[ . By","the definition of P 0 , A(x) ! is in P such that","̂2 ( ). By the induction hypothesis, for any","2 TN[ such that ̂0 [̂[ ̂00","]] 2 ( ), G ) . By","the definition of , there exists 0 2 T N[ (X1) and","00 2 T","N[ such that = 0 [A( 00",")]","G) 0","[ [ 00","]],","and ̂0","[̂[ ̂00","]] 2 ( 0","[ [ 00","]]). Therefore, G ) .","And in the case (3), ̂= ̂0 [ A ]","G′) ̂0 [̂] G′ )","for some ̂0 2 T N′ [ (dX1e) \\ TN′","[ (bX1c). By","the definition of P 0 , A(x) ! is in P such that","̂2 ( ). By the induction hypothesis, for any","2 TN[ such that ̂0","[̂] 2 ( ), G ) . By the","definition of , there exists 0 2 T N[ (X1) and","00 2 T","N[ such that = 0 [A( 00",")]","G) 0","[ [ 00","]],","and ̂0","[̂] 2 ( 0","[ [ 00 ]]). Therefore, G ) .","Because ( S) = fSg, L(G) = L(G0 ).","Next, consideration will be given to whether the restriction of linearity can be removed from monadic CFTGs to generate the same class of languages. The answer is negative. The following example is a non-linear, monadic CFTG that generates a string language that no linear, monadic CFTG can generate. Example 3.2 The following is an example of a monadic CFTG that generates the string language Lw4 = fwwww j w 2 fa; bg+","g. G = (N; ; P; S) where N = fS; Ag, the ranks of S and A are 0 and 1, respectively, = fa; b; c; dg, the ranks of a, b, c and d are 0, 0, 2 and 4, respectively, and P consists of the following rules: S ! A(a), S ! A(b), A(x) ! d(xxxx), A(x) ! A(c(xa)), and A(x) ! A(c(xb)). Because G has the rule A(x) ! d(xxxx), G is not linear. Theorem 3.3 There exists a monadic CFTG which is not weakly equivalent to any linear, monadic CFTG. Proof. It is known that the string language Lw4 in Example 3.2 cannot be generated by any TAG. It cannot be generated by any linear, monadic CFTG, neither."]},{"title":"4 Epsilon-Freeness on Linear, Monadic CFTGs","paragraphs":["According to our definition of CFTGs, they are allowed to generate trees with the special symbol \", which is treated as the empty string while taking the yields of trees. In this section, it will be seen that for any linear, monadic CFTG, there exists a weakly equivalent epsilon-free, linear, nondeleting, monadic CFTG. Because any epsilon-free CFTG cannot generate a tree with \", it is clear that for a CFTG with epsilon-rules, there generally doesn’t exist an equivalent epsilon-free CFTG. Theorem 4.1 For any linear, monadic CFTG G = (N; ; P; S), if 62 LS(G), then there exists a weakly equivalent epsilon-free, linear, nondeleting, monadic CFTG G0",". If 2 L","S(G), then there exists","G0 whose epsilon-rule is only S ! \". Proof. Since it is enough to show the existence of a weakly equivalent grammar, without loss of generality, we may assume that G is in strong normal form. We may also assume that the initial nonterminal S doesn’t appear in the right-hand side of any rule in P .","We firstconstruct subsets of nonterminals E0 and E1 as follows. For initial values, we set E0 = fA 2 N0jA ! \" 2 P g and E1 = ;. We repeat the following operations to E0 and E1 until no more operations are possible:","If A ! B(C) with B 2 E1 and C 2 E0 is in P , then add A 2 N0 to E0.","If A(x) ! b(C; x) with C 2 E0 is in P , then add A 2 N1 to E1.","If A(x) ! b(x; C) with C 2 E0 is in P , then add A 2 N1 to E1.","If A(x) ! B(C(x)) with B; C 2 E1 is in P , then add A 2 N1 to E1. In the result, E0 satisfiesthe following. E0 = fA 2 N0j9 2 T ; A G ) ; yield( ) = g","We construct G0","= (N 0","; 0 ; P 0","; S) as follows.","The set of nonterminals is N 0 = N 0","0 [ N 0","1 such that N 0 0 = N0 [ fAjA 2 N1g and N 0","1 = N1. The set of terminal is 0","= [ fcg, where c is a new symbol of rank 1. The set of rules P 0","is the smallest set satisfying following conditions:","P 0","contains all rules in P except rules of the form A ! \".","If S 2 E0, then S ! \" is in P 0",".","If A ! B(C) is in P and C 2 E0, then A ! B is in P 0",".","If A(x) ! B(C(x)) is in P , then A ! B( C ) is in P 0",".","If A(x) ! b(C; x) or A(x) ! b(x; C) is in P and C 2 E0, then A(x) ! c(x) is in P 0",".","If A(x) ! b(C; x) or A(x) ! b(x; C) is in P , then A ! c(C) is in P 0",".","To show LS(G0 ) = L","S(G), we prove the following (i), (ii) and (iii) hold by induction on the length of derivations: (i) For A 2 N0, A","G′",") 0","and 0","2 T if and only if A G ) for some 2 T such that","yield( ) = yield( 0",") 6= . (ii) For A 2 N1, A(x)","G′",") 0","and 0","2 T (X1) if and only A(x) G ) for some 2 T (X1)","such that yield( ) = yield( 0",").","(iii) For A 2 N 0 0 N0, A","G′",") 0","and 0","2 T if and only if A(x) G ) for some 2 T (X1) such","that yield( [\"]) = yield( 0",") 6= . We start with “onl y if” part. For 0-step derivations, (i), (ii) and (iii) clearly hold since there doesn’t exists 0","2 T","nor 0 2 T (X1) for each statement.","We consider the cases for 1-step derivations. [Proof of (i)] If A","G′) 0 and 0","2 T , then 0","= a","for some a 2 0 and the rule A ! a in P 0","has been","used. Therefore, A ! a is in P and A G) a. [Proof of (ii)] If A(x)","G′) 0 and 0","2 T","(X1), then 0","= c(x) and the rule A(x) ! c(x) in P 0","has been used. By the definition of P 0",", A(x) ! b(C; x) or A(x) ! b(x; C) is in P for some C 2 E0. There exists 2 T such that C G ) and yield( ) = . Therefore, A(x) G) b(C; x) G ) b( ; x) or A(x) G) b(x; C) G ) b(x; ), and yield(b( ; x)) = yield(b(x; )) = yield(c(x)). [Proof of (iii)] There doesn’t exists 0","2 T such that A","G′) 0",".","For k 2, assume that (i), (ii) and (iii) holds for","any derivation of length less than k. [Proof of (i)] If A","G′k",") 0",", then the rule used at","the first step is one of the follwoing form: (1)","A ! B(C) or (2) A ! B. In the case","(1), A G′) B(C)","G′",") 0","[ 0","] = 0","for some 0","2","T (X1) and 0","2 T such that B(x) G′ ) 0","and C G′ ) 0",". By the induction hypothesis of (ii), there exists 2 T (X1) such that B(x)","G",") and","yield( ) = yield( 0 ). By the induction hypoth-","esis of (i), there exists 2 T such that C","G",")","and yield( ) = yield( 0","). By the definition of P 0",",","A ! B(C) is in P . Therefore, A G) B(C)","G",") [ ]","and yield( [ ]) = yield( 0 [ 0 ]). In the case (2),","A G′) B G′ ) 0",". By the definition of P 0",", A ! B(C)","is in P for some C 2 E0. There exists 2 T such","that C G ) and yield( ) = . By the induction hypothesis of (iii), there exists 2 T (X1) such that B(x) G ) and yield( [\"]) = yield( 0","). Therefore, A G) B(C) G ) [ ] and yield( [ ]) = yield( 0","). [Proof of (ii)] If A(x)","G′k",") 0",", then the rule used at the first step is one of the follwoing form: (1) A(x) ! B(C(x)), (2) A(x) ! b(C; x) or (3) A(x) ! b(x; C). Becasue these rule are in P , the proofs are direct from the induction hypothesis like the proof of the case (1) of (i). [Proof of (iii)] If A G′k ) 0",", then the rule used at","the first step is one of the follwoing form: (1)","A ! B(C) or (2) A ! c(C). In the case (1), A G′) B(C)","G′",") 0 [ 0 ] = 0","for some 0","2 T (X1)","and 0 2 T such that B(x) G′ ) 0","and C G′ ) 0",".","By the induction hypothesis of (ii), there exists","2 T (X1) such that B(x)","G",") and yield( ) =","yield( 0 ). By the induction hypothesis of (iii),","there exists 2 T (X1) such that C(x)","G",")","and yield( [\"]) = yield( 0","). By the definition","of P 0 , A(x) ! B(C(x)) is in P . Therefore,","A(x) G) B(C(x))","G",") [ ] and yield( [ [\"]]) =","yield( 0","[ 0 ]). In the case (2), A G′) c(C) G′ ) c( 0",") =","0 for some 0","2 T such that C G′ ) 0",". By the in-","duction hypothesis of (i), there exists 2 T such","that C","G",") and yield( ) = yield( 0","). By the def-","inition of P 0",", A(x) ! b(C; x) or A(x) ! b(x; C)","is in P . Without loss of generality, we may as-","sume that A(x) ! b(C; x) is in P . Therefore,","A(x) G) b(C; x) G ) b( ; x) and yield(b( ; x)[\"]) = yield(c( 0",")).","The “if ” part is similarly proved as follows. For 0-step derivations, (i), (ii) and (iii) clearly hold since there doesn’t exists 2 T nor 2 T (X1) for each statement.","The cases for 1-step derivations are proved. [Proof of (i)] If A","G) and 2 T , then = a","for some a 2 0 and the rule A ! a in P has been","used. Therefore, A ! a is in P 0","and A","G′) a. [Proof of (ii) and (iii)] There doesn’t exists 2 T such that A G) .","For k 2, assume that (i), (ii) and (iii) holds for any derivation of length less than k. [Proof of (i)] If A Gk ) , then the rule used at the first step must be of the form A ! B(C). Thus, A G) B(C) G ) [ ] = for some 2 T (X1) and 2 T such that B(x) G ) and C","G",") . Here, we have to think of the two cases: (1) yield( ) 6= and (2) yield( ) = . In the case (1), by the induction hypothesis of (ii), there exists 0","2 T (X1) such that B(x)","G′",") 0","and","yield( 0",") = yield( ), and by the induction hypothe-","sis of (i), there exists 0 2 T such that C G′ ) 0","and","yield( 0",") = yield( ). By the definition of P 0",", A !","B(C) is in P . Therefore, A G′) B(C)","G",") 0","[ 0","]","and yield( 0","[ 0","]) = yield( [ ]). In the case (2),","C 2 E0. Thus, A ! B is in P 0 . By the induction","hypothesis of (iii), there exists 0","2 T (X1) such that B","G",") 0","and yield( 0",") = yield( [\"]). There-fore, A G′) B","G′",") 0","and yield( 0",") = yield( [ ]). [Proof of (ii)] If A(x)","Gk",") , then the rule used at the first step is one of the follwoing form: (1) A(x) ! B(C(x)), (2) A(x) ! b(C; x) or (3) A(x) ! b(x; C). The proof of the case (1) is direct from the induction hypothesis. In the case (2), A(x) G) b(C; x) G ) b( ; x) = for some 2 T such that C G ) . Here, we have to think of the two cases: (a) yield( ) 6= and (b) yield( ) = . (a) If yield( ) 6= , then by the induction hypothesis of (i), there exists 0","2 T such that C","G′",") 0","and yield( 0",") = yield( ). By the defini-","tion of P 0",", A(x) ! b(C; x) is in P 0",". Therefore,","A(x) G′) b(C; x)","G′",") b( 0","; x) and yield(b( 0","; x)) = yield(b( ; x)). (b) If yield( ) = , then C 2 E0 and A(x) ! c(x) is in P 0",". Therefore, A(x)","G′) c(x) and yield(c(x)) = yield(b( ; x)). The proof of the case (3) is similar to that of the case (2). [Proof of (iii)] If A(x)","Gk",") , then the rule used at the first step is one of the follwoing form: (1) A(x) ! B(C(x)), (2) A(x) ! b(C; x) or (3) A(x) ! b(x; C). In the case (1), A(x) G) B(C(x)) G ) [ ] = for some ; 2 T (X1) such that B(x) G ) and C(x)","G",") . By","the definition of P 0",", A ! B(C) is in P 0",". By","the induction hypothesis of (ii), there exists 0","2","T (X1) such that B(x)","G′",") 0","and yield( 0",") = yield( ). By the induction hypothesis of (iii), there exists 0","2 T such that C","G′",") 0","and yield( 0",") = yield( [\"]). Therefore, A G′) B(C)","G′",") 0","[ 0","] and","yield( 0","[ 0","]) = yield( [ [\"]]). In the case (2),","A(x) G) b(C; x) G ) b( ; x) = for some 2 T such that C G ) and yield( ) 6= . By","the definition of P 0",", A ! c(C) is in P 0",". By","the induction hypothesis of (i), there exists 0","2","T such that C","G′",") 0","and yield( 0",") = yield( ). Therefore, A G′) c(C)","G′",") c( 0",") and yield(c( 0",")) = yield(b( ; x)[\"]). The proof of the case (3) is similar to that of the case (2). By (i), we have the result LS(G0",") = L S(G)."]},{"title":"5 Conclusions","paragraphs":["In this paper, the desirable features of linear monadic CFTGs have been discovered: the restriction of nondeletion doesn’t affect their generative power of tree languages, and the restriction of epsilon-freeness can be assumed when their generation of string languages is considered. The key to the proofs of this paper was the simplicity of the definition of linear, monadic CFTGs and their normal form.","Recently, the class of grammars called mildly context-sensitive grammars has been studied very actively, to which TAGs and other well-established formalisms for natural languages belong. Since it is not difficult to study formal properties of linear, monadic CFTGs, they are helpful tools for the study of mildly context-sensitive grammars."]},{"title":"References","paragraphs":["Anne Abeillé and Owen Rambow, editors. 2000. Tree adjoining grammars: formalisms, linguistic analysis and processing. CSLI Publications, Stanford, California.","Walter S. Brainerd. 1969. Tree generating regular systems. Information & Control, 14(2):217–231.","Akio Fujiyoshi and Takumi Kasai. 2000. Spinalformed context-free tree grammars. Theory of Computing Systems, 33(1):59–83.","Akio Fujiyoshi. 2004. Epsilon-free grammars and lexicalized grammars that generate the class of the mildly context-sensitive languages. In 7th In-ternational Workshop on Tree Adjoining Grammar and Related Formalisms: Proceedings of the Workshop, Vancouver, pages 16–23.","Aravind K. Joshi and Yves Schabes, 1996. Handbook of Formal Languages, volume 3, chapter Tree-adjoining grammars, pages 69–124. Springer, Berlin.","Aravind K. Joshi, Leon S. Levy, and Masako Takahashi. 1975. Tree adjunct grammars. J. Computer & System Sciences, 10(1):136–163.","Uwe Möennich. 1997. Adjunction as substitution: an algebraic formulation of regular, context-free and tree adjoining languages. In G. V. Morrill G-J. Kruijff and R. T. Oehrle, editors, Formal Grammars 1997: Proceedings of the Conference, Aixen-Provence, pages 169–178.","Sanguthevar Rajasekaran and Shibu Yooseph. 1998. TAL recognition in O(M (n2",")) time. J. Computer & System Sciences, 56(1):83–89.","Sanguthevar Rajasekaran. 1996. Tree-adjoining language parsing in O(n6",") time. SIAM J. Comput., 25(4):862–873.","William C. Rounds. 1970. Mapping and grammars on trees. Mathematical Systems Theory, 4(3):257–287.","K. Vijay-Shanker and David J. Weir. 1994. The equivalence of four extensions of context-free grammars. Mathematical Systems Theory, 27(6):511–546."]}]}