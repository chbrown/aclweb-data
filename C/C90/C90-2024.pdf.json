{"sections":[{"title":"Contribution of a Category Hierarchy to the Robustness of Syntactic Parsing. Damien GENTHIAI~, Jacques COURTIN, lr6ne KOWARSKI Laboratoire de g6nie informatique ° lmag Campus ° BP53X F-38041 GRENOBLE CEDEX - France","paragraphs":["T61 : 76 51 48 78 E-Mail :"]},{"title":"courti.@imag.imag.fr courtin@imag.UUCP Abstrad","paragraphs":["We describe how the use o1' at hierarchy of lexical categories instead of a simple set of categories leads to the definition of a flexible and precise language for the description of dependency structures. After specifying the t'ormalism we use to decorate these structures, we present an application aiming to detect and correct en'ors in a written text. We outline how tile use of the hierarchy irnproves the manii)ulation of unknown words."]},{"title":"]i. it - troduction","paragraphs":["The work presented in this paper is part of a nat)re general project which aims towards a complete system for detection and corrcctio~ of errors i~ a written text. Our interes~ here is tit(: creation of a syritactic--semantic module which builds depenttency structures decorated with attribute.-pairs lists integrating a mechanism for the inheritance of properties. We show the contribtltion of hierarchisation of lexical categories to the constructi(m of syntactical structures."]},{"title":"2. Construction of dependency structures","paragraphs":["Dependency structures are trees which give a description of the structure of a sentence by establishing direct links be|wcen the words (or lexical items : the terminal symbols according lo constituent grammars). The idea is that the structure of a phrase can be thought of as a particular word (the head or governor) modified by' the other words (the modifiers or dependents). Dependents can themselves be modified to produce a tree strucure : the governor as root and dependents as his sons. Complex intormation (e.g. syntactic functions or semantic relationships) can easily be added on the links of such trees and rules of agreement are conveniently expressed. For example, in French, the agreement in gender and number betweeen a noun and its determiner and adjectives implies the same gender and number for both the dependents (determiner and adjectives) and their governor (noun). On the other hand, it is difficult to express ptn'ase properties on dependency structures, because the properties of a phrase governed by a word at(: not necessarily limited to the properties of the word alone. In order to describe such structures, we write binmy relations in \"governor-dependent\" form. The formalism proposed by Tesni~.res [120] (dependermy grammars) is very precisE, but all possible arrangements of the dependents of a governor must be described. In Courtin's work [8], weighted dependency relations are defined, which are well suited to computation, but limited in power of expression. We have attempted to design a language for the description of dependency structures retaining the precision of grammars, but more appropriate for automatic treatment. To build these structures, we must be able to determine, for any two words, caracterized by their lexical category : det, noun, verb ..... which one governs tile other. More generally, given two dependency trees, we must know how to merge them into a unique tree. t!~,xample : 1 s, eL det adj We have defined a language based on rewriting rules ; each rule applies to a dependency forest and produces a dependency tree. A set of such |Examples given are simple English adaptations of tile French originals 139 rules constitutes a dependency grammar, which can be applied to a sentence by means of an interpreter. This interpreter can be viewed as a u'ee-transducer. Example of a simple rule : (the \"--\" begins comments) N V [ -- Name (~:{N}, (0, SF:{P})2:{V}) -- Forest => ( ( i, SF ) 2 ) --Resulting tree ] This rule applies to any forest which includes a sequence of an N and a V, whose left dependents are only preverbal particles P. It builds a new tree where the N is added as a dependent of the v. The advantage of these rules, compared to simple binary relations, is that it is possible to express the context of each category which appears. It is thus possible to restrict a governor to one or two dependents only, or to forbid more than one occurrence of a given category .... One can also define linked pairs of binary relations, as for coordination conjunctions: N coon [ (T '","\"\"~ :{N}, ~:~coco}, ~:t_, ~) :> { ( 1 ) 2 3)) ] On the other hand, they present the drawback of the primitive dependency grammars : there nmst be a rule for almost every pair of lexical categories (LC). To avoid this problem, we have chosen to use a hierarchy of LCs instead of the usual linear set of LCs. This hierarchy is a set, partially ordered by the ±s-a relation (Figure 1). CLS N \\/ A enoun xbe xhave verb pastp adj Figure 1 • Example of hierarchy We can, in this manner, express very general rules like the two given above (N V and N coco) or more specific ones like ' a u x_pp a s [ (l:{xbe ; xhave}, 2:{pastp ) => ((1)2) ] Thanks to i.s-a ( { cnoun, pnoun }, N) and is-a ( {xbe, xhave, verb, pastp } , V) relations, the N_V rule for instance rnay be applied to all the following pairs of categories : (cnoun, xbe) (pnoun, xbe) (cnoun, xhave) (pnoun, xhave) (cnoun, verb) (pnoun, verb) (cnoun, pastp) (pnoun, pastp) We can thus define a set of basic categories which describe words in a very specific way, and use these categories for lexical indexing. The categories can then be grouped in \"meta-categories\" according to the structures we want to build. Finally, we can write the rules which effectively build these structures. By using this method, we can avoid the usual compromise between a very fine set of LCs (which multiplies morphological ambiguities and syntactic rules ) and a very general set (which multiplies syntactic ambiguities). We also obtain a fairly robust syntactic parsing : all unknown words are given the most general category (CLS), to which any rule carl apply (see §4). Similar type hierarchies have already been used in work on language semantics to represent the taxonomy of semantic types. We shall therefore use the same formalism for the representation of syntactic and semm]tic knowledge."]},{"title":"3. Type hierarchies and 'e-terms","paragraphs":["We have chosen to represent knowledge about words and trees with a unique formalism ' q'- terms [2]. q'-terms are case frame structures which permit the description of types (in the sense of classical programming languages such as Pascal), i.e. sets of values. ~-terrns are directed graphs (Figure 2) in which nodes are symbols associated to fundamental types (simple types) and arcs are labelled with attribute symbols. Each node of the graph includes a reference tag which can be used to designate it, thus allowing information to be shared. Simple types are defined in the signature which is a set partially ordered by the is-a relation. This order is extended to q'-terms by the unique operation used to manipulate them : unification [1, 2]. The unification of two simple types is 140 2 defined as the set of lower bounds of these two types; (in the 2 s - a relation).","Ser[i # sere pat. ient","Linear R.°m :","\"tJL (J.@X --> \"e&tS\"; cdt7 > ve zl~' ; subj ~:> Uh(sem ':> S:ANIMATE) ; obj ,:> UL (so;a : > O:Y.A'2AB'. I;;) ; sere :=> £NGggT(agent: :> g;","pat:Jent > O) ) Figure 2 • Example of %l:crm UHification allows implicit irwheritancc of properties, and can be ¢iTiciently implemented"]},{"title":"I31.","paragraphs":["Exmnple of unification •","The two tlJoterms \"","Uf,(i_ex :> \"dr)g\"; CaL : > cr~our%; nbr -.> sin; gnu: > re<is; sere -,:> CA~iqi N:<)","UL(cat : > ,L; sere ::> ANIMATP:) unify as\"","UL(ieN : > \"d<)g\"; C~]L -:> CrlOtID; 9~r > mas ; nbr > sin; sere :> CANINE) under the condition that the associated signature unifies CANINE and ANIMATE as CAN I NE. We can del'ine a sel-senmntics on simple types [1, 191] ; this semantics can be extended to 't'- terms giving the following interpretation of unification : if Pl and P2 are two T-terms describing respectively two sets el and e2 of values, then unification of two q'-terms L](pl, P2) describes the set elne2 . To transduction rules we have added expressions which enable us to test and modify 'v-terms attached to the trees we are manipulating. We can thus simultaneously build a syntactic structure (dependency tree) and a semantic structure (f-term, which also contains morphological and syntactical information). Example of rules ~md application ' We have two words • UL (•~e>: ::'~- \"co g~\";","C&t ::7 (;~l{;,~J~5i ;","sere => CANINE) rTT =:> It{ . ~ c. 11 • ,.:• ( ] ~:< ..~ct, .~- ;","\".:at. : > v~.~b; UL(sem ::> ~,c':AN2MATI:) ;","ob I => UL {s.em ::=> O:]~ATAJ~L}L) ;","seiI'L =:> 1 ~':f']'°~''~,o.',,.0 L (=~ge?/C. =:> S;","]{:)~.t ient ::> O) ) and lhe rule \" s'cbj(-ct:. [ (]. : {N}, 2: 4V}) /',;:~:i. ~: I, 2 sub)) ~' ~ ~ .... • . \" ,.. O[i(._,_ L",".1 (9,~.:: 2> ( ( i 2 ) ; ..... '\" c;bi . . \" ..... z~o.:~; (2 sub ], i , Act :ions J The root of the resulting tree is decorated by ° U[, ( I(',\",1 :> \"C'~[L~\";","<:t&L :> L' @ E]:) ;","sui:; ] ::> UL(Iox .... > ,,Hr~,,. t~ll<; <x** j","sere --:> ,~ ~':CANINE;) ;","ob ::> UL(sem => O:EATABLE) ;","sere => ]:NGEST (agorzt => f_;;","oaLJeri!; ::> O) )"]},{"title":"4. Applticafio as : a robus parser of French and syamcticait vcril[ica o","paragraphs":["We have implemented on a microcomputer a prototype of the dependency-tree transducer. This prototype is integrated in a system for detection and correction of errors in a written text as a syntactic filter (Figure 3) o The prototype uses an algorithm for the application of rules adapted to syntactic.- semantic parsing • the text is pmsed from left to right ; each time a word is recognized by the morphological parser, it is transmitted to the syntactic module which includes it in the 141 3 current state of the analysis. This state is represented by a list of dependency forests to which the transducer tries to attach the new word, according to the rules. Sentence (Text) Morphol. Parsing I","Unknown words"]},{"title":"E1","paragraphs":["Hypothesis Generator Correct words Hypotheses","~yn~actic F i it e r"]},{"title":"I","paragraphs":["~J","Syntact ico-semantic structures Figure 3 : Architecture If part of the entry string is not recognized, it is passed on to the hypothesis-generator which attempts to correct it by means of three techniques (skeleton key [1611, phonetics [9], and morphological generation [7]). The hypotheses are then passed on to the syntactic module which handles them exactly in the same way as morphological ambiguities. It must be noted that the three modules can function almost simultaneously (pipe-line) and that the hypothesis-generator always transmits something to the syntactic module. If a word is so ill-formed as to render its correction impossible, tile hierarchical structure of categories can be used to transmit the most general possible word, i.e. • UL (cat :> CLS). Any rule can apply to CLS (which is tile most general category), so the choice of the rule to be applied i,; determined only by the context of the unknown word, and this rule will in turn determine which category the word should have had. Example\" With a forest such as • ( l:{cnoun}, 2:{coco}, 3: CLS} ) we shall obtain • ( (l:{cnoun}) 2:{coco} (3 {N}) ) after applying the rule N_coco. The syntactic filter works like a parser but does not take into account agreement in number and gender between words. A specialized module in charge of verification of these agreements is now being designed. A prototype of such a module has been implemented in Prolog ; it detects agreement mistakes and can propose corrections by means of a morphological generator. We are now working on rewriting it in tile transducer language. The main use of the syntactic filter is therefore to validate the lexical category of the hypotheses generated by the lexical corrector by building dependency trees which take into account the semantic information attached to the words.","Example\"","With the phrase \"sun and moun\" we obtain","the following hypotheses for moun :","UL(Iex => \"morn\"; cat => cnoun; sem => TIME)","UL(lex => \"moon\"; cat :> cnoun; sem :> CELESTIAL-OBJECT)","UL(iex => \"mount\"; cat => verb; subj => UL(sem => S:ANIM, hTED) ; obj => UL(sem => O:PLACE} ; sem :> MOVE (agent => S ;","where => O)",") Each of these hypotheses is considered an interpretation of the unknown word moun. The rule of coordination is N coco [ (I:{N}, 2:{coco}, 3:{N}) /Unif(l.sem, 3.sem)/ => (( i )2 ( 3 ) ) ; ASSiGN(2.sem, Unif(l.sem, 3.sere)); ASSIGN(2 .nbr, plu) ] with for sun : UL(lex => \"sun\";","cat => cnoun;","sem => CELESTIAL-OBJECT) . The rule cannot be applied to mount because a verb is not a N. It can only be applied to the noun moon by unification of the seniantic features of moon and sun. With a phrase such as \"sun and mizrn\", the hypothesis generator gives for mi zrn : UL(cat => CLS) The application of the rule N_coco will give the tree of the figure 4."]},{"title":"5. Conclusion","paragraphs":["The use of a category hierarchy simplifies the writing of the rules and introduces a way of manipulating unknown words which is not part of the mechanisms of the system but which is 142 4 integrated in the objects it manipulates. We can then write rules without thinking about illformedness (i.e. it is not necessary to make the rules tolerant because the tolerance is implicit in the system).","UL(Ie:< => \"and\"; C~C =:> COCO; nbr > plu; sem =>","CELESTIAL-OBJECT)"]},{"title":"/ k","paragraphs":["UL(lex -> \"and\"; UL(cat : > N) cat => coco; sem :>","CELESTIAL-OBJECT) Figure 4 : Decorated tree The throe modules have each been implemented on a microcomputer, we are now working on integrating the three modules and adding the module for agreement verification. We are also improving the performance of the transducer : - by integrating a factorization technique for the intermediate forests in the form of a graphstructured stack [21 ], - by adding a finer control (graph of rule application) precomputed at compilation time."]},{"title":"Refi. rences","paragraphs":["I1] : H. A'it Kaci"]},{"title":"An Algebrai'c Approach to the eJ'['ective resolution of type equations.","paragraphs":["Theoretical Computer Science 45, 1986, pp 293--351 [2] : H. Ait Kaci, P. Lincoln"]},{"title":"LIFE .\" A natural language for natural language.","paragraphs":["MCC Technical Report, Number ACA-ST-074-88, February 88 [3] : H. A'it Kaci et al."]},{"title":"Ejficient implementation o./' Lattice Operations,","paragraphs":["ACM Transactions on Programming Languages and Systems ll:l, 1989, pp 116-146 [4] :C. Boitet"]},{"title":"Representation and computation of units of translation for Machine Interpretation of spoken texts.","paragraphs":["GETA & ATR Technical Report TR-I-0035, August 88 [5] : J.G. Carbonell & P.J. Hayes"]},{"title":"Recovery Strategies for Extragrammatical Language.","paragraphs":["AJCL 9:3-4, 1983"]},{"title":"Parsing [6] : E.","paragraphs":["ChaJ'niak"]},{"title":"On the use of framed language comprehension.","paragraphs":["AI 11, 1978."]},{"title":"knowledge for","paragraphs":["[7] : B. Cohard"]},{"title":"Logiciel de d~tection et de correction des erreurs lexicales.","paragraphs":["Mdmoire CNAM, Mars 1988 [8] :J. Courtin"]},{"title":"Algorithmes pour le traitement interactif des langues tmturelles.","paragraphs":["Th6se d'dtat, USMG, Octobre 1977 [9] : J. Courtin, D. Dujardin, I. Kowarski, D. Genthial, V. L. Strube de Lima"]},{"title":"Correqdo de erros de ortografia atrav~s da fondtica em textos escritos em franc~s.","paragraphs":["XIV Conferencia Latinoamericana de Inform~.tica, 17avas Jornadas Argentinas de Informfitica e Investigacidn Operativa, Buenos Aires, Sep. 1988. pp 873-891. [10] : J. Courtin, D. Dujardin, I. Kowarski, D. Genthial, V. L. Strube de Lima"]},{"title":"Interactive Multi-Level Systems for Correction of Ill-Formed French Texts.","paragraphs":["Proceedings of the 2 nd Scandinavian Conference on Artificial Intelligence, Tampere, Finland, June 1989 [11] : L. Emirkanianl L. Bouchard"]},{"title":"Knowledge integration in a robust and efficient morpho-syntactic analyser for French.","paragraphs":["12 th CoLing, Budapest, August 1988, pp 166-171. [12] : J. P. Fournier, J. V6ronis"]},{"title":"Traitement des erreurs dans la communication homme-machine en langage naturel.","paragraphs":["Acres des premi6res journ6es nationales du GRECO-PRC Communication Homme-Machine, Paris, Novembre 88 5 143 [13] : R.H. Granger"]},{"title":"The NOMAD System : Expectation-Based Detection and Correction of Errors during Understanding of Syntactically and Sermmtically Ill-Formed Text.","paragraphs":["AJCL 9:3-4, 1983, pp 188-196, [14] : Peter Hellwig"]},{"title":"Dependency Unification Grammar","paragraphs":["11 th CoLing, Bonn, August 1986, 195-198. [15] : G. Lapalme, D. Richard"]},{"title":"Un systOme de correction automatique des accords desparticipes passes.","paragraphs":["Techniques et Sciences Informatiques, 4, 1986 [16] : J. J. Pollock & A. Zamora"]},{"title":"Automatic' spelling correction in scientti[i'c and scholarly text.","paragraphs":["CACM 27:4, 1984 [17] : D. Scott"]},{"title":"Data Types as Lattices.","paragraphs":["SIAM Journal on Computing 5:3, 1976, pp 522-587 [18] : S. M. Shieber"]},{"title":"An Introduction to Unification-Based Approach to Grammar.","paragraphs":["CSLI Lecture Notes 4, 1986 [19] : G. Smolka and H. A'/t-Kaci"]},{"title":"inheritance IIierarchies : Semantics and Unification.","paragraphs":["Journal of Symbolic Computation 7, 1989, pp 343-370 [20] : Tesni6res"]},{"title":"Eldments de syntaxe structurale.","paragraphs":["Klincksiek, Paris, 1959 [21] :M. Tomita"]},{"title":"Graph-structured Stack and Natural Language Parsing.","paragraphs":["Proceedings of the 26 th Annual Meeting of the ACL, Buffalo, USA, June 88 [22] : R. Zajac, M. Emele"]},{"title":"Multiple Inheritance in RETIF.","paragraphs":["Report of the ATR Interpreting Telephony Research Laboratories. 144 6"]}]}