{"sections":[{"title":"Funetor-Driven Natural Language Generation with Categorial-Unification Grammars Dale G, erdemann Beckman Institute for Advanced Science and Technology University of Illinois at Urbana-Champaign 405 N. Mathews Urbana, IL 61801 USA Erhard W. Hinrichs Beckman Institute for Advanced Science and Technology University of Illinois at Urbana-Champaign 405 N. Mathews Urbana~ IL 61801 USA 1. Introduction","paragraphs":["In this paper we develop a functor-driven approach to natural language generation which pairs logical forms, expressed in first-order predicate logic, with syntactically well-formed English sentences. Grammatical knowledge is expressed in the fi'amework of"]},{"title":"categorial unifieation-qrammars","paragraphs":["developed by Karttunen (1986), Wittenburg (1986), Uszkoreit (1986), and Zeevat et. al. (1987). The semantic component of the grammar makes crucial use of the principle of"]},{"title":"minimal type assignment","paragraphs":["whose importance has been independently motivated in recent work in natural language semantics (see Partee and Rooth 1983). The principle of"]},{"title":"type-raising as necessary","paragraphs":["which follows fi'om minimal type assignment has been implemented using Wittenburg's (1987,1989) idea of supereombinators. This use of supercombinators to achieve semantic compatibility of types generalizes Wittenburg's strictly syntactic use of such combinators.","The use of categorial unification grammars makes it possible to develop an efficient top-down control regime for natural language generation. Rather than generating the syntactic output string in a leftotoright fashion, our algorithm always generates that part of the output string first that belongs to the funetor category in a given phrase, before it generates any of the arguments of the functor category. This fnnctor-driven strategy is similar to the head-driven approach to natural language generation developed by Shieber el. al. (1989). However, unlike the head-driven approach, which uses a mixed regime of top-down and bottom-up processing, our algorithm always has sufficient top-down information to guide the generation process. Moreover, due to the principle of minimal type assigmnent in the semantics, our approach avoids problems of efficiency that arise for the head-driven approach for those classes of grammars that do not satisfy this principle. The work reported here is implemented in the natural language system UNICORN, which can be used for natural language parsing (see Gerdemann and Hinrichs 1989) and na.tural language generation. 2. The Grammar Formalism: Categorim Unification Grammar","The grammatical formalism that we adopt for categorial unification grammar is similar to that proposed in Uszkoreit (1986). Following the schema for syntactic rules developed for PATR-style grammars, we formulate the ca tegorial grammar rule of functional application by the rule schema in fig. 1. The Figure 1: Function Application zl node (i.e. the node at the end of the path (zl}) represents a functor category that combines with an argument at x2 to yield as a result the category at x0. The rule also specifies that the semantic translation"]},{"title":"(trans)","paragraphs":["of the result category x0 is inherited from the functor xl. As is characteristic of categorial grammars, our syntactic rules are highly schematic, with most of the grammatical information encoded in the categorial lexicon. For example, constraints on word order are encoded in lexical representations of functor categories, rather than in the syntactic rules themselves. To this end we adopt an attribute"]},{"title":"phon","paragraphs":["(for:"]},{"title":"phonology)","paragraphs":["which is used to encode linear order for syntactic strings. The values for"]},{"title":"p~taon","paragraphs":["are structured as difference lists. The use of this data structure, inherited from PROLOG, allows us to concatenate functor categories with their arguments either to the left or to the right. It also allows us to state syntactic rules without having to make reference to constituent order.* The graphs in fig. 2 display partial lexical entries for the intransitive verb"]},{"title":"smiles,","paragraphs":["1In this respect, our representation is more compact than other categorial-unitlcation grammar formalisms which state order constraints in the categorial lexicon and in each syntactic rule. In particular, we don't need to distinguish between forward application and backward application i 145"]},{"title":"l,. c. /-,% j.","paragraphs":["%@//'N@~ o_ '~"]},{"title":"(v4 / #/ ~ from e s smiles~","paragraphs":["Figure 2: Phonology Rules for the proper name Tom and for the sentence Tom smiles. The phon attribute for argument categories such as proper names is encoded as a singleton list which contains the argument string in question, e.g. Tom. The phon attribute for functor categories is designed to combine the string for the functor category with the phon feature structure of its argument categories. In the case of the intransitive verb smiles, the morpheme smiles appears as the first element in a list that is appended to the difference list for its subject argument. When the phonology attributes for Ibm and smiles are combined by function application, the resulting sentence exhibits the correct word order, as fig. 2c shows. For the sake of con> pleteness, we also include the representation of the preposition from as an example of a forward functor in fig. 2d.","For the remainder of this paper we will concentrate on the interplay between syntax and semantics for the purposes of language generation. We will as-sume that information about word order propagates from the lexicon in the manner we just outlined by example."]},{"title":"3. Natural Language Generation with Categorial-Unification Grammars","paragraphs":["In this section we describe our functor-driven approach to natural language generation which pairs logical forms (represented in first-order predicate logic) with syntactically well-formed expressions of English. For example, given a first-order fornmla such as"]},{"title":"(1)","paragraphs":["gx[person'(x) --~"]},{"title":"smile'(x)]","paragraphs":["we want to generate a sentence such as Everyone smiles.","Ill order to produce the appropriate sentence, the generator is supplied with a start Dag as in fig. 3."]},{"title":"s ~., ~iksmil e &","paragraphs":["every )ersoll Figure 3: Start Dag for Everyone smiles","The first order formula (1) is represented in fig. 3 under the attribute trans (for: logical form translation). The value for the attribute cat specifies that the translation corresponds to a syntactic expression of category s (for: sentence). Unlike functional categories which take other syntactic categories as arguments, s is a basic category, i.e. a category which does not take an argument.","The task of the generator is to further instantiate start Dags such as that in fig. 3 so that appropriate syntactic expressions are generated in the most efficient manner possible. 3.1 A Functor-Driven Generation Algorithm","One advantage of the use of categorial grammars is that efficient generation can be effected by a completely general principle: at each step in the deriva-tion of a syntactic expression, constituents tha.t correspond to functor categories are to be generated before the generation of constituents that correspond to the functor's argument categories. The strategy underlying this principle is that in any grammatical construction, functor categories always provide more syntactic and semantic information than any of the argument categories. By generating the fnnctor cat-146 2"]},{"title":"a. o@.~i, ' b. /'/~?~4\"..o","paragraphs":["c. rans"]},{"title":"I¢ 'V","paragraphs":["\";~//\" ~'O '~ ~b person person"]},{"title":"s","paragraphs":["np smile Figure 5: Generating £'verg.one sraile.~"]},{"title":"J1\"'.4 I r \\+ s l~: \"-.~'e, \\","paragraphs":["smile person it,'igure 4: Start Dag u~Jifies with function application ;i'llle .::gory first, the choice of argnmenI~ categories will be :~e.verely con~-trained, which sigJ:ificantly prunes the ;;earch space in whieh the algorithm has t.o operate.","We will illustrate our approach by discussing the funetor-driven order of processing for the generation of the sentence Ever'gone <<-rsz'i, les. First the generator will make a top-down prediction by unifying the e.',bart Dag in fig..3 with the m0 node of the functional ;xpplication rule shown in fig. 1. The resulting Dag is shown in fig. 4.","The predicted Dag in fig. 4 then becomes sub- .}eel; to the principle of generating functor categories !'h-st. Identification of a functor eategory in a rule of categoriab.unitication grammar is straightforward: Ihe functor category is represented by the subdag whose wflue for the attribute c~tt is a Dag with ato i;,'ibut.es art and reszUt a.nd whose 'ce.~zlt are is reen- !rant with the value of the subdag rooted in ):0. Thus, in the case of fig. 4, the functor category is zl. 2 At this point there is enough information on the zl node to uniquely det, ermine the choice of a functor category, whereas the choice of an argument category would be eompletciy unconst.raired. When the !exical entry for eve,\";t/cne (fig. 5a.) unifies with the a:l node, the result is the Dag in fig. oh. ~ Then, at this point, the z2 node is fully enough instantiated to uniquely determine the choice of .~miles (fig. 5e) hom the lexicon. 3.2 Non-minimally Type Raised Functors","Now consider w]',at, happens when non-quantified NPs like To~Tz are type-raised as in"]},{"title":"~'[ontague","paragraphs":["(1974). That is, suppose that the lexical entry for Torn is the Dag ill fig. 6a rather than the lower type in fig. 6b. It turns out that if the type raised NP is used, it will not be possible to constrain the choice of func-for in generation. For example, fig. 7a shows the rule of flmction application (fig. 1) in which the z0 node has been unified with a start ])ag appropriate. to generate Tom ~miles. In fig. 7b, the zl node has unified with a type-raised entry for Hatred, show-. ing that the start Dag has done nothing to constrain the choice of functor. Thus, apart fl-om introducing spurious ambiguity into the grammar (see Wittenburg 1987 for detailed discussion), the operation of type-raising, when used unconstrained, can also lead to considerable inefficiency in generation. In order","2Alternatively, one could could simply take ¢1. to always be the functor since, given our use of the phon attribute, the order of xl and x2 no longer corresponds to linear order.","aA problem that arises here is that the ~1 node in fig. 4 will also unify with the lexieal entry for s~r~iles (fig. 5c) giving a nonsensical translation. Clearly, what needs to be done is to modify the semantic representations so that quantified expressions will not unify with non-quantified expressions. One line that could be investigated would be to have a type system which distinguishes quantified and non-quantified signs as in Pollard and Sag (1987). 3 14 \"7"]},{"title":"~~p fOS","paragraphs":["\"~ \"~ ~ l t"]},{"title":"0 ' S t m P smile ~Ep / - ,4","paragraphs":["harry"]},{"title":"C. -~o o","paragraphs":["P s i Figure 7: Generating Torn smiles"]},{"title":"<,2)# tom ~","paragraphs":["np ~ ~p tom Figure 6: Lexical entries for Totv, to constrain rite use of type-raising, we adopt the principle of minimal type a.,sigament suggesl;ed on independent grounds by Partee and Rooth (1(.)83). Part:ee and Rooth argued for t, he principle of minireal type assigament, tto account fox\" seopal properties of NPs in a variety of coordinate structures. Among the examples they discuss is tthe contrast between sentences sud~ as (2) a,,d (3). (2) Every student failed or got' a D. (3) Every student failed or every student got a D. (2) and (3) have different truth true if some students failed and while others got a D and did not would be false in that situat,ion. point out that appropriate truth","conditions. (2) is","did not get a D,","fail. (3), however,","Partee and Rooth","conditions for (2)","can only obtained if intransitive verbs are given a","non-Wpe-raised intterpretation and if their conjunc-","tion is represented by the k-abstract in (4). When","(4) is combined with the translation for every stu-","dent, the desired reduced formula in (5) is obtained. (4:) Aa[fail'(a:)V goLa_D'(z)] (5) Vm[student'(z) ...."]},{"title":"[failed'(ac)","paragraphs":["v got,_~LD'(~;)]l The use of conjoined type-raised predicates as in (6), however, would incorrectly yield the formula in (7), which is appropriate for (3) but not for (2)."]},{"title":"(6) v p(Az.goLa_D'(z)) (7) V [stud nt,'( ) -, V V0-[student'( ) --+ got,_a_D'(z)]","paragraphs":["On the other hand, Partee and Rooth point' out that for the interprc't,ation of senttences such as (8): intransitive verbs do ha.ve to be Wpe-raised, since (9) is a paraphrase of (8).","(8) A tropical storm was expected to form off t.lle coast of Florida and did form there within a few days of the forecast.","(9) A tropical st'orm was expected to form off the cc, ast of Florida and A tropical storm did form there within a few day's of the forecast'.","In order to reconcile this conflict, Partee and Rooth propose that extensionM intransitive verbs such as formed should be assigned t,o the lowest possible type and be type-raised only when t,hey are conjoined with an intensional verb such as be ezpected.","Given the principle of minimal type assignment, the entry for smile3 fig. 5c will now be the main functor in generating the sentence To~n s~..iles. It. can be seen that smiles (and no other non-type-raised cat.- egory) will unify with the zl node of fig. 7a. The resulting prediction is shown in fig. 7c. At this point the x2 node is constrained to unify with the minimal, non-type-raised entry fox: Torn (fig. 6by. Thus, the principle of minimal type assignment turns out to be crucial tor constructing efficient generation algorithms for categorial-unification grammars. 3.,3 Allowing Type-Raising as Needed","As seen in the previous section, efficient generation requires the use of basic (non-type-raised) NPs, whenever possible. However, this is not' t,o suggest' 148 4"]},{"title":"a..~~xC~x b. ~~ ~~ np ~c~~","paragraphs":["Figure 8: Type-Raising that the operation of type-raising can be eliminated from the grammar altogether. For example, t,ype-raising needs to apply in the case of conjoined NP's such as Tom and every boy. If we assume, as in Wittenburg (1986), that and is assigned the category in (10), 4 then to parse or generate a conjoined NP like Tom and every boy the category for Torn will have to be raised so that its type will match that of every boy. (10)"]},{"title":"(XIX)iX","paragraphs":["What is needed then is sonle operation that will convert the non-type-raised entry for [/bm in fig. 6b to its raised counterpart in fig. 6a. One way of in-corporating the necessary operation into the grammar would be via the type-raising rule in fig. 8a, in which the non-type-raised entry unifies with the xl node to yield the type-raised result at z0 '5 ttowever, the problem with the rule in fig. 8a is that it will allow type-raising not just as needed but also any-where else. So the problem of spurious predictions like that. in fig. 7b reemerges.","Clearly, what is needed is some way of allowing type-raising only in those cases where it is needed. Partee and Rooth suggest that type raising should be constrained by some kind of processing strategy, 6 withou~ indicating how such a processing strategy","4We use a non-directional calculus here, since word order is encoded into lexical items. The domain is to the right of tt~e bar and the range is to the left. The capital Xs represent a variable over categories. This is just a schematic representation of a considerably more complicated category.","SNote again thai., since phonology is encoded into lexical items, we can get by with a single rule of type-raising whereas most formalisms would require two. The phonological counterpart of type-raising would be:","• 4/","~Partee and Rooth were actually more interested in psyeholinguis¢ic processing strategies. Still their ideas carry over straightforwardly to computational linguistics. can be implemented. It turns out that the processing strategy that Partee and Rooth suggest can be stated declarativcly as part of the grammar, if the operation of type-raising is incorporated into a supercombinator (in the sense of Wittenburg 1987,89) that combines type-raising and functional application into a single operation.","Wittenburg himself was interested in constraining type-raising in order to eliminate the spurious ambiguity problem of eombinatory categorial grammars. He noted that in some of Steedman's (1985,1988) grammars type-raising was needed just in those cases where an NP needed to compose with an adjacent functor, tie, therefore, proposed that the type-raising rule be included into the function composition rule. The use of type-raising in coordinate structures that we have considered in this paper, is quite similar: We want type-raising to be licensed, just in case an NP is adjacent to a funetor that is locking for a type-raised argument. We, therefore, incorporate type-raising into the function application rule as seen in fig. 8b. Now, the old type-raising rule in fig. 8a is no longer needed, and spurious type-raising will no longer be a problem.","The type-raising supereombinator schema in fig. 8b is, for example, used in the generation of cool dinate structures such as Tom and every boy. Space will not allow us to fully present an analysis of such an NP here, but. the important point is that a non-type-raised lexical entry such as that in fig. 6b will be able to unify with the x2 node, and when it. does so, the subdag at the end of the path (zl cat art) will become identical to the type-raised entry for Tom in fig. 6a. 4."]},{"title":"Conclusion","paragraphs":["In this paper we have argued t,hat a functor-driven generation algorithnl for categorial unification grammars leads to efficient natural language generation, if the algorithm incorporates Part,ee and Rooth's (1983) principle of minimal type assignment. In order to have minimal type assignment and still allow type-raising in rest.ricted contexts, we have adopted Wittenburg's (1986) idea of supercombina-5 149 tors. Type-rMsing has been incorporated into the function application rule so that type-raising can only apply when some functor is looking for a type-raised argument. This use of supercombinators to achieve semantic compatibility generalizes Wittm> burg's strictly syntactic application of these combin at ors."]},{"title":"References","paragraphs":["Gerdemann, D. and Hinrichs, E. 1988. UNI-CORN: a unification parser for attribute-value grammars."]},{"title":"Studies in the Linguistic Sciences, 18(2):41-86","paragraphs":["Karttunen, L. 1986. D-patr: a development environment for unification-based grammars. In"]},{"title":"COLING-86.","paragraphs":["Montague, R. 1974. The Proper treatment of quantification in ordinary English. In R. Thornsson (Ed.),"]},{"title":"]7ormal Philosophy: Selected Papers of Richard A.~ontague,","paragraphs":["Yale University Press, New }taven.","Partee, B. and Rooth, M. 1983. Generalized conjunc-tion and type ambiguity. In R. Bau erle, C. Schwarze, and A. yon Stechow (Eds.),"]},{"title":"Meaning, Use and Interpretation o/Language,","paragraphs":["361-383, Walter de Gruyter. Pollard, C. and Sag, I. 1987."]},{"title":"An Information-Based Approach to Syntax and Semantics: Volume i Fundamentals. CSL[ Lecture Notes No. 13,","paragraphs":["Chicago University Press, Chicago.","Shieher, S. 1988. A uniform architecture for parsing and generation. In"]},{"title":"COLING-88,","paragraphs":["614-9.","Shieber, S., van Noord, G., Moore, R. C., and Pereira, F. C. N. 1989. A semantic-head-driven generation algorit, hm for unification-based formalisms. In"]},{"title":"ACL Proceedings, 27th An.nual Meeting,","paragraphs":["7-17.","Steedman, M. 1985. Dependency and coordination in the grammar of dutch and english."]},{"title":"Language,","paragraphs":["61:523-568.","Steedman, M. 1988. Combinat.ors and grammar. In R. Oehrle, E. Bach, and D. Wheeler (Eds.),"]},{"title":"Categorfal Grammar ar,,d Natural Language Structures,","paragraphs":["417-442, Reidel, Dordrecht.","Uszkoreit, H. 1986. Categoriat unification grammar. In"]},{"title":"COLING-86.","paragraphs":["Wall, R. and Wittenburg, K. 1989. Predictive normal forms for composition in categorial grammars. In"]},{"title":"Proceedings of International Workshop on Parsing Technologies,","paragraphs":["152-161. Wittenburg, K. 1986."]},{"title":"Natural Language Parsing with Cornbinatory Categorial Grammar in a Graph-Unification-Based Forrnalism.","paragraphs":["PhD thesis, The University of Texas at Austin.","Wittenburg, K. 1987. Predictive combinators: a method for efficient parsing of combinatory c~ttegorial grammars. In"]},{"title":"Proceedings of the 25th Annual Meeting of the Association for Computational Linguistics,","paragraphs":["73-80.","Zeevat, H, Klein, E, and Calder, J. 1987. Unification categoriM grammar. In N. Haddock, E. Klein, and G. Morrill (Eds.),"]},{"title":"Edinburgh Working Papers in Cognitive Science,","paragraphs":["195-222, Centre for Cognitive Science, University of Edinburgh."]},{"title":"150 6","paragraphs":[]}]}