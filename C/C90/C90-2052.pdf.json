{"sections":[{"title":"Reversible Unification Based Machm. Franslatlon Gertjan van Noord OTS RUU Trans 10 3,512 JK Utrecht Valmoord~hutruu59.BH~net March 28, 1990 Abstract","paragraphs":["[n this paper it will be shown how unification grammars can be used to build a reversible machine translation system.","Unification grammars are often used to define the relation between strings and meaning representations in a declarative way. Such grammars are sometimes used in a bidirecLional way, thus the same grammar is used for both parsing and generation, in this paper 1 will show how ~.o use bidirectional unification grammars to dethle reversible relations between language dependent meaning representations. Furthermore it is shown how to obtain a completely reversible MT system using a series of (bidirectional) unification grammars."]},{"title":"l Introduction","paragraphs":["The notion of a rew:rsible MT system was first expressed by Landsbergen [11]. Such a system will in principle produce a set of possible translations, by employing linguistic knowledge only. Choosing the best iranslation from the set. of linguistically possible translations will rsually require other sources of knowledge, either incorporated in the systenl or provided (interactively) by the. user. The relation 'possible translation' is symmetric whereas the relation 'best translation' is not. Thus an MT system may consist of a reversible core, implementi~:g the symmetric relation ~possible translation', and additional components (not necessarily reversible) to select tile best translation.","Not only is it pos.siblc to build reversible (modules of) MT systems; it has also been claimed that reversible systems are preferable. For example Isabelle [6] clahns that reversible MT systems are to be preferred to oth- (:rs be(:~nlse in reversible MT systems a better under-standing of the translation re.lation is achieved; such systems will eventually exhibit better practicM performance. Moreover, the arguments in favour of using bidirectional grammars in NL1 ), such as those given in [1, 8] carry over to translation as well.","Because o[ tile declarative nature of unification- and logic grammar formMisms grammars written in these formalisms are increasingly used in a bidirectional way, thus the sa.me grammar is used for both parsing and generation. Some recent developments are reported in"]},{"title":"[3, 24, 16, 21, 2, 18, 19, 22, 20].","paragraphs":["In this paper I will show how to use such bidirectional unification grammars to build a completely reversible, multilingual, MT system. For each language there is a unification grammar that defines a reversible relation between strings and language dependent lneaning representations (logical forms ). Moreover, for each language pair (or set of languages) there is a unification grammar that defines a reversible relation between such language dependent logicM forms. Translation is thus detined by a series of three unification granrmars.","A specific version of the system that is described here is implemented as the (:ore of the experiments! MiMo2 translation system [23]. This system aims at translating international news items on felctext. Apart from unification grammars the system rises a bidirectional two-level orthography component. Langu age de.- pendent meanings are represented as simple predicate argument structures with some extra labels indicating 'universal' meaning such as tense and aspect. The cur.- rent system (November 1989) includes grammars for Dutch, Spanish and English.","The paper is set up as follows. In section 2, I will give some examples that show how bidirectional unitication grammars can be used t.o define relation~ be tween logical forms of diiferent languages. In section 3, reversibility is detined in terms of symmetry and con> patability. Possible approaches to obtedu reversibility are discussed. In section 4, I wilt compare the current approach with some other approaches in tile unification based translation paradigm and discuss some problems and future directions."]},{"title":"2 Unification-based Transfer","paragraphs":["in this section 1 wilt give some exan@les of the use of a unification grammar (in PATR II [17] notation) to define the relation between language dependent logical forms. For illustrative purposes I will assume logical fl)rms are represented by feature structures consisting of the attributes pred, ar.ql, art2 together with some attribu tes representing 'universM' meanings such as tense, aspect, munber and person; I will not touch upon issues such a~s quantification and modification. The logical forlns of English and Spanish are labeled by the attributes 9 b and sp respectively. As an example"]},{"title":"299","paragraphs":["the logical form of 'The army opened fire at the civilians' is represented as in figure 1. Such feature struc-Figure 1: An example of a logical form gb = pred = open_fire_at ?~ulttber :. sg","[wed=civilian] arg2 = number -- pl tures will often be related ill a straightforward way to a Spanish equivalent., except for the value of the prod attributes. A very simple rule in PATR II style may look as in figure 2. This rule simply states that the Figure 2: A simple rule 0--+123"]},{"title":"(0 gb pred) =","paragraphs":["(1"]},{"title":"gb)","paragraphs":["(0"]},{"title":"gb argl) = (2 gb) (0 gb arg2> = (3 gb) (0 sp pred) = <1 sp) (0 sp gl) = (2 sp> (0 sp arg2) = (3 sp)","paragraphs":["translation of a logical form is composed of the translation of its arguments. If the rule applies to the feature structure in 1 tile three daughters of the rule will be instantiated as in figure 3, and the value of sp will be bound to the sp values of these daughters. An example Figure 3: Three instantiations [ gb = open_fire_at ]"]},{"title":"[ 1","paragraphs":["gb = namber = pl '~umber ~- sg of the rule for the first daughter will be a lexical entry and looks as iu figure 4. The simple English expression 'army' has to be translated as a complex expression in Spanish: 'Nerza militar'. The rule will look a.s in 5 where it is assumed that the construction is analyzed in Spanish as an ordinary noun-adjective construction, and where the logical form of the adjective takes the logical form of the noun as its argument. The translation for 'civilian' is defined in a similar rule (although the translation of 'number' is different). Note that this example of complex transfer is similar to the famous 'schimmel - grey horse' cases. As a result of the rule Figure 4: A lexical entry 0 --~"]},{"title":"<0 gb) = open_fire_at (0 sp> = romper_el_fuego_a","paragraphs":["Figure 5: A rule for 'fuerza rnilitar' 0 ---~ (0 gb pred) = ,army (0 ap pred pred) = militar (0 sp argl pred) = fuerza (0 sp argl nmnber) = (0 gb number} applications the feature structure in figure 1 will get instantiated to tile feature structure in 6, from which the generator generates the strir~g 'La fllerza militar rompio el fuego a la poblacion civil'. Figure 6: The feature structure after transfer 9b = sp pred = open_fire_at","[ pred ....... y] argl :-x n.ur~zbe, e = s 9","pred = civilian arg2 =: t~umber ---- pl pred = romper_el_fuego_a ar 9 1 = at92 ="]},{"title":"]","paragraphs":["ar91 pred = ]uerza ,zttrllbev ~. sff","pred = poblacioI~ at9! L ,;.,arnber = s 9","In the foregoing examples the relation between Iogicar forms is rather straightforward. Note however that tile full power of a unification grammar can be used to settle more difficult translation cases, because differellt attributes can be used to represent the 'translational syntax'. For instance we can build a tree as value of the attribute tree to represetlt tile derivational history of the translation process. Or we can %hread'informa-tion through different nodes to be able to make translations dependent on each other. Translation parameters such as style and subject field can be percolated as attributes of nodes to obtain consistent translations; but these attributes themselves need not be translated."]},{"title":"3 Reversible Unitication Grammars","paragraphs":["A unification grammar defined in formalisms such as PATR II and 1)CG [12] usually defines a relation between a string of words and a logical form. In sign-based approaches such as UCG [26] and flPSG [14] this string of words is not assigned a privileged status but is the value of one of the attributes of a feature structure. I will assume a formalism similar to PATR II,"]},{"title":"300","paragraphs":["but without the context-free ba~e; the string is represented as the value of one of the attributes of a feature structure. Thus more generally, unification grammars define relations between the values of two (or more 1) attributes - for example the relation between the value of the attributes"]},{"title":"string","paragraphs":["and"]},{"title":"If,","paragraphs":["or between the value of the attributes"]},{"title":"sp","paragraphs":["and"]},{"title":"gb;","paragraphs":["these relations are all relations between feature structures."]},{"title":"3.1 ]Reversibility","paragraphs":["I will call a binary relation"]},{"title":"reversible","paragraphs":["if the relation is"]},{"title":"symmetric and computable.","paragraphs":["Both symmetry and computability will be explained in the following subsec-tions. A grammar G is reversible for a relation R iff R is reversible and defined by G. For example, a grammar that relates strings to logical forms is reversible if both the parsing and generation problem is computable, and the relation between strings and logical forms is symmetric; the parsing problem is computable if for a given string all corresponding logical forms can be enumerated by some terminating procedure; such a procedure should halt if the given string does not have a corresponding logical form. Thus: reversible -- symmetric + computable. Note that reversibility as defined here is different from bidirectionality. The latter merely says that grammars are to be used in two directions, but does not state how the two directions relate.","It is easy to see that a composition of reversible relations is a a reversible relation too; i.e. if some feature structure fl is related to some feature structure f~ via the reversible relations"]},{"title":".Ri(fi,fi+l),","paragraphs":["each defined by some reversible grammar"]},{"title":"Gi,","paragraphs":["then"]},{"title":"R'(fl, fn)","paragraphs":["is reversible. Thus an MT system that defines a relation R(,%,"]},{"title":"st)","paragraphs":["via the relations"]},{"title":"t~ ( s~, 5), Ry ( l~, lt ) and Ra(lt, st)","paragraphs":["is reversible if"]},{"title":"R1,2,3","paragraphs":["are reversible. 3.1.1 Symmetry A relation R C A x B is symmetric iff"]},{"title":"R(a, b)","paragraphs":["implies"]},{"title":"R(b, a ~)","paragraphs":["where a and a' are equivalent. For an MT system we want to define 'equivalence' in such a way that the translation relation is a symmetric relation between strings, ttowever, strings are feature structures thus wc must define equivalence for feature structures to obtain this effect.","Unification grammars as they are commonly used implement a rather"]},{"title":"weak","paragraphs":["notion of equivalence between feature structures: feature structures a and b are equiv-Ment if they ca~ ~if>.: Definition I (Weak equivalence)"]},{"title":"Two feature structures fl, f2 are weakly equivalent iff fl","paragraphs":["U"]},{"title":"f2 exists.","paragraphs":["if feature structures are taken to stand for all their grouml iustances this yields an acceptable version of sym ;~e.try. Moreover, under the assumption that","1 Note that it is possible to define a unification gra~nmar that relates several language dependent logical forms; in this approach a multilingual transfer system consists of only one transfer gramm,'m feature structures which represent strings are always ground (i.e. these feature structures cannot be extended), this results in a symmetric relation between (feature structures that represent) strings.","It is also possible to define a 'strong' notion of equivalence for feature structures that does not rely on this assumption. Definition 2 (Strong equivalence)"]},{"title":"Two feature structures fl,f2 are strongly equivalent (fl =-- f2) iff /2 E A and A E f2.","paragraphs":["A grammar that defines a computable relation between two attributes under the strong definition of equivalence might be cMled"]},{"title":"strongly reversible.","paragraphs":["Similarly a"]},{"title":"weakly reversible","paragraphs":["grammar is reversible under a weak definition of equivalence. Again these results can be generMized to a series of unification grammars. The strong version of equivalence can be motivated on the ground that it may be easier to obtain computability; this is the topic of the next subsection. In section 3.2 I will discuss possible relaxations of the strong version of equivalence to obtain 'mildly' reversible grammars. 3.1.2 Computability A relation R C A x B is"]},{"title":"computable","paragraphs":["iff for a given a E A the set {b C"]},{"title":"B]R(a,b)}","paragraphs":["can be enumerated by some terminating procedure. To discuss cornputability it is useful to look a bit more careful at the relations we are interested in. These relations are all binary relations between feature structures, ttowever, in tile case of the relation between strings and logical forms, strings will always be related to logical forms and logical forms will be related to strings. Similarly for the relation between l)utch and Spanish logical forms. Clearly, the domain and range of the relation is structured and can be partioned into two sets A and ]3, [or example the set of feature structures representing strings and the set of feature structures representing logical forms. The relation R C A U B x A U B can be partitioned similarly into the relations r C A x I] and its inverse, r -~ C B x A. The problem to compute R is now replaced by two problems: the computation of r and r -1. For example the problem to compute the relation between logical forms and strings consists of the parsing- and generation problem. It is now possible to incorporate the notion of equivalence, to obtain a definition of a parser, generator and translator. For example, an Mgorithm that computes the foregoing relation r will enumerate for a given features structure fl all feature strnctures"]},{"title":"fy,","paragraphs":["such that"]},{"title":"r(fa, fy)","paragraphs":["and f~ and f3 are equivalent. In the case of strong equivalence this implies that"]},{"title":"fl~ f3 (completeness),","paragraphs":["and fa U fl"]},{"title":"(coherence).","paragraphs":["In other words, the input should not be extended (coherence) and should completely be derived (completeness). This usage of the terms completeness and coherence was introduced in [24]. In the following I will discuss ways to obtain computability of one such partition.","It is well known that relations defined by unrestricted unification grammars are not computable in general a~s"]},{"title":"301","paragraphs":["such grammars have Turing power [13]; it is thus not decidable whether the relation is defined for some given input. Usually some constraint on grammars is defined to remedy this. For example the off-line-parsability constraint [13, 5] ensures that the recognition problem is solvable. Moreover this constraint also implies that the parsing problem as defined here is computable; i.e. the proof procedure will always terminate (because the constraint implies that there is a limit to the depth of possible parse trees for all strings of a given length).","llowever the off-line-parsability constraint assumes a context-free base of the formalism. A generalization of the off-line-parsability constraint for any binary relation defined by unification grammars will consist of three parts; the first and third of these parts are usually implicit in the case of parsing.","Pirst, the value of the input must be built in a wellbehaved compositional way. For example in the case of parsing: each daughter of a rule dominates part of the string dominated by the mother of that rule. Similarly for transfer and generation: each daughter of a rule has a value for"]},{"title":"If","paragraphs":["that is part of the value of"]},{"title":"If","paragraphs":["of the mother.","Second, a special condition is defined for rules where the input vMue of the mother is the same as the input value of one of the daughters. [:or parsing such rules have exactly one daughter. A chain of applications of such rules is disallowed by some constraint or other; this is the core of most definitions of the off-line parsabilityoconstraint. For example in [13] such a chain is disMlowed as the principal functor of a term may only occur once in a chain. For a slightly more general definition, cf. [5]. For generation and transfer a similar constraint can be defined. In the terminology of [18, 19] the 'head' of a rule is a daughter with the same logical form as its mother. A chain of these heads must be disallowed.","Third, the input should not get extended during the proof procedure. In the case of parsing this is achieved eaMly because the input is ground 2. For generation and transfer this is not necessarily the case. This is the point where the usefulness of the coherence condition comes in; the coherence requirement explicitly states that extension of the input is not allowed. For this reason strong reversiblity may be easier to obtain than weak reversibility. In the next subsection I will discuss two relaxations of strong symmetry that will not affect the computability properties discussed here.","Generalizing the terminology introduced by"]},{"title":"[13]","paragraphs":["a proof procedure is"]},{"title":"strongly stable","paragraphs":["iff it always terminates for grammars that adhere to a generalized off-line parsability constrMnt. In [15] a general proof procedure for DCG based on head-driven generation [18, 19, 22] is defined that is strongly stable for a specific instantiation of the generalized off-line parsability constraint.","?'Note that this is the reason that most DCG parsers expect that the input value of the string has an atomic tail, i.e."]},{"title":"parse([john, kisses,mary], ~)","paragraphs":["will work fine, but"]},{"title":"parse([john, kisses, mary]X], X)","paragraphs":["will cause problenas. 3.2 Possible relaxations It is easy to see that the completeness and coherence requirenrents make life hard for the rulewriter as she/he needs to know exactly what the possible values of in-puts are for some component. It is possible to relax the completeness and coherence requirement in two ways that will not affect the reversibility properties between strings. The useflfiness of these relaxations depends on the analyses a user wishes to define. 3.2.1 Cyclic and non-cyclic attributes The first relaxation assumes that there is a sort system defined for feature structures that makes it possible to make a distinction between"]},{"title":"cyclic","paragraphs":["and non-"]},{"title":"cyclic","paragraphs":["attributes (cf. [5]). For the moment a non-cyclic attribute may be defined a.s an attribute with a finite number of possible values (i.e. it is not recursive). For example the attributes"]},{"title":"argl","paragraphs":["and"]},{"title":"arg2","paragraphs":["will be cyclic whereas"]},{"title":"number","paragraphs":["will be non-cyclic. The completeness and coherence condition is restricted to cyclic attributes. As the proof procedure can only further in-stantiate non-cyclic attributes no termination problems occur because there are only a finite number of possibilities to do this. The definition of 'equivalence' for feature structures is now slightly changed. [[b define this properly it is necessary to define the notion"]},{"title":"non-cyclic extension.","paragraphs":["A non-cyclic extension of a feature structure only instantiates non-cyclic attributes. This results in the following definition of equivalence: Definition 3 (Non-cyclic equivalent)"]},{"title":"Two feature structures f:, f2 are non.cyclic equivalent iff f~ _=__ f~ where f~ are non-cyclic extensions of f,~.","paragraphs":["It will be clear that the usefulness of this definition depends heavily on the style of grammar writing that is used. Note that it is of course also possible to declare for each non-cyclic attribute whether the completeness and coherence requirements hold. 3.2.2 Reentrancles The second relaxation is not without ramifications for the organization of a transfer grammar. Tlfis relaxation has to do with reentrancies in feature structures. Some constructions such as control verbs and relative clauses may be represented using reentrancies; for example 'the soldiers tried to shoot the president' may be represented by a feature structure where the first argument of 'try' is reentrant with the first argument of 'shoot', cf. figure 7. The translation of such logical forms to Dutch equivalents can be defined as in rule 8. In this rule the reentrancy is explicitly mentioned for two reasons. The first reason is simply that in the case of different possible translations of"]},{"title":"ar91","paragraphs":["we want the same translation for both"]},{"title":"argl","paragraphs":["and the embedded"]},{"title":"argl.","paragraphs":["Note that the translation of 'soldier' into Dutch can be both 'soldaat' or 'militair'. If the reentrancy is not mentioned the system has to try to generate from four different Dutch logical forms, two of which without matching"]},{"title":"argl's. 302","paragraphs":["Figure 7: A logical form containing reentrancy gb= pred = try argl = [] [ pred = soldier","number = pl ]","ar.q2 = argl = [] pred = president arg2 = nu'mber = sg Figure 8: Translating subject control 0--.123 (0 gb pred) = (1 gb)"]},{"title":"<0 nl pred} = <~ ~p> (0","paragraphs":["nl"]},{"title":"argl)","paragraphs":["="]},{"title":"(0 nl arg2 argl) <o gb ~rg1> = <2 gb) (0 nl ~rg1> = <2 ~p> <0 gb arg2} = (3 gb> <o n:L ~g2} = <3 ~p>","paragraphs":["The reentrancy is also mentioned because this is required by the completeness condition. It is possible to relax the completeness and coherence condition with respect to these reentrancies, again without directing the reversibility properties of the system by slightly changing the definition of equiva]ence. There is a tradeoff between simplicity of the transfer grammar (in the presence of this relaxation) and the efficiency of the system. In the case of this relaxation the system will eventually lind the good translations, but it may take a while. On the other hand, if we are to mention all (possibly unbounded) reentrancies explicitly then the transfer grammar will have to be complicated by a threading mechanism to derive such reen trancies. Again, the specific use o:[ reentrancies in the logical forms that are defined will deterlnine whether this relaxation is desired or not."]},{"title":"4 Final remarks","paragraphs":["The objective to build a reversible MT system using a series of unification grammars is similar to the objective of the CRITTER system as expressed in [3, 7], and the work of Zajac in [25]. Instead of using unification grammars CRITTER uses logic grammars; Zajac uses a type system including an inheritance mechanism to define transfer-like rules. In these two approaches less attention is being paid to an exact definition of reversibility; although our work may be compatible with these approaches.","A somewhat different approach is advocated in [9]. In that approach a system is described where an I, FG grammar for some source language is augnlented with equations that define (part of) the target level representations. A generator derives from this partial description a string according to some LFG grammar of the target language. Instead of a series of three grammars this architecture thus assumes two grammars, one of which both defines the source language and the relation with the target language. The translation relation is not only defined between logical forms but may relate ~ll levels of representation ( c.structure, f-structure, a-structure). Although in this approach monolingual grammars may be used in a bidirectional way it is unclear whether the translation equations can be used bidirectionally 3","An important problem for the approach advocated here is the problem of logical form equivalence. Shieber [16] noted that unification grammars usually define a relation between strings and some canonical logical form. Depending on the nature of logical forms that are being used, severM representations of a logical form may have the same 'meaning'; just as in first order predicate calculus the formulas p v q and q v p are logically equivalent; a unification grammar will not know of these equivalences and, consequently, all equivalences have to be defined separately (if such equivalents are thought of as being translational equiwdents); for example in a transfer grammar two rules may be defined to translate p V q into both p' V q' and q' V p' if these formulas arc thought of ,~ being equivalent. Of course this technique can only be applied if the number of equivalences is finite, it is not possible to define that p is equivalent with ..... p for any even number of --'s.","The approach discussed so far can be extended just as unification grammars for parsing and generation have been extended. Apart from equationM constraints it will be useful to add others such as disjunction and negation. Moreover it seems useful to allow some version of universal constraints or some inheritance mechanisrn to be able to express generalizations and excep-tions more easily."]},{"title":"Acknowledgements","paragraphs":["I want to thank Joke Dorrepaal, Pim van der Eijk, Maria Florenza, Dirk Iteylen, Steven Krauwer, Jan Landsbergen, Michael Moortgat, IIerbert Ruessink and Louis des Tornbe. I was supported by the European Community and the NBBI through the Eurotra project."]},{"title":"References","paragraphs":["[1] Douglas E. Appelt. Bidirectional gr~nmars and the design of natm'al language generation systems. In Theoretical Issues in Natural Language Processing 3, 1987.","[2] Jonathaal Calder, Mike Rcape, and tlenk Zeevat. An algorittma for generation in unification catcgorial grammar. In Fourth Con.ference of the European Chapter of the Association for Computational Linguistics, 1989.","[3] Marc Dymetman ~ld PielTe Isabellc. Reversible logic grannnars for machine translation. In Proceedings of the Second International Conference on Theoretical","3Although parsing of LFG's is decidable no such result is available for generation; note furthermore that according to [9] extension is Mlowed dm'ing generation. 303 and Methodological issues in Machine Translation of Natural Languages, 1988.","[4] Barbara Qrosz, Karen Sparek Jones, and Bonny Lynn Webber, editors. Readings in Natural Language Processing. Morgan Kaufinann, 1986.","[5] Andrew Haas. A generalization of the offline parsable grammars. In '27th Annual Meeting oJ the Association for Computational Linguislies, 1989.","[6] Pien'e Isabelle. Towards reversible MT systems. In MT Summit ]I, 1989.","[7] Pien'e Isabelle, Marc Dymetman, and Elliott Macldovitch. CRITTER: a translation system for a~'ieulturM market reports. In Proceedings o/ the 12th International Conference on Computational Linguistics, Budapest, 1988.","[8] Paul S. Jacobs. Achieving bidirection'Mity. In Proceedings o] the 12th International Conference on Computational Linguistics, 1988.","[9] Ronald Kaplan, Klaus Netter, Jiirgen Wedekind, and Annie Zaenen. Translation by structural correspondences. In Fourth Conference o] the European Chapter of the Association for Computational Linguistics, 1989.","[10] Margaret King, editor. Machine Translation, the State o] the .4 ft. Edinburgh University Press, 1987.","[11] Jan Landsbergen. Isomorphic grammars and their use in the Rosetta translation system, 1984. paper presented at the tutorial on Machine Translation, Lugano t984, Also appears in [10].","[12] Femando C.N, Pereira and David WaITen. Definite clause grammars for language analysis - a survey of the formMism and a comparison with augmented transition networks. Artificial Intelligence, 13, 1980. reprinted in 114].","[13] Femando C.N. Pereira and David Wan'ca. Parsing as deduction. In 21st Annual Meeting of the Association /or Computational Linguistics, 1983.","[14] Carl Pollard and Ivan Sag. In.formation Based Syntax and Semantics. Center for the Study of Langalage and Information Stanford, 1987.","[15] Herbert Ruessink attd Gertjan van Noord, Remarks on the bottom-up generation Mgorithm. Technical report, Department of Linguistics, OTS RUU Utrecht, 1989.","[16] Stuart M. Stfieber. A mfiform architecture for parsing and generation. In Proceedings o/ the 12th International Conference on Computational Linguistics, 1988.","[17] Stuart M. SIfieber, Hans Uszkoreit, Fernando C.N. Pereira, J. Robinson, and M. Tyson. Tile formalism and implementation of PATR-II. In B. J. Grosz and M. E. Stickel, editors, Research on Interactive Acquisition and Use o] Knowledge. SRI report, 1983.","[18] Stuart M. Shieber, Gertjan van Noord, Robert C. Moore, and Fernando C.N. Pereira. A semantic-head-driven generation Mgorithm for unification based formMisms. In 27th Annual Meeting of the Association .for Computational Linguistics, 1989.","[19] Stuart M. Shieber, Gertjan van Noord, Robert C. Moore, and Fernando C.N. Pereira. Semantic-head-driven generation. Computational Linguistics, 1990. To appear.","[20] Tomek Strzalkowsld. Automated inversiot) of a unification parser into a unification generator. Technical report, Courant Institute of Mathematical Sciences, New York University, 1989. technical report 465.","[21] Gertjau van Noord. BUG: A directed lmttom-up generator for unification ba~sed fonnMisms. Working Papersia Natural Language Processing, Katholieke Universiteit Leuven, Stichting Taaltechnologie Utrecht, 4, 1989.","[22] Gertjan van Noord. An overview of head-driven bottom-up generation. In Robert Dale, Chris Mellish, and Michael Zock, editors, Current Research in Natural Language Generation. 1990.","[23] Gertjan vail Noord, Joke DorrepaM, Louis des Tombe, and Pim van der Eijk. The MiMo2 research system. OTS RUU Utrecht.","[24] Jiirgen Wedekind. Generation as structure driven derivation. In Proceedings o/ the 12th International Conference on Computational Linguistics, 1988.","[25] Rdmi Zajac. A transfer model using a typed feature structure rewriting system with inheritcnce, In 27th Annual Meeting of the Association for Computational Linguistics, 1989.","[26] [leak Zeevat, Ewau Klein, and Jo Calder. Unification categorial grammar. In Nicholas tIaddock, Ewan Klein, and Glyn Morrill, editors, Categorial Grammar, Unification Grammar and Parsing. Centre for Cognitive Science, 1987. Volume 1 of Working Papel.'s in Cognitive Science. 304"]}]}