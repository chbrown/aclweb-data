{"sections":[{"title":"Parsing Plans Situation-Dependently in Dialogues","paragraphs":["Kiyoshi Kogure, Akira Shimazu"]},{"title":"and Mikio","paragraphs":["Nakano","NTT Basic Research Laboratories","3-1 Morinosato-Wakamiya, Atsugi, Kanagawa, 243-01. Japan","{kogure, shimazu, nakano}@atom, brl. ntt. jp"]},{"title":"Abstract","paragraphs":["This paper describes a plan parsing method that can handle the effects and preconditions of actions and that parses plans in a manner dependent on dialogue state changes, especially on the mental state changes of dialogue participants caused by utterances. This method is based on active chart parsing and uses augmented edge structures to keep state information locally and time map management to deal with state changes. It has been implemented in Prolog and is used for plan recognition in dialogues."]},{"title":"1 Introduction","paragraphs":["Dialogue understanding requires plan recognition. Many plan inference models have thus been proposed. As an approach to the computation of plan recognition from observed actions, plan parsing hms been proposed by Sidner (1985) and formalized by Vilain (1990). A typical plan recipe for an action includes a sequence of subactions as its decomposition, so interpreting an action sequence in terms of plans can be seen as parsing in which observed actions correspond to lexieal tokens and plan recipes correspond to grammatical rules.","Previous plan parsing methods, however, are insufficient for dialogue understanding since they do not handle the effects and preconditions of actions. These effects and preconditions are of crucial importance in reasoning about what the agent intends to do and what she presupposes. More concretely, without treating them, it is impossible (a) to describe actions in terms of their effects, (b) to capture the relationship between an action and another action that satisfies the former's preconditions to enable it, and (c) to interpret actions in a manner dependent on the dialogue state.","To solve these problems, we have developed a plan parsing method that can handle the effects and preconditions of actions and that parses plans in a manner dependent on dialogue state changes, especially on the mental state changes of dialogue participants caused by dialogue utterances. This method, in particular, makes (a) (c) possible. The method is based on active chart parsing and uses augmented edge structures to keep state information locally and time map management (Dean and McDermott, 1987) to deal with state changes. The method is implemented in Sicstus Prolog and is applied to a dialogue understanding system (Shimazu et al., 1994). 2 Requirements for Treating"]},{"title":"Effects and Preconditions","paragraphs":["Let us examine typical situations where the effects and preconditions of actions must be treated."]},{"title":"2.1 Effect-Based Action Descriptions","paragraphs":["In describing plan recipes, it is convenient to specify an action in terms of its effects ms follows:"]},{"title":"Recipe","paragraphs":["1 Action: informref(S, H, Term, Prop) Decomposition: achieve(bel(H, P)) Effects: belref(H, Term, Prop) Constraints: parameter(Term, Prop) A description of the form 'achieve(P)' specifies the action for achieving the state where the proposition P holds. This recipe thus says that an informref action can be performed by an action that has 'bel(H, P)' as its effect. There may be many such actions. Furthermore, the action specified by 'achieve(P)' depends on the situation where P is about to be achieved. In the extreme case, ifP already holds, the agent need not do any-thing. For example, a speaker may not perform any action to make a hearer believe a proposition if the speaker believes the hearer already believes it. If we are not permitted to use this form, we must enumerate all the actions that achieve P to-gether with the conditions under which they do. Treating this form requires calculating the effects of actions."]},{"title":"2.2 Action-Enabling","paragraphs":["Given a goal, a planning procedure searches for an action to achieve the goal (a main action). If the procedure identifies such an action with preconditions, it calls itself recursively to search for actions"]},{"title":"1094","paragraphs":["O~","~01 .~ : contradicts(~,~, q</) ~oj: Figure h Effects of Complex Action. that satisfy them (enabling actions of tile main action), and then provides the action sequence consisting of the main action preceded by its enabling actions. Given an action sequence of this form, a plan recognition procedure must thus regard it as I)erforming a main action to achieve its ettb.ct(s). There are many kinds of dialogue phenomena that can be captured by such action-enabling relationships. Understanding snch dialogue phenomena reqnires handling effects and preconditions. 2.3 State-Dependent Interi)retation There are cases where state-dependent interpretation is iml)ossible unless the effects and preconditions of actions are treated. Consider, for example, the folh)wing dialogue fragment: A: Please tell Ine how to go to the Laboratories. B: Take the bus to Tokyo. Whereas an imperative sentence (with surface speech act type surface_request) is generally interpreted as a request, the second utterance actually describes a step in tile plan to go to the Laboratories because the first utterance convinces B that A wants to have that plan. This latter interpretation can be captured by using the heuristic rule for seh;cting an interpretation with fewer unsatisfied preconditions and the following recipe: Recipe 2 Action: describe_step(S, H, Action, Plan) Preconditions: bel(S, want(H, Plan)) Decomposition: surface_request(S, It, Action) Constraints: stei)(Aetion , Plan) This interpretation would be possible instead by using a recipe whose decomposition Mso contains the action of making B believe A's want. However, such a recipe can handle only cases where the belief has been established by the action just before surface_request."]},{"title":"3 Effects and Preconditions 3.1 Effects of Actions","paragraphs":["The efl>cts of a linguistic action in a dialogue mainly I)roducc unobservable mental state changes of the diMogne participants. For a computer to participate in a dialogue like people do, it must simulate such mental state changes.","The clthcts of an action are the propositions tlmt hold after the action's successfltl execution. The effects are taken to be cah:nlated recursively c~ Case (a)","(tgj = ~/)k I I* C~e (b)","~Pk : ~j = ~Pk) .... ~i ,, , contradicts(~i, ~bk) C:~s0 (~) '~bk : contradi('ts((pl, ~bk)","qoi ) ). Case (d) contradicts(q~i, ~Pk) 't/,' i Figure 2: Preconditions of Complex Action. fl'om tile action's recipe and component actions if any: the effects are essentially those specified by the action's recipe, plus those of component actions. Since an action is modeled to have a certain tenq)oral extent, an action's effect is inodeled to hohl at the point in time where the action has just finished and to continue, to persist infinitely or until the first instance that a contradictory fact holds. An effect of an a(:tion's component action also holds in the same way. Therefore, an action ~ with (71,-..,%) as its component actions has component action 7{'s effect ~oi as its own ef-R'~ct if there is no component action 3'3 after 3'/ with an e[fect 99j contradictory to ~oi written as contradicts(~,i, ~j)- and does not if such \"~i exists as in Figure 1. a.2 Preconditions of Actions Tile preconditions of an action are tile proi)osi- (ions that must hold before the action's successful execution. Recognizing an action thus requires that its preconditions can be ~msured or at letust hypothesized to be believed by the agent.","The preconditions of an action are essentiMly taken to consists of those specified by the ac~ tion's recipe and those of its component actions if atty. A component action's precondition, however, can be satisfied by another component action's effect. Consider action a with its component actions (%,...,%~), as shown in Fignre 2. Let us focus on precondition '~b/~ of action %. When the.re is an action 7j before % such that its ef~ fect q0j is identical to '~bk as in Case (a) in the figure, \"~b k is satisfied by ~oj, so *Pk need not hoht at (~'s starting time. That is, ~ does not have ~/J/~ as its precondition. On the contrary, when there is an action ~i before % such that its effect q0i contradicts ~/;k, ~bk's hohting at a's starting time cannot contribute to the satisfaction of %'s precondition */;k- If there exists an action 7j between 7i and % with its effect qoj identical to ~bk, ~/Jk can be satistied [Case (b)]. Otherwise, *Pk emmot be satisfied [Case (c)], so a cannot be successflflly ex-- ecuted and shonht not be recognized. This kind of 1095 interference is hereafter called 'effect-precondition (E-P) conflict.' There is another kind of interference called 'precondition-precondition (P-P) conflict:' if a precondition specified by ~'s recipe, or a precondition ¢i of any other component action 7i contradicts Ck, they cannot hold simultaneously at c~'s starting time [Case (d)]. In such a case, should not be recognized. 4 Active Chart Plan Parsing 4.1 Decomposition Grammar The relationship between an action and its decomposition specified by a recipe can be viewed as a phrase structure rule. The decomposition relationship specified by Recipe 2, for example, can be view as","describeostep(S, H, Action, Plan) surface_request(S, H, Action). This interpretation of the decomposition relationships specified by recipes in a plan library gives us a decomt)osition grammar and allows us to apply syntactic parsing techniques to plan recognition.","Based on this idea, we constructed a plan parsing method that handles the effects and precondi= tions of actions. Hereafter, we focus on bottomup active chart parsing, although the core of the discussion below can be applied to other parsing methods. 4.2 Calculating Effects and Preconditions Time Map Management","Time map management is used to capture the temporal state changes caused by the effects of actions. A time map consists of a set of (potential) fact tokens) A fact token is a triple"]},{"title":"(tl,t2,~o),","paragraphs":["where tl and t2 are time points and ~ is a time-less fact description (a term), that represents the proposition that ~ holds at tl and continues to persist through t2 or until a contradictory fact holds. As a time point, we use a vertex in a chart, which is an integer. As a special case, time point T is used to represent unbounded persistence. An effect ~ of action finishing at t is represented by a fact token (t, T, ~o}.","A time map with a set ~\" of fact tokens supports queries about whether it guarantees that a fact ~ holds over an interval [t~, t2] (written as tm_holds((h,t2, ~),~-)). i fact ~ is guaranteed to hold over an interval"]},{"title":"[tl, t2]","paragraphs":["exactly if there is an intervalrt' gl such that (t~ <tl <t2 <t~)A L1, 21 -- -- -- (t~,t~,qo) e ~\" an d if there is no (ta,t4, v') 6 ~\" such that contradicts(~0,~0') A (t~ < ta _< t2).","A precondition ¢ of an action can be represented by a triple similar to a fact token. Since it must be satisfied at the action's starting time t, it is represented by (t, t, ¢). 1This paper uses Shoham's terminology (1994)."]},{"title":"start end action rsubactions constraints effects preconditions acnd","paragraphs":["(an !nteger) (gn ihteger) (a term) (a sequence of terms) (a set of constraints} (a set of triples) (a set of triples) (a variable) Figure 3:"]},{"title":"Edge","paragraphs":["structure Data Structures","In our chart parsing, an action is represented by an edge. Since information on the effects and preconditions of the action represented by an edge must be kept locally, we use the"]},{"title":"edge","paragraphs":["structure shown in Figure 3. An edge's"]},{"title":"start","paragraphs":["and"]},{"title":"end","paragraphs":["values are vertices that are the respective integers representing the starting and ending time points of (the part of) the action represented by the edge. The"]},{"title":"action","paragraphs":["and"]},{"title":"rsubactions","paragraphs":["(remaining subaetions) values are respectively an action description and a sequence of descriptions of actions to find in order to recognize the action. An edge is called active if its"]},{"title":"rsubaetions","paragraphs":["vahm is a non-empty sequence and is inactive otherwise. The"]},{"title":"constraints","paragraphs":["value is a set of constraints on variable instantiation. The"]},{"title":"effects","paragraphs":["and"]},{"title":"preconditions","paragraphs":["values respectively are sets of triples representing the action's effects and preconditions. The"]},{"title":"aend","paragraphs":["(action end) value is a variable used as the placeholder of the action's ending time point. The ending time of the action represented by an active edge is not determined yet, and neither is the starting point of the effects specified by the action's recipe. To keep information on those effects in the edge, fact tokens with the"]},{"title":"aend","paragraphs":["value as their starting time points are used. An unbound time point variable is taken to be greater than any integer and to be less than T. An edge's"]},{"title":"aend","paragraphs":["value is bound to its"]},{"title":"end","paragraphs":["value if it is inactive. Given an edge e and its field"]},{"title":"field, field(e)","paragraphs":["denotes the value of"]},{"title":"field","paragraphs":["in e. Chart Procedures","Given an observed action, chart parsing applies the following procedure: Procedure 1 Let ~j be the description of the j-th observed action. For each recipe with action ~r, and for each most general unifier 0 of ~j and C~r satisfying the constraints Cr specified by the recipe, create an inactive edge from j - 1 to j such that its"]},{"title":"action, constraints, effects,","paragraphs":["and"]},{"title":"preconditions","paragraphs":["values respectively are a j0,"]},{"title":"CrO,","paragraphs":["{(j, T, ~T0)I~T e E~}, and {(j-1,j-1, ¢~0} I¢,\" E Pr}, where Er and Pr are the effects and preconditions specified by the recipe.","Chart parsing proceeds using the following two procedures."]},{"title":"1096","paragraphs":["l'rocedure 2 Let ei be an inactive edge. For each recipe with its a.ction a,., decomposition (71,.-.,%), effects"]},{"title":"Er,","paragraphs":["and preconditions P,, and for each most general unifier 0, satisfying"]},{"title":"constraints(ei)","paragraphs":["and recipe's constrains C,., of"]},{"title":"action@i)","paragraphs":["and 71 such that"]},{"title":"g = (cffccts(ci))O U{(v,T,9::,,.O) I~,\" C ZC,.} and","paragraphs":["7 ) = {(t,t,'¢') rd"]},{"title":"(prcconditions(ci))O I","paragraphs":["~tm_holds((t, t, ¢), g)}"]},{"title":"U{(start(ei), start(ed,GO) l G c/',.},","paragraphs":["without E-P or P-I' contlict, where v is a new variable, create an edge from"]},{"title":"start(ci)","paragraphs":["to"]},{"title":"cnd(ci)","paragraphs":["such that its"]},{"title":"action, rsubactions, constraints, effects, prceonditions,","paragraphs":["and"]},{"title":"aend","paragraphs":["values respectively are"]},{"title":"<Y,.O, (%,...","paragraphs":[",7,~)0, (C,. O"]},{"title":"eonstraints(ci))O, g,","paragraphs":["7), and V. Procedure 3 Let c~ and ei be adjacent active and inactive edges such that"]},{"title":"rsubactions(e~)","paragraphs":["is (71,.-., 7~). For each most generM unifier 0, satisfying C ="]},{"title":"constraints(e~)","paragraphs":["O"]},{"title":"constraints(ci),","paragraphs":["of 71 and"]},{"title":"action(el)","paragraphs":["such that"]},{"title":"= (eFects(ea) u eJy~cts(ed)O and 7)","paragraphs":["= {(t,t,'~b) E"]},{"title":"(prcconditions(e.) Upreeonditions(ei) )OI t.,_holds ((t, t, ¢), C) },","paragraphs":["without F,-P or P-P conflict, create an edge fr<)m"]},{"title":"start(e<,)","paragraphs":["to"]},{"title":"end(el)","paragraphs":["such that its"]},{"title":"action, rsubaetions, constraints, effects, preconditions,","paragraphs":["and"]},{"title":"acnd","paragraphs":["values respectively are"]},{"title":"(action(e,))O,","paragraphs":["(Tu,-.. ,7~)0,"]},{"title":"CO, g, ~P,","paragraphs":["and"]},{"title":"acnd(c,~).","paragraphs":["Now that we have the basic means to eah:ulate the effects and preconditions of the action represented by an edge, we can augment plan parsing to handle the situations described in Section 2. Effect-based action descriptions The fact that the description of the form achieve(P) can specify an action with P as its effect is captured by augmenting Procedures 2 and 3. The set of effects of the action represented by an inactive edge ei that hold at the. action's ending time is /?7/ = {qo I tm_holds({qo, end(ei),"]},{"title":"cnd(ei)), effects@i))}.","paragraphs":["The fact is thus captured in these procedures by checking that"]},{"title":"Ei","paragraphs":["contains P, instead of unifying 71 with"]},{"title":"action(ei),","paragraphs":["if 71 is of that form. The fact that achieve(P) can specify the null action if P already holds is captured by a new procedure that, given an active edge e~ with as its"]},{"title":"rsubactions","paragraphs":["value (achieve(P), 72,.-., %}, creates a new edge whose"]},{"title":"rsubactions","paragraphs":["value is (%,..., %} and whose"]},{"title":"preconditions","paragraphs":["value is"]},{"title":"preconditions (e,~)","paragraphs":["if e~, has P aa its effect and"]},{"title":"preconditions(ca)","paragraphs":["plus"]},{"title":"{end(e.), end(c~), P}","paragraphs":["otherwise. Action-enabling An action-enabling relationship can be captured by a new procedure"]},{"title":"that,","paragraphs":["given two adjacent inactive edges el and e2 such that el's effects satisfy some of eu's preconditions, treaties a new inactive edge with"]},{"title":"action(c2) ,as","paragraphs":["its"]},{"title":"action","paragraphs":["value. .+ State-dependent interpretation A dialogue state is determined by the initial state and the effects of the I)receding actions. The initial state is treated by using a special 'initialize' inactive edge from 0 to 0 with the"]},{"title":"effects","paragraphs":["value representing it. The influence of the qnitialize' edge is propagated by the procedure for treating action-enabling relationships and preference rules referring to precon(litions, a"]},{"title":"5 Conclusion","paragraphs":["A plan l)arsing method has been prol)osed that handles the effe<:ts and l)reeonditions of actions and that parses i)lans hi a manner del)endent (m <tialogue state changes ('ause<t by utterances. The method has been implemented in Prolog. The. imt)lemented progl'am uses an agenda inechanism that uses priority scores on edges to obtain i)re - fi'.rred plans first. The method has been applied to understanding route-explanation dialogues by using the dialogue plan model that takes each action of uttering a word ;~s a primitive and that treats intra- and inter-utterance plans uniformly to treat fragmentary utterances (Kogure et al., 1994)."]},{"title":"References","paragraphs":["Tllomas I~. l)ean and Drew V. McDermott. :1987. Tmnporal data base management."]},{"title":"ArtiJicial Intelligence,","paragraphs":["32(1):1-55.","Kiyoshi Kogure, Akira Shimazu, and Mikio Nakano. 1994. Recognizing plans in more natural dialogue utterances, in"]},{"title":"Proceedings of IGWLP .94,","paragraphs":["pages 935 - 938.","Akira Shimazu, Kiyoshi Kogure, and Mikio Nakano. 1994. Cooperative distributed processing for understanding dialogue utterances. In"]},{"title":"Proceedings of IUSLP 94,","paragraphs":["pages 99:102. Yoav Shoham. 1994."]},{"title":"Artificial Intelligence Techniques in Prolo 9.","paragraphs":["Morgan Kanfmann Publishers.","Candace L. Sidner. 1985. Plan parsing for intended response recognition in discourse."]},{"title":"Computational InteUigence,","paragraphs":["1 (1):1-10.","Mark VilMn. 1990. Getting serious about parsing plans: a grammatical analysis of plan recoguition. In"]},{"title":"Proceedings of AAAI-90, pages 190-197.","paragraphs":["2As an extention to control the applicability of this procedure, the"]},{"title":"effects","paragraphs":["and"]},{"title":"preconditions","paragraphs":["fields respectively are divided into"]},{"title":"main_effects","paragraphs":["and"]},{"title":"side_effect.s","paragraphs":["fields amt into"]},{"title":"preconditions","paragraphs":["and"]},{"title":"prerequisites","paragraphs":["fields. The procedure checks enabling relationships only between"]},{"title":"main_effects","paragraphs":["and"]},{"title":"preconditions.","paragraphs":["aThe use of the initial state also contributes to the efficiency of plan parsing: an input action sequence (:an be shortened by cMculating the current state in the middle of a dialogue and by restarting plan parsing with the current state as a new initial state. 1097"]}]}