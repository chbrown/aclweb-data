{"sections":[{"title":"JAUNT: A Constraint Solver for Disjunctive Feature Structures","paragraphs":["Hiroshi Maruyama","IBM Research, Tokyo Research Laboratory maruyama@ t rl.vnet.ibm.conl Abstract To represent a conlblnatorial nulnber nf ambigu ous interpretatioas of a natural la'nguage sentence efficiently, a \"packed\" or \"factorized\" represeutath)n is necessary. We propose a representatitm that comprises a set of explicit value disjunctltms and constraints hnposed on them. New constraints are successively added for disambiguation, dnrhtg which local consistencies are maintained by an underlying mechanism. We have developed a constraint solver called JAUNT that em bodies this idea. The latest techniques, including"]},{"title":"con straint propagation","paragraphs":["and"]},{"title":"forwa,vl checking,","paragraphs":["are employed ms constraint satisfaction mechauisms. JAUNT also allows an external recta-inference program tn intervene in the constraint satisfaction process in order to control the application of the constraints. 1. Introduction Certain natural language constructs, such as PP: attachnmnt in English, are known to have a combinatorial number of syntactic parses (Church & Patil 1988). For example, sentence (1) has 14 (= Catalan(4)) dif= ferent parses because of the three consecutiw~ PPs: Put the block on t}m floor on the table in the room. (1) Representing the set of parses in a compact way and extracting a correct parse by using such knowledge as A block cannot be on a thmr and on a table at the same time are keys to a practical natural language system. The parsing method of Constraint Dependency Grammar (Maruyama 1990) axldressed exactly these issues. The essential ideas were • to represent the set of parses by a"]},{"title":"constraint network,","paragraphs":["which is emnposed of a set of explicit, vahm disjunctions and constraints imposed on them, • to apply constraint propagation in order to kee I) the constraint network locally consistent, and • to dynamically add new constraints for disambiguation. In this paper, we describe a programming tool named JAUNT that embodies the above ideas. JAUNT is a constraint solver for disjmmtive feature structure% whose constraint satisfaction mechanisms are"]},{"title":"constraint propagation","paragraphs":["and"]},{"title":"forwar~l checking. In","paragraphs":["the next secthm, we show ]tow various ambiguities are represented in our explicit vahm disjunction + constraints scheme. The constraint satisfaction algorithnls S :~ {"]},{"title":"[id=O,cat=v,head=put,gr=root,mod=nilJ, [id=i,cat=np,hoad=block,gr=obj,mod~O], [id=2,cat=pp,prep=on,head=floor, gr={~loc,postmod~},mod={~O,l~}","paragraphs":["],"]},{"title":"[id=S,cat=pp,prep=on,head=table, gr={~ioc,postmod~},mod={~O,l,2~} ], [id=4,cat=pp,prep=in,head=room, gr={~loc,postmodZ},mod={~O,l,2,3~} J };","paragraphs":["Figure 1: JAUNT representation of sentence (l) adapted in JAUNT are explained in Section 3. Section 4 describes the rise /)f JAUNT's recta-inference capability. Section 5 concludes the paper. 2. Explicit disjunction + constraints Let us emmlder sentence (1). In order to simplify the following dlscussimt, we iL~stlnle that the sentence is prepmcessed ms in Figure 1. This preprocessing can be done [W a simple context-free grammar that does not determhm PP-attachments. In the figur% [...] is a featnre structure, {...} is a llst, and {~{...Y,} is a disjunction. \"Phus~ the variable S represents the (packed) structure of sentence (1) as a list of five eom- [}mmnts 1 each of whldl corresl)onds to a V: an NP, or a PP. The grammatical relation (gr=) and the modiflee (meal=) of the three PPs are disjunctions, meaning that one of the wdues shouhl be selected, but that the correct candidate has not yet beat determined. For example, the first PP \"on the floor\" has {~0,1~,} .'~s its and= vahm, which means it can modify either phrase 0 (the verb \"put\") or phrase 1 (the NP \"the block\"). Not all the value combhtations of the disjunctions are allowed. In the above example, if a PP modifies the main verb, the grammatical relation should be loc. In JAUNT, constraints are introduced by addc statemeats. The program fragment (2) applies constraints between the moditlee and the grammatical relation of a pp. for W in S begin addc W.cat==pp & S.(W?mod).cat in {pp,np} =>","W?gr==postmod ; addc W.cat==pp ~ S. (W?mod) .cat==v =>","W?gr==loc; end; (2) []ere~ dots and question marks are operators for me: cessing components of bsts or feltture structurest. '].'he ?The difference between a (lot and a question mark is that a Ac~.s DE COLING-92, NAIVI~S, 23-28 Ao(rr 1992 1 1 6 2 PRec. OF COLING-92, NANIES, AUG. 23-28, 1992 symbols t~ (logical and) an,I => (iml,ly) h~ve their or-dinary logical meanings. In geuernl, ;tny first-order logical formula without qnantifieation is allowed as a ctmstraint. 'Fhe variable W is bonnd to ea~zh V~ NP~ and PP while the addc statelnen|,s lmtweee begin and end are executed. Tim lirst addc statement reaxls ~s ft)ll(,ws: If tile category of W is PP aud the category of the modifiee of W is either PP or NP, then the grammatictd relation of W should be postmod. The applied constraints are represented implicitly by an internal data structure called a"]},{"title":"consltvdnt oeln,o'rk","paragraphs":["(described t;tter). in axlrlititlu~ tam"]},{"title":"p,'ojeclivity","paragraphs":["constrzdut, that modifi~ cation liuks do unt crossover, can be progranmmd ~s h)llows: for Y,X in S begin addc (Y.id < Lid ~ X?mod < Y.Jd) => l?mod <= Y?mod;"]},{"title":"end; (3)","paragraphs":["We have now obtained a packed representation that consists of explicit disjunctions, as in Figure 1, and constraints attached behind them. Each value conl-- bination of the disjunctions that globally sat, isfies tim constraints exactly corresponds to one of the 14 parses of sentence (1). Every context-free parsing ,~lgorit.hnl timt ha.s a polynomial time bound prodnees a pu~cketl represen tation of the parsing results (for example, •"]},{"title":"chart ill","paragraphs":["chart parsing (Kaplan 1973), a"]},{"title":"pa,'si.g mat,'ix","paragraphs":["in the CKY nmthod (Yonnger 1967), and a"]},{"title":".sha,~d-packed-forest","paragraphs":["in qbmita's algoritlun (Tomita 1987)). These representations take advantage of tile regularities of syntactic ambiguities in context-free parslog. For example, sillce it is known that 1~ consecutive P]'s ilave"]},{"title":"Cutalan(n)","paragraphs":["different p~zrses, it is possible to encode all PP-attachment ambiguities by renlemberiug only n and the position of tile PPs (Church ~ Patil 1982). However, once we try to extract ~ single illterpre tation item these representations, we face a prubhml, because such regularities may be vnid when new cun.- straints ~re introduced for disnmbiguati,nl. Consider the application of constraint (4): A verll cannot have two h)eatives. (4) Tiffs constraint viohttes the regularity of the PI' att;miunent ambiguity and tl,ereh)r,~, the Cb'G be-led packed representations nlentioned ailove cannot hall-- tile this new int~rmation properly without modifyiug the grammar significantly. Ill JAUNT~ this constraint is ~pplied by a simple addc statement (5). for X,¥ in S begin adde not(X?mod==Y?mod ~ S. (X?mod) .cat==~ &","X?gr==i°c & Y?gr==l°c) ; (5) end ; lebrrnaliy~ it ha.s beea proven that Constraint Depeudency Grammars: whose rules Ca~ b(! written a~s q.estion mrtrk allows ~ disjunction as its value, w]mre~ a (lot does not. The cllrretlt inl|llelllentatiOll generates more e|flclent code for dots than for question m~rks. S := { [id=O, cat=v ,head=put, gr=root ,and=nil], lid = i, cat=rip, head=block, gr=obj ,mod=O] , lid=2, cat =pp, prep=on, head=f leer, gr={%loc,postmod~,},mod={%0, I%) ] , [id=3, cat=pp, prop=on ,head=t able, gr={%inc,postmod~},mod={%0,2~} ] , lid=4, cat=pp, prep=in, huad=room, gr={~Ioc, postmod%}, mod={%0, I, 2,3~} ]"]},{"title":"};","paragraphs":["Figure 2: JAUNT rel,resent~tion of sentence (1) restricted f(irms of JAUNT program: have ~ weak generativr power strictly greater than that of CI\"G (Maruy~ma 1991), This implies that certain types of pa~rsing results can be represenu..d by constraint networks but not by CFG based represmttatioos. Sen and Simmons (1988) proposed"]},{"title":"syntactic 9~phs","paragraphs":["and discussed the axlvantagos of having explicit, dis junctions in a packed data structure. Their represeu tation is similar to ours in tile seuse th;tt they have con~trahlts attached to the explicit disjnnctive data structure. However, they d. uot diseusa how to ~rp. ply disam[liguation knowledge in order tn reduce the ambiguity effectiwqy, lu JAUNT, the underlying constraint saris[action algorithm removes im:onsistmdl val-IteS ~cnd keeps tim constrai/it uetwork locally consistent. Consider, lot example~ the application of the new con straint (6): An object {:annot In! on two distinct objects a,t the same tin,e. (6) This constraint is written a~s follows: for X,Y in S begin addc X.prap~=on ~ Y.prep==on &","X?mod in {pp,np} => X?mod != Y?mod;17) end; After this coustraint [ta.s beet, evahl~ted~ tile and attribute of the t'P \"on the t~ble\" becomes {~0,2Z}, n~ strewn it, Figure 2, because the vMue 1 is locally inconsisteut ;mcnrtling to the coostraints applied su far, and central, pneti( il,ate ill any of the remaining seveu re;tdings. There },ave been several ~Lttenlpts to incorporate dis junctions in uniiicatinu-ba.sed grammars re.g. Karl tuoen 1984). Constr.'tints ;ere introduced by ~t unification between two disjuuctiw.' feature structures. A nnificatio, succeeds only if there are combinations (ff wducs of the disjunctions that s~tisfy tile equality con straints implied by the u,lificatio.. It, order to clarify the exl,ressiw~ power of fe~ture structures with general disjunctions, Kasper ~ Rounds (1986) defined a logic-be-led notation called FM1, A fornlula in FMI, can be rewritteu as an addc statement in JAUNT, and hence, constraints expre~ed hy a unification can also be expr~ssed in JAUNT. In ~|dition, in unification-based grammars, the nnly basic predicate is equality, aud other useful predicates, such em inequalities and set inclusion/membership, are diflicuh to represent. In","~If the secottd PP \"on tile table\" modifies the NP \"the block,\" the first PP \"on tim riot,r\" ha.s no legal modifiee~. ACRES DE COLING-92, Nam'l~s, 23-28 AOUX' 1992 1 1 6 3 I'koc. OV COLING-92, NANTES, AU(L 23-28, 1992 JAUNT, inequalities and set operations are built-in, and user-defined predicates are also allowed."]},{"title":"3. Constraint-satisfaction algorithm","paragraphs":["Since every disjunction in a JAUNT program has a finite number of choices, its satisfiability problem can be formulated as a constraint satisfaction problem over a finite donlain (sometimes called a"]},{"title":"consi.~tenl-htbeling problem","paragraphs":["(Men[snarl 1974)). Much effort has been de voted to developing efficient algorithms for this prob lea. Two such algorithms are employed in JAUNT. Ore, is the"]},{"title":"constrainl propagation","paragraphs":["algorithm (Mackworth 1977), which is activated when a new constraint is added by addc statements. The constraint propagation algorithm runs in polynomial time, and eliminates locally inconsistent vMues from the choice points and propagates the results to the neighboring constraints. The constraint propagation algorithm usually reduces the size of the search space significantly. The other algorithm used in JAUNT is the"]},{"title":"forward-checking","paragraphs":["Mgorithm (Haralick &Elliott 1980), which is triggered by the execution of a special find stat~ meat. It is essentially a back-tracking algorithm, but it prunes unpromising branches whenever temporal choices are made, thus significantly reducing the size of the remaining search space. This section describes in detail the constraint propagation Mgorithm used in JAUNT. Re'0ders are referred to Hentenryck (1989) for the forward-checking algo-"]},{"title":"rlthm. 3.1 Internal","paragraphs":["representation of"]},{"title":"constraints","paragraphs":["Bob)re describing the Mgorithm in detail, let us explain the internal representation of the constraints, hi a compiled [nodule of a JAUNT program, a disjunction is represented by a data structure called a"]},{"title":"Choice Point (CP).","paragraphs":["A CP maintains a list of ptJssible values (called a"]},{"title":"domain)","paragraphs":["at the time of program execution. When a new constraint is added by a addc statement, the constraint is represented internally ms a"]},{"title":"conslrrint ms[lisa","paragraphs":["For example~ assume that W is bound to"]},{"title":"[gr={~loc ,posttaod~}, mod--{Y,0, lY,}].","paragraphs":["W?gr and W?mod are represented internMly a.~ CPs whose domain size is two. Then, when the constraints (2) are evaluated, a new two-dlmensional constraint matrix is created between the two CPs, as shown in Figure 3. Each dimension of the constraint matrix corresponds to a CP. The elements indicate whether the particnlar combination of the CP vMues is legal (1) or illegal (0). For example, W?gr=loc and W?mod=O satisfies the constraint and hence the corresponding element in the matrix is 1. If another adds statement is then executed declar-ing that ttm value combination of W?gr=pontraod and W?mod=l is illegal, the corresponding element in the matrix is changed to 0, yielding the matrix shown in Figure"]},{"title":"4.","paragraphs":["W?g( W?rnod Figure 3: Constraint matrix","W?~lr W?rnod [ {~IoC pOS Figure 4: Updated constraint matrix Suppose that the executioll of art adde statement referring to 7t different CPs"]},{"title":"XhX2,...,Xn","paragraphs":["reveals that the value combhtation <"]},{"title":"xl,x~,...:x,~","paragraphs":["> is illegal. JAUNT first locates an n dimensional con straint matrix connected to"]},{"title":"X1,X2,...,X=,","paragraphs":["and set its element corresponding to the value combination < xi, x2, ..., x,~ > to 0. If there is no such constraint matrix, JAUNT creates a new one whose elements are all 1 except for the element of < xl,x~,...~x,, > that is set to 0."]},{"title":"8.2 Constraint propagation","paragraphs":["The ba.sie idea of constraint propagation is to re mow~' locally inconsistent values from the, choice points and to reduce their domain size before a back tracking search is performed. [n the example ~d)ove, let us consider the row af W?gr=postraod in the constrah[t matrix. When i~?gr=postmod~ the elements of the matrix are zero, whatew~r value W?mod Lakes. This means that there are no glnbal solutions with W?gr=postmod, and therefore this value can be safely removed fronl tim domain of the CP W?gr. Similarly, Id?rnod=l ca.n be removed from the domain of the CP W?raod. In general, when a particular row or column (or plane or hyperplaue, if the dimension is greater th~n two) contains all zero elements, the corresponding vMne zl of CP X can never participate in ~ solutimt (see Figure 5). Therefore, a'i can be eliminated frmn the domaitt of X. Whenever a constraint matrix is updated~ JAUNT searches for a. hyperplane whose ele~ ale/Its are all zero aud relnoves the corresponding v~thle from its domain. This may updrrte other constraint matrices conllected to l he C.P~ and may cause rabies in other CPs to be elhninated. Thus, updates are prop-agated ow~r the network of constraints until the entire network reaches a stable state. For every hyperplane in a constraint matrix, JAUNT ACTUS DE COLING-92. NAbrrES, 23-28 AO(Yr 1992 1 l 6 4 PROC. OF COLING-92, NANIES, AUG. 23-28, 1992 X\\Y ... xi 0 (I 0 ... 0 Figure 5: Locally innonsistent value a:i suppo.[~3[] Numtmr of I's ill the plal~"]},{"title":"[ ~ 3/~ ~ suppo~[Xl[l","paragraphs":["Figurt+ 6: Support keeps the current number of t's on that plane, called the support (see Figure 6). When a certain element of a constraint matrix apl)ears to be inconsistent a,s a result of the evaluation of addc statement, the curre sponding support in each dimensiun is decremented. When a value in a CP is removed by constraint prop station, the carrespondlng hyperplaue of every con straint matrix connected to the (11' is removed, attd the result is reflected i~( all tt~e support values in the matrix. This algorithm is a uatnral extension of Mohr and Henderson's arc-c(msistency algorithm (Mohr & Henderson 1986) for allowing n:ary constraints. The cmnputathmal complexity of our constralut propagation algorithm is hounded by O(eIMD, where"]},{"title":"IMI","paragraphs":["is the siz,~ of the constraint matrices and e is the number of the cunstraint matrices, becattse at lemst oue element in st)me matrix is changed to 0 from I for every iteration of constraint propagatiom If the con str~ints are Iocal~ that is, if the arity of each ennstraint is bounded by a small integer, this time bound is a polynomial of the number of disjunctions. Our algorlthnr tries to maintain h,cal consistency ix( the sense that it runs(tiers only one eonstr+dnt ma trix at. +t time. This is a generalization of the notion called am consistency (Mackworth 1977) or pair-wise cousisteucy, and is equlva]ent tn the flrst two steps of Ka.sper's (1987) successive aptnvximatimL Algo rithms for achieving more global consistency by look: ins at mnltlple constraint matrices are possibh+, but as Carter (1990) argues in his paper on the experimen. tal Propane parser, once pair-wise consistencies have been achieved, peffurnling a backtrack search is usually more efficient than using higher-level consistency algorithms. In JAUNT, a forward:checking algorithm, which is far better than the traditional backtracking algorithms (Haraliek & Elliot 1980), is provided for generating global solutions, if necessary, although th[~ intended use of JAUNT is to combine constraint prop agation with the recta-inference described in the uexl section~ rather than t() perfornl a search. There hay,' t~en attl!nlpts to formulate natural language pro,:essing as a cunstraiut satisfaction problenl with broader don~ains (fl~r example, the Herbraud domain). CIL (Mukai 1988) and cu=Pmh)g (Tsuda, ltasida & Sirai 1(.189) are examples of such atteuipts. There is a trade-off between the expressive power and the COmlmtatiunal complexity, aml we argue that linite donlaius have sutticient expressive power while retain: ing the couqmtational eflicieucy implied by the algu+ rithms described above. 4. Meta:inference A cunsiM,(~nt-]at)elliLg pr()bl(!nl uLay or nlay not have a solution. If it ha_s role, it is most probable that there are multiple solutions. In fax:l, it+ the glven constraints are lint 'tight' enough tu narrow down the uumber uf sohltitlliS to (Hit? or a few! the prohhml Ill~l,y have an eX ponential number of solntions. This situatlon is common hL natural language processing. Strict grammars canse analysis failures for grammatical sentelt{;(~s~ i)n the other hand, lnose graulmars pruduce a combinato rially explosive number oF parse trees fin' certain types of sentence. 'lb avoid this situation, cnnstrahits shouhl be dynamically added aud remuw~d according to the size of the stdul.iut( space+ hi uther words, a constraint solver shunhl tm provided with a means of watching its own infl~rence process and changing its strategy ac= cord(us to tim observati<m. To set>purl the metaAnference capability~ JAUNT provides the following built in functions: 1. incousistentp() ... Non-NULl, wilen JAUNT detects incDltslstencies bf~tweell coltstraints 2. saveS(ate() ... Save the current status of constraint sat(slant(us g. loadState() ... lLestore the saved status of con-. straint satisfactiuu. lu JAUN'I'~ tire state of the constraint:satisfaction process is deJined ms the set of all choice points and all cosstraint nlatrices. Oth,~r statuses bUlC]I mS global aud local variables, the prograln couuter+ ;utd the coutrol stack are lint saved I sn applications (If cmlstraints nan be uadone without distilrbing the c<uttrul ll.w. Meta inh~renc,~ is nonletlntes perh~rmed in an exter hal nlodule. JAUNT has interqm)cess crassus(cation primitiw~s hmm~d on UNIX so<:kets. With these met;uinference capalfilities, an independent inference process timing ext.ernal knuwh~dge can tilt)ill(or and iIiterveneln a JAUNT progra.nt. If it detects an inconsistency, it instructs the JAUNT i>rogram to go b.'u:k tu the previous inferenc[~ state and try another set of constraints; if it finds thai the solution spa~:e is not small enough+ it may giw~ new constraints from its own knowledge source. By separating the rneta-inference module from tile object-level JAUNT program, modularity [)f knowledge is ;whieved. As an application <>f the meta:inference capability, let us describe the interactive Japanesp parser of the Japanese t<FEnglish m;u:hine translation system JETS (Maruyama, Watanabe, & Oginn 1990). The systmn structure is shown in Figure 7. Tim morphological A(:rl~s BE COL1NG+92, NANTES, 23-28 Ô(JT 1992 1 1 6 S Pron. oi: COLING-92, Nm,n'zs, AUG. 23-28, 1992 Fignre 7: Analysis p~rt of JETS [~ord_id=O, string=\"ANATh\", modifieeffi{~1,2,3,4~}, lex={~, [part_of_speech=pronoun, sf={hum}],","[part _of _speech=noun, sf={loc}] %), Figure 8: Input feature structure analyzer analyzes an input sentence using a type-3 grarl'lln&r and creates a feature structure that COlltalus disjunctions for lexieal and attachment ambiguities (Figure 8). The syntactic analysis program written in JAUNT applies grammatical constraints based on Constraint Dependency Grammar to these choice points and sends the result to a user-interlace running on a separate machine. The amblguons choice points (those with domain size> 1) are highlighted on the screen, and the end user can select an appropriate value for some of them. This information is sent back to the JAUNT program through the inter-process communication channel and applied in the form of new constraints. This iteration is written in JAUNT as fedlows;","Uif := opon(Client~ame,\"socket\") ;","while true begin send(U/f,S) ; X := read(Uif); if X==goAhead then break; saveStato() ; addc S. (X.id)?mod==X.mod; if /nconsistentp() then begin","send(Uif,\"inconsistency detected\") ;","loadStateO ; end;","end;","Thus, h* JETS, the end nser acts as an external know[","edge source to guide the inference process of the pro-","gram. SHALT2, an experimental English-to-Japanese machine translation system currently being developed at IBM's Tokyo Research Laboratory, has a similar system structure (Nagao 1990). Instead of user interac-tion, an external example ba.~e built from an exist-ing corpus is used for resolving attachment amblguities in SHAUF2. Thus, clear modularization of general syntactic/semantic knowledge from domain-dependent example-based knowledge is achieved. 5. Conclusion We have described a constraint solver for efficiently processing ambi~nlties in natural language sentences. Disambignation is dntm by dynamically adding new constraints while the constraint satisfaction algorithm mainteoius local consistency. The system is actually bnldemented and used in two macl6ue translatiun systems. References 1. Carter, I}., 1990. \"Efficient Disjunctive Unification for Bottom-Up Parsing,\" COLING '90. 2. Church, K. and Patti, R., 1982 \"Coping with Syntactic Ambiguity, or llow to Put the Block m the Box on the Table.\" Arne*-tcan d. of Compulattonal Linguistics 8. 3. llaralick, M. and Elliott, G. 1,., 1980, \"lnerea~sing Tree Search Efficiency for Constraint Sittisfaction Problems,\" Arhficial Intelligence 1~. 4. llentenryck~ P. V., 1989, Constraint Satisfaction In Logic Programming, MIT Press. 5. Karttunen, L., 1984, \"FcaUtres and Values~\" COL1NG '8q. 6. Ka.sper, R. T., 1987, \"A Unification Method for Dis.Inactive Feature I}escriptions,\" 25lh ACL Annual Meeting.","7. Kasper, IL T., and Rounds, W. C., 1986, \"A Logical Semantics for Feature Structures,\" 2Jth ACL Annual Meeting.","8. Mackworth~ A. K., 1977, \"Consistency m Networks of ll.elation,\" Artificial lntelhgence 8.","9. Maruyama, 11., 1990, \"StmlcUtral l)isambiguation with Constraint Propagation,\" 28th ACL Annual Meelin 9.","10. Maruyama, H., 1991, \"Constraint I)ependency Gram mar and Its Weak Generative Capacity,\" Advances in Software Science and Technology 3.","11. Maruyama, H., Watanabe, 11., and Ogino, S., 1990, \"An Interactive Japanese Parser for Machine 'lYansla-tion,\" COLING '90.","12. Montanari, U., 1974, \"Networks of Constraints: Fundamental Properties and Applications to Picture Pro cessing,\" Information Science 7.","13. Mohr, R. and llenderson, T., 1986, \"Arc and Path Consistency Revisited,\" Artificial Intelligence 28.","14. Mukai, K. 1988, \"Partially Specified Term in Logic Programming for IAnguistic Analysis,\" International Conference on Fifth Generation Computer Systems, Tokyo.","15. Nagao, K, 1990~ \"Constraints and Preferences: In-tegrating Grammatical and Semantic Kimwledge for Structural l)isambiguation,\" Pacific Rim International Conference on Al, Nagoya.","16. Se,, J. and Simmons, R. 1988, \"Syntactic Graphs: a Representation for the Union of All Ambiguous Parse Trees,\" Computational Linguistics 15","17. Tsuda, 11., llasida, K., and Sirai, I1., 1989, \"JPSG Parser on Constraint Logic Programming,\" 4th ACL European Chapter.","18. Younger, D. H., 1967, \"Recognition and Parsing of Context-Free Languages in time nO, '' Information and Control 10. ACRES DE COLING-92, NANTEs, 23-28 Ao~r 1992 I 1 6 6 PRec. OF COLING-92. NANTES, AUG. 23-28, 1992"]}]}