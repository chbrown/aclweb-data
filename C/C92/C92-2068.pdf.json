{"sections":[{"title":"Quasi-Destructive Graph Unification with Structure-Sharing* Hideto Tomabechi Carnegie Mellon University 109 EDSH, Pittsburgh, PA 15213-3890 t0mabech@cs.cmu.edu Abstract","paragraphs":["Graph unifi(:ation remains the nlost expensive part of unificatiou-b~Lsed grammar l)arsing. We fl)cus on (Hie 81}ee(l-u 1) elelltellt ill the design of llllifiea-tion algorithms: avoidance of copying of umao(lifled sul)graph.s. We propose a method of attaining snch a design through a nlethod of structnre-sharing which avoids log(d) overheads often associated with structure-sharillg of graphs without any use of costly dependency pointers. The proposed scheme eliminates redundant copying whih~ maintaining the qua.sidc,qtructive scheme's ability to avoid over copying and early copying eomlfined with its ability to handle cyclk: structures without algorithnfie additions."]},{"title":"1 Motivation","paragraphs":["Despite recent efforts in improving graph unification algorithms, graph unification renlains the most expensive part of parsing, both in time and space. ATR's latest data fi'om the SL-TRANS large-scale speech-to-speech translation project ([Morimoto, et al, 1990]) show 80 to 90 percent of tot~ parsing time is still consumed by graph unification where 75 to 95 percent of time is consumed by graph copying funeti(ms. 1 Qu~si-Destruetive (Q-D) Graph Unification ([Tontabeehi, 1991]) was deveh)ped as a fiLst variation of non-destructive graph unification based upon the notion of time-sensitive 'qu~mi-destruction' of node structures. The Q-D algorithm was proposed I)~Lsed upon the following m:cepted obserwttion about graph unification:","Unification does not always succeed.","Copying is an expensive operation. The design of tit(', Q-D scheme was motiwttcd by the following two princil)les h~r frost gral)h unification ba,sed upon the above observations: • Copying should be performed only for successful unifications. • Unification failures should be found as soon as possible. *This research wa.8 (lone while the author was ~ Visiting Research Scientist at ATR Interpreting Telephony [O~search Laboratories.","lBased on unpublished reports from Knowledge itnd Data Processing Dept. ATR. The observed tendency was that sentellCCS with very long parsing tillle requiting a large Ii|lltll~t~r of unification calls (over 200l} top-level calls) coll811lllcd extremely htrge proportion (over 93 percent) of total paraing time ft~r graph unification. Similar data tep0rted in [Kogure. 19901. and eliminated Over Copying and Early Copying (as defined in [Tomabechi, 1991] 2) and ralt about twice the speed of [Wroblewski. 1987]'s algorithm, a In this pal)er we proi)ose another design principle f(n' graph unification bmsed upon yet another accepted observation that:","Unmodified subgraphs can be shared. At lemst two schelnes have been proposed recently ])a.~ed Ul)OU this observation (namely [Kogure. 1990] and [Emele, 1991]); however, both schemes are I)ased upon the increlllent'al Col)yiug sehellle all(l ~-LS ([escribed in [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi'om Early Copying as defined in that article. This is I)eeause, when a unification falls, the copies that were (:reated up to the point of failure are w~Lste(l if copies are created increment;ally, By way of definition we would like to categorize the sharing of struetul'eS in gral)hs into Feature-Structure Sharing (FS-Sharing) ~nd Data-Structure Sharing (DS-Sharing). Below arc our definitions: • Feature-Structure Sharing: Two or more dis-","tinct i)~,ths within a graph share the same sub-","graph by (:onwwging (111 the same node equiv-","alent to the notion of structure sharing or reen-","lrancy in linguistic theories (such ~ in [Pollard","and Sag, 1987]). • Data-Structure Sharing: Two or more dis-","tinct graphs share the same subgral)h by con-","verging nil the same node the noti(m nf 2 Namely. • Over Copying: Two dags ate created in order to create","one new dag, This typically happens when Col)its of two","input d~tgs are created prior to a destructive unific~Ltion","operation to build one new dag. • Early Copying: Copies ar~ created prior to the failure","of unification so that copies (:reltted since the beginning","of the unitication up to the point of failure are wasted. Wroblewski defined Early Col)ying as follows: \"The argutnent dags are copied be/t~te unification started. If the unilication fails then some of the Ct)l)ying is wasted effort\" attd restricts early copying to cases that only apply to copies that are created prior to a unification. Our definition ()f Early Copying includes copies that ~rc created during a unification and created up t() the point of fltilur(~ width were iltt(!ow~red by Wroblewski's definition. 3 Recent (~xp(~rilnents COlllhlctt~d ill the Knowledge all(] Data Pro(:esniug Dept. of ATR shows the original Q-D algorithm COllsiatelltly rllllS lit ~tt~out 40 ])q~rctrl|t ~ff the elal)sed tillle uf Wroblewski'8 algorithm with its SL-TRANS large-scale upoken-languag,~ ttansl~ttlon system (with over l(t00{I grammatical gral)h nodes). ACRES DE COLING-92, NANTES, 23-28 AOt~T 1992 4 4 0 PROC, OF COLING-92, NANTES, AUG. 23-28, 1992"]},{"title":"straeture-sharing","paragraphs":["at tim data structure level. [Kogurc, 1990] cldls Coltying of sui:h strltctures"]},{"title":"Redundant Copyin 9.","paragraphs":["Virtually all gral~ll-lutitication alg(n'itlinl,,; suptmrt FS-Sh~triug and some SUliport DS-Sharing with vary-ing levels (if overhead. In this lisper we proltOSl~ ~t sclienle of graph unification I)tmed UllOn a qu;~sidestrtt(:tive gratth uniti(:ati(m inetlloll that attains DS-Sharing with virtually no overh(',ad for structure-sharing. Henceforth, in tills palter, structltre-sharing refers tit DS-sllariug unless otllerwise n(ited. Wc will see that tfic iutroducti(m of strlu:ture-sliarilag to qua~si-destructive imification art;tins another two-fold increase ill rim tiluc spired. The graphs llamdled in the scheme (:;tit lie auy dirc(:ted grai)ll and cycli(:ity is llaudled without any algorithmic ;tdditions. Our design princiitles for achieving structlu'C-sharing in tit(', qlta.si-destructive scllellU~ are: • Atomic and Bottom nodes can be shared 4","Atomic nodes can lie sltarcd sahdy since they","tlever cli~l, llge their wdues. B(Ittolll llodl!s Call It(!","share(l 5 sittce bottom nodes are always fl)rwal'ded","to somc other uo(Jes wllcn they unify. • Complex nodes can be shared unless they","are modified- conq)lex nodes (:all bc COllSld-","ercd modified if they ~tre a target of the fitrward-","ing operation m' if riley received the curreut ad-","ditiml of comltlcment arcs (into COml)-ari:-list in","(pia,si-destructive sclmme). By designing an algorithm ba.sed Ult,m these pril> (:il)les for strlu:ture-sliarillg while retaining the quasi-destructive nature of [Totnat)echi, 1991]'s algoritllnl, our scllmnc eliniinates l{,cdlnt(tant Cllpying whih~ elinlinating botll Early Copying auld Over Copying."]},{"title":"2 Q-D Graph Unification","paragraphs":["We Woldd first like to describe tlle qu;Lsi-destructiwe (Q-D) graph unilication schenle which is the lnLsis of our s(:henl(,'. As a data structltrl~, at nolle is rcpre sentcd with live fiehls: type, arc-llst, comp ark-list. fm'w~u'd, (:oily, and geueration. 6 The data-structure for an at'(: has two liclds, qabel' and 'value'. \"Lot)el\" is an atmnic symt)ol wllicli labels tile ;u'e. and 'wdue\" is a llointer to a llo(le structure. The central notion of tile Q-D algm'itlun is tile del)eudency of the retiresentational (:ontcnt on the glob~d timing clol:k (or thc global counter for tlic currcnt generation of lUlific;~tions). Any luodilic;~tiol~ made to coml)-arc-list, forward, or i:Olly rid(Is during one top-lcw:l uniticati(m (:au bc inwdidated by (me in- (:renlent otmration inl tile global timiug counter. COIl tents of the (xmlp-arc-list, forward and (:opy fields arc 'IAtomic lto([l~8 ;ire IlodeH (halt reprea(~llt atoluic vcdue8, lie( loin nodes are llo{|e8 that repreuellt variabh*. ~As long as the unific~ttion Ol)er,~tion is the only operation to nmdify graphs. 6 Note that [Tonlabechi, 1991] used sellarttte lltark fields fin COml)-;trc-liat, forward, fill(| copy: (:urrently however, (}lily f}lltt general(kin mark is used for adl three fiehls. Thanks are due to Hidehiko M~U,uo of T,)yo Informattion Sy,tcms (TIS) for suggesting thin. NODE","type + ............... +","are-list + ............... + comp-nrc-lint + ............... +","~orward IRC + ............... + + ............... +","copy I label I + ............... + + ............... + generation I value I ............... + ............... ÷ Figure 1: Node and Arc Structures resl)cctc(l ,rely wlten tile ge.neration mark of the lml'- ticlll~u' node nuttches tile current glob;d comat.er wdue. Q-I) graph unificatiola ham two kinds of arc lists: 1) ar,:-list and 2) colnt~;u'c-list. Arc-list (:Ollt~tins the arcs that are p(!rln;tu(!nl (i.e.. ordimLry gral)li arcs) and Cillnp-arc list contains arcs that are rally wdid during one top-hwel graph unitication oper;d, ion. Tim algorittun also uses two kintls of fi)rwardlng links, i.e,, l)(!rttlalal!nt ;IAl(l t;(!llll)Ol'&l'y, i ll(!rlll~l,llellt forwar(fillg link is the usual fm'warding link ftnmd in ottler' ;d-goritfilns ([Pereir~t, 19851, [Wroblewski. 1987], ctc). Telnl)orary forwarding links arc links tlud. arc only wdid during onc top-level unilic~tti(m, Tlic currency IIf the temporary links is (letermiued by matching the emlteut of tim generati(nl field for the links witll the gl(ibal (:ounter; if they nutt(:ll, the content of this tiehl is respect[~d 7. As in [Pereira, 1985]. tile Q D ~dgorithln lla.S tltree types of uodes: 1) :atonfic. 2) :lie(torn 8, and 3) :conqth!x. :atOllli(: tyllc nodes repres(mt at(nni( synll)ol values (such ;~s 'Noun'), :bet tom type n(Jdes are variables and :(:()lttl)lcx tylac nodes ~l.re Ilo(les that have art:s i:ol[litlg (lilt of thenl. Arcs are stored in the m'cqist tiehl. Tile atomic vahl(! is also storc.d in the m'c-list if the node tyttc is :at,imil:. :llottom nodes succeed in unifyiug with nny uodes and the result of lint(it:alien t~kes tim type ~md the value of the node tlutt the :bottona nI)de w;m unified with. :atonli(: nodes succeed in unifying with :btIttona nodes or :at(lllliC llO(li~s with the mune vallle (Stilted in the arc-list). UnificatioD of an :atomic uode with a :co]tll)lex llOde illlllte([iatcly filJls. :cottll)lex taodes site(reed in unifying with :bottolit nodes or witll :(:OUll)lex trades whose subgrlqdls all unity. ° Figure 2 is the central qllmsi-,lestructlw~ graph unifi(:ation algorithm and Figur('. 3 is the dcrcfel'encing 1° flulction. Fig-lit'(? 4 shows the algoritlill; for (:ollying ttilfl(!s all(1 ~Lrcs (called from lmify0) wllih~ respecting the (:Ollt(mts of ~a~4 \"~x~ist~","7~1~ do II(It ]l~tVe ~t separate field for temporary forwtLrding links; instead, we desigllat(t tile integer wdue 9 to repreuent a permanent f,~rwatding llnk. We Ht~trt incrementing the global COUltter f[Olll 10 ,() whellever the gener;tti(ut lu~trk i8 lIO| 9, the integer vahle 11111~4t e(ltla] the globad COllltter v;tllle to reulmCt the forwaxding link.","8 lqottom i8 called leaf in Pereira'u algorithm.","9Arc wtlues are ,'always It(Idea aLnd never synlbolie V~dlle8 because :atomic *uLd :bottom nodes lilly lie (or ]l(}cO]ll(}) poillted to by luultiph: arl:x (i.e, FS-Sh~ring) depemlil~g on gt0annlar COllHtr.'killtg, and we do not want arcu to (:oltt~tln terlnin~d atomic V~lleO. l°Derefi~rel|Cillg i8 till opera((loll to recllrsively traw~rae f.rw;trding links to return the target mille of forwarding. AcrEs DE COLING-92, NANTgS, 23-28 AO~\" 1992 4 4 1 I'ROC. OF COLING-92. NAmES, AUG. 23-28, 1992 QUASI-DI~qTnuCTIVE ~RAPI[ UNIFICATION ] FUNCTION unify-dg(dgl,dg2}; result ~ catch with tag 'unify-fail","calling unify0(dgl,dg2): increment *unify-global-counter*: ;; starts front 1(} 11 ret urn (result); END; FUNCTION unify0(dgl,dg2); if '*T* = unifyl(dgl,dg2); THEN copy ~ copy-dg-with-coml)-arcs(dgl); return(copy); END;","FUNCTION unify1 (dgl-underef,dg2-undercf):","dgl ~ derefercnce-dgldgl-underef);","dg2 ~ dereference-dgl dg2-undercf }:","IF (dgl.copy is son-empty)THEN dgl.copy ~ nil; :; cutoff ullt:ltrrent copy","IF (dg2.copy is non-empty) THEN dg2.copy ~ nil;","IF (dgl = dg2)I~THEN return('*T*);","ELSE IF (dgl.type = :bottom) THEN forward-dg( dgl,dg2 jt empor asy); return('*T*);","ELSE IF (dg2.type = :bottom) THEN forward-dg( dg2,dgl,:tem porary ); rcturn('*T*);","ELSE IF (dgl.type = :atomic AND","dg2.type = :atomic) THEN","IF (dgl.arc-list = dg2.arc-list)13THEN","forward-dg( dg2,dgl,:tempor ary}:","return('*T*);","ELSE throwt4with keyword 'unify-fail;","ELSE IF (dgl.type = :atomic OH","dg2.type = :atomic) THEN","throw with keyword 'unify-fail;","ELSE shared ~ intersectaxcs(dgl,dg2); forward-dg( dg2,dgl,:t empor ary ); 15 FOR EACH arc IN shared DO","unifyl(destination of","the shared arc for dgl,","destination of","the shared arc for dE2); new ~ complementarca(dg2,dgl); 16 IFlT(dgl.comp-arc-list is non-empty) THEN","IF (dgl.generation = *unify-gloh;d-counter*) THEN","FOR EACH arc IN new DO","push as['. to dgl,comp-arc-list,,","ELSE dgl.colnp-arc-list ~ nil: ELSE dgl.genera.tion ~ *unify-glohal-couttter*:","dgl.comp-arc-list ~- new; return ('*T*); END: FigLure 2: The Q-D Unification Functions Tit(' functions Contl)lenlelttarcs((lgl,dg2) and In-119 indicates a l)ermanent forwarding link. 12 EquM in the 'eq' 8ellse. Bec~tuae of forwarding altd cycles, it is possible that dgl and dg2 are \"eq'. 13 Arc-list contains atomic value if the node is of type :atomi(. 14Catch/throw coastxuct; i.e., immediately return to unifydE. lSThis was performed ~dter FOR EACH letup in [Tonrahechi, 19911 which couht haw~ c~.uacd it prtddem writ a sttccessful cyclic call. Thanks are due to Marie Boyle of University of Tuebingen fur suggesting the change. 16Colnplementarcs(dg2jlgl) was called before unifyl recursiena in [Tomabechi, 1991], Currently it is moved to after all unifyl recuraions successfully return. Thanks are ;dso due to Marie Boyle for suggestiug this. 17This check was added after [Tomabechi, 1991] to avoid over-writiltg the conlp-arc-list wll(~ll it is wrltt(,it more than once within one Ulfify0 call. Thanks are duc to Peter Neuhaus of Oniversitiid Karlsruhe for reporting this l)roblem. C;RAPll NODF\" DF',F'F'FERF'NF'ING ] FUNCTION dereference-dg(dg): f(>rward-dest ~ dg.forward; IF (forward-dent is non-empty) THEN","IF (dg.generation : *unify-global-counter* OR","rig.generation = 9) THEN","dereferetu:e-dg( for ward-dent );","ELSE dE.forward ~ nil: :; make it GCable","retura(dg)', ELSE return(rig); END; Figure 3: The Q-D Dereference Function t('rsc('tarcs(dgl,dg2) return the sct-diff(,renF(̀\" (the arcs with labels that exist in dgl but not in dg2) and intersection (the arcs with labels that exist both in dgl and dg2). During th(\" sct-difl'erence and sctiutersection otlera.tiultS, the (,ulttent of colnp-arc-lists art\" respected ms parts of arc lists if the genera.tion mark matchs the current va.lu(, of the globa.l tinting counter. Forward(rig1, dE2, :forward-type) puts (tg2 in tile forwa.rd field of dgl. If the keyword in the fun('tion call is :temporary. the eurrev.t valu(, of the *unify-glob;d-counter* is writtea in the generation fiehl of dgl. If the kcyword is :perman(,nt, 9 is written in the generation fiehl of (lgl. 18 The temporary forwarding links are necessary to handle rcentrancy and cycles. As soon as unification (at any level of r(,cursion through sha.rcd art,s) is performed, a. teml)orary forwarding link is made from dg2 to dgl (dE1 to dE2 if dgl is of type :bottom). Thus, during unification, a. node already unified by othcr recursive calls to unify1 within the same unify0 c',dl has a temporary forwarding link from dg2 to dE1 (ur dgl to dE2). As a result, if this node becomes an int)ut argument node, derefcrencing the node causes dgl a.ud dg2 to lleconte tile Salll(, llo(lc attd unification immediately succeeds. Thus, a subgraph below an Mrea(ly unified nude will not be checked inore than once even if an a.rgument graph has a. cycle. 19 [ QUASI- DFS̀TI1UCTIVF, COPYING ]","FUNCTION copy-dg-wit h-conq*-arcs(dg-underef):","dg ~ dereferencc~dg(dg-underef};","IF (dg.copy is iron-empty AND dg.copy.generation 2n ~ *unify-gloh',d-countcr*) THEN ret urn(dg.copy); 21","ELSE IF (dg.type = :atomic) THEN ncwcopy ~ create-node(); 2~ newcopy.type ~ :atolltic; newcopy.arc-list ~ dg,arc-list: Itewcopy.gel|eratiolt ~ *tinily-global-counter*; dg.copy ~ newcopy; ret urn(newcopy);","ELSE IF {dg,type = :bottom) THEN ltewcopy ~ creatc-nodel ); newcopy, type 4~ :hottoltl; I~ewcopy.gem!rlttioll ~ *unify-global-counter*; dg.copy ~ newcopy; ret urtt( newcopy )i","ELSE 18permanent forwardings may be needled by gr~tlltlltar COlllpliers that merge graphs. l°Also, during copying suhaequent to a mlccessful uniticatioll, two 0d¢:8 COllvergillg into the 8&lltl~ llode will Ilot c~*,lSe ovcrcopying simply because if a node already has a copy then the copy is returned. AcrF, s DE COLING-92, NANTES, 23-28 AOt3T 1992 4 4 2 PRec. OF COLING-92, NANTES, AUO. 23-28, 1992 lieW(;Opy ~ (:reilt.:-node(); lleWCOpy.type ~ :COlllp|i~x; newcopy.g(~neratioll ~ *ltnify-glolnd-countel*: dg.col)y ~- lieWco|)y: 23 FOR ALL arc IN dg,arc-llst DO","n(~warc ~ ctlpy-arc-alid-ct)lnp-llrc(arc)l","pllsh ll()w,%rc into newct)py.ttrc-li,t; IF (dg.coiup-arc-li,t is non-mnpty AND","dg.generation - *unify-glohal-counter*) THEN","FOR ALL c(nnp-ar(: IN dg.conll~-itrc-li~t DO","li(~wlirc ~-- Col)y-arc-and-colllli-ltrc(colllp-arc};","plish liewltrc into n¢~wcopy.arc-liut; dg,cotnp-arc-list ~ nih return (newcopy): END; FUNCTION Colly-arc-aud- conq)-arc(inpu t - arc }; label ~- input-,xrc.labch V~dllO t'~ copy-dg-witil-coulp-arl:s(input-arc.valul~); return a liCW ~trc with hd,el itltd vahle; END; Figure 4: Node and Arc Copying Functions"]},{"title":"3 Q-D Copying + DS-Sharing","paragraphs":["In order to attain strncture-sharing during QmLsi-Destructive gral)h unitication, no niodifieation is necessary for the unification functions descrit)ed in the previous section. This section describes the qua.st-destructive copying with strueturc-sharing which replaces the original copying algorithm. Since unification functions are unnt0ditied, the Q-D unitieslion without stru(:ture-sharing eau be mixed trivially with the Q-D unificatitm with strueturc-sharlng if such a mixture is desired (by simply choosing differeat copying fimetions). Infi)rlnally, the Q-D copying with structure-sharing is l)erformed in the following way. Atonfie and ])ottom llodes are shared, A COlllplex node is shared if llo nodes below that node are changed (a node is considered ehange(I by being a target of forwarding or having a valid COlnp-arc-list). If a uode is ehaaged then that information is 1)~sed Ul) the graph path using multil)le-valut~ binding facility when a copy of the nodes are recursively returned. Two wdues are returned, the first value being the Col)y (or original) nolle and the second value being the flag representing whethe, r any of the node below that node (including t, hat node) h;us been ehanged. Atomic aud bottonl nodes are always sharetl: however, they are considered changed if they were a target of forwarding st) that the 'changed' infornlation is passed up. If the eomI)lex node is a target of forwarding, if no node behiw that node is changed then the ()rigin;d eonlplex node is shared; however, the '(:hanged' inforniatit)n 20I.e.. the *gtill(Sratioli\" fiehl of the iiodt, stored in tile q:olly' field of the \"dg' llode. The Mgoritlnn (lescrihed in [Tomabechi, 1991] imt,d ~COlly-ln~rk' fiehl of'dg'. Currently 'generlttion' field replaces tile three lnltrk fiehl described ill the article. 21 I.e.. the cxisthig copy of the ilodc. 22 Creltto8 fin empty node 8tlliCiUr(L ~a'l'lli~ ofl~ratil)li to set it newly i:tl!iited copy node into tim 'copy' field of Mg' w~ dolill Mter reclirSiOll into tubgtaph~ in tile Mgorithnl description in [Toinabechl. 19911 which wa~ it cause of iufinite D2CllrSiOll with it parlicuhtr type of cycle~ lit the graph. By llloving ill> to tills p(mltion flolll after the recilrtdon, 811ch a pr(~l)hmi Call be effectively avoided. Thilllk8 itr(2 due to Peter Neuhaus for reporting tile pro|lima. is l>~Lsse(l ut> when the recursion retunts. Below is the a<:tual algoritlnn description for the Q-D copying with structure-sharing.","[ Q-I) C ............. s ......",".","........ S ....... I","FUNCTION copy-dg-wit h-conq~-arce-share( dg-u nderef I:","dg ~ dereference-dg(dg-underef);","IF (dg,col)y i8 ito,-enlpty AND dg.ctqiy.generation = *unify-global-counter*) THEN IF (dg = rig.copy) THEN ~a newcopy ~- create-itode( ): newcopy.typc ~- :bottom; tmwcopy.gtmt~r ation ~ *unify-gh)b~d-ctm nt er *; dg.copy ~-- newt:spy; wdues(dg.copy.:changed): 25 ELSE vMue~(dg,col)y,:changed);","ELSE IF (dg ~ dg-underef) THEN copy- imde-comp-not - for war ded(dg);","ELSE copy-node-cmnp-fi)rwardedidg);","END;","FUNCTION copy~node-comp-not-fi)rwarded(dg):","IF (dg,type : :atolnic) THEN values(dg,uil);",";: rt~turn original dg with \"liO ch;lllg(~' flag.","ELSE IF (dg.type = :bottolll} THEN wdueu(dg.nil):","ELSE","IF (dg.cmnp-arc-liat is no.-empty AND","rig,generation = *unify-globaLcounter*) THEN","lmWCopy ~ creatt:-node();","newcopy.tylm ~ :eonwlex;","n(~wcopy.genet&tiolt ~ *ullify-globAl-collnter*:","dg.copy ~ newct)py:","FOR ALL arc IN dg.arc-list DO newarc","first Wdilt~ of copy-arc-and-contp-arc-Mlltre(arc); i)llsh liewitrc into lmwcopy,arc-]ist;","FOR ALL conq)-arc IN rig,cutup-arc-list DO ilawltrc ¢~ firl4 t vahlc of","copy-~trc-alld-ct )ill p-arc-share( corn [)-arc ): ])uflh ileWltr(: iltto ilew(:opy.arc-|iat;","dg.conlp-arc-list ~ nih","wdtieu{ llew(:t~py,:chltlt ged ):","ELSE","state ~ IdL arcs ~ ldh","dg.copy ~ rig 26 , dg.gtmerittiolt ~ *uliify-giol~al-i;o.nt(!r*;","FOR ALL art: IN rig.arc-list DO itewar¢,challge~tl ~ (:opy-arC-~lld-t:Olllp-ar(-sh;tr~(arc}; pus|t newart: illt~ arcs: IF (changed has wdue) THEN","state ,- I:hllligl~d;","IF (state has vldue) THEN IF (rig.copy # dg) THEN","dg.copy.arc-liat , Arcs:","dg.copy.type ~ :complex;","vldues{ tlg.ct~py,:changed ); ELSE","liewcopy ~ create-node();","newcopy.type ~- :comtdex;","llewcopy.getleratioll ~ *tniify-gl()lnd-ctnlntl~r*;","newcopy.arc-liat ~ ~trc~;","dg.copy ~-- m~wl:opy;","vidues( liewct)py.:t:hallged ) ;","ELSE dg.copy ~ nil; ;;reset copy fiekl","values{dg,uil): END; FUNCTION copy-node-conq)-forwarded{ dg); IF (dg.type : :g, tomic) THEN values(dg.:changed); ;; return origiaM dg with 'changed' flag. ELSE IF (rig.type ~- :lmttom) THEN values(dg,:changed); ELSE","IF (dg,comp-arc-li~t is uon-enipty AND","dg,generMion : *unify-globM-counter*) THEN","newcopy ,- create-node():","newcopy.tylm *- :coilifdex; ACRES DE COLING-92, NAMES, 23-28 AO~I 1992 4 4 3 PROC. OF COLING-92, NANTES, AUG. 23-28, 1992 newcopy.gencratio~l ~ *utdfy-global-counter*; slle(:essful tllliticatiOllS to the total ltUlllbcr of Itllifica-dg.copy ~ newcopy: tions. Wc parsed cach selltcncc three times on a Sym-FOR ALL arc IN dg.arc-list DO I)oli(:s 3620 using three tin}float}on ntethods, namely,","Ilew&rc","(- first value of capy-arc-and-coml)-arc-sharc(arc); Wroblewski's algorithln, a qua,si-dcstrttctive lllethod","pllslt new&re }taro newcopy.arcdist: FOR ALL c<>ml)-arc IN dg.comp-arc-list DO","ilewar(:","first value of","copy-arc-and-(:Olllp-ar(:-sh are( colll ])-arc/;","pudt newarc into l|eWcg)y.arc-list; dg.comp-arc-list ~ nil: vMm~s(newcopy,:dlanged );","ELSE stale + nil, arcs ~ tail;","without structure-sharing, and a qu,%i-destructive","method with structure-shariug. Wc took tile short-","est elapsed time for ea(:h metho<l ('W' represents","Wroblewski's algorithnl with a modification to han-","dle cycles and wtrialllcs 29, 'QD' represents the <luimi-","destructive nletlmd without structure-sharing, slid","'QS' represents the prol)osed lnethod with structure-","sharing). Data stru(:tures arc the same for all three","dg.col)y ~ (Ig, dg.gcneration + *Ulfify-glol>al-counter*; unification methods ex(:el)t for additional fields for","FOR ALL art: IN dg.arc-list DO","imwarc,changed +: COl)y-arc-an( -comp-arc:s lare(arc); )l II -ar -list ill tile Q-D lnethod8. 8anle fltllctil)ltS","push newarc into arcs; are llsed to interface with Eal'ley~s parser and tile","IF (dmnged has value) THEN stat~ ~ cbal|ged;","IF (state }tits value) THEN","IF (rig.copy =fi dg) TItEN rig.copy.arc-list ~ arcs: dg.copy.type ~ :comt)lex; value,(dg.col~y.:changed);","ELSE newcopy ~ create-node(); newcopy.type ~-- :complex; SalIIC sul)fllllCtiOllS are used wherever"]},{"title":"possible (snch","paragraphs":[";as creation slid access of arcs) l, ll lnilthllize th(! diffcrem:eu that are not purely algorlthltfi<:. 'Nmnber of Copies' represents the numl)er of nodes created durillg each parse. 'Nlllllber of Arcs' rcprcsents the nlllllber of arcs created durillg each parse. We used Earley's parsing 'algorithnl for the experintent. The Japanese gralmnm' is based on tlPSG newcopy.gencration ~ *unify-gbJb~d-(:ounter*; newcopy.arc-list ~ a~cs; dg.copy ~ neweopy; v~dueA( newcopy.:cllangcd);","ELSE dg,copy ~ nil; vahte~(dg,clmnged); ;; considered changed END; FUNCTION copy-arc-and-comp-arc-dkare(input -arc ); destination,cb~tnged","Col)y-rig-wit h-coml)-~rcs-dtare(in put -,xr(:.value ); IF (changed has value I TItEN","lal)d + inpubarc.label;","value ~ destination;","values(a new arc witb lalml and value,:cluulged); ELSE rabies(input-arc jail): ;; return original arc END; Figure 5: Structure-Sharing Copying Functions"]},{"title":"4 Experiments","paragraphs":["Table 1 shows the resltlts of our experiments using all HPSG-11,~sed sample Japanese granmtar dcvdoped at ATR br a conference registration telephone dialogue domain. 'Unifs' represents the total ltulnl/er of top-level unifications during a parse (i.c, the munl)er of calls to the top-loyal \"unify-dg', and not 'tinily1') 28. 'USratc' represents the ratio of 24 Currently, all lIOdetl arc Col)ted ill a cych~ il~ order to prevent the split of the copy ~uld the original when node above all uladl~.ngcd original i8 modified. Tbanks are due to Makoto 'I'ak~d,a~i of TIS for suggesting the fix. Of c,urue, a better method, if possihle, would be 1o copy tim whole cycle only wheat at least one node in the cycle i~ modified, 25'Values' retltrn nlllltil)le values ~rOlll ~t fllnCtioII. In our algoritlmt, two values are retunlcd. The first value is the result of copying, and the second value is ~t flag iMicatiag if tlmre wa~ any modificatiolt to the node or to ally of its desc(!n(lallt8. 26Temporarily set copy of the dg 1o be itself, 27Multil)te-value-hind call. The first value is homld to 'newarc'. arid the second vahte is bt)und to 'dumged'. 28Unifyl in called several times the number (>f uttify-dg in the gtalnl|l&r ilSC(I ill the eXl)erilllCltt. For exanlpb! nnifyl wi~ analysis ([Ponard and Sag, 1987]) eovering llhenomena such as coordination, case adjmlction, adjunets, control, shLsh categories, zero-pronouns, in terrogativcs, WH constructs, and sonic pragmatics (speaker, hearer relations, politeness, etc.) ([Yoshimoto and Kogm'e, 1989]}. The grammar covers many of the imllortant linguistic phenomena in conversational Japaucse. The grammar graphs which are convertcd front the l)atll equations contaiu 2324 no(tcs, a° Wc used 16 Sclttenecs from a sanlplc telet/hone convcrs~tion dialog whi(:h range from very short sentenets (one word, i.e., tie 'no') to rdativdy hntg ones (such as soredehakochirakarasochiranitourokuyoush, iwoookuriitashimasu 'In that case, wc [speaker] will send you [hearer] the registration form.'). Thus, tltc number of (toll-level) unifications per senteltce wu'icd widdy (from 6 to over 500)."]},{"title":"5 Discussion:","paragraphs":["Pereira ([Percira, 1985]) attaills structure-sharing I)y having the rcsult graph share information with the origiw, d gr~tphs by storing charges to tile 'enviroltmerit'. There will be tlle log(d) overhead (where d is the nuM)er of nodes ill a graph) associated with Percira's ntetho<l that is rcqttircd during node access to ,~ssenfl>le the whole graph from the 'skeleton' and the updates ill thc 'environment'. Ill the proposed sdtcmc, since tim arcs dircetly lloint to the original graph structures there will be no overhead till\" node accesses. Also, during unificatioli, siltce citaltges art! called 3299 times for sentence 9 when Itnify-dg was called 480 tillies. 29 Kogure ([Kogur< 1989]) des(:ribe~ It trivial time modification to WrohlewRki's algorithm lo handle cycles which is used ill oltr experillleltts, 3tlDisjunctive equation~ are l)reproceH~ed hy the grammar reader module to expand into cross-multiples, whereas il~ ATR% SL-TraNs syRtem. Kasl)er's method ([Kauper. 1987]) to handle disjunctive feature-strltctures ia adopted. ACRES DE COLING-92, NANTES, 2348 AOt~T 1992 4 4 4 PROe. OF COLING-92, NANTES, AUG. 23-28, 1992 sent# Unifs USrate 1 6 0.50 2 101 0.34 3 18 0.22 4 71 0.55 5 305 0,37 6 59 0.27 7 6 0,50 8 81 0.51 9 480 0.37 10 555 0.41 ii 109 0.45 12 428 0.33 13 559 0.39 14 52 0.38 15 77 0.55 16 77 0.55 total 2984","(Z for total) Elapsod timo(nec) Num of Copies W QD QS w QD q3 o,2o o.15 0.13 107 79 18 2,53 1.16 1.10 2285 1317 407 0.40 0.20 0,20 220 111 26 2.20 1.24 0.91 2151 1564 514 13.78 6,51 3.65 9092 5224 1220 3,20 0.64 0.50 997 549 97 0.21 0.13 0.11 107 79 18 3.17 1.59 1.21 2406 1699 401 24.62 8.11 5.74 15756 8986 1696 40.15 16.39 8.80 18822 11234 2737 4.60 1.71 1.41 2913 1938 555 19.57 8.24 4.45 13363 7491 1586 37.76 11.74 6.23 17741 9417 2483 3.61 0.90 0.50 947 693 107 2.50 1.57 0.93 2137 1513 428 2.53 1.57 0.90 2137 1513 428 161.23 61.85 36.77 91181 53407 12721 ioo~ 38.4~ 22.8~ 100~ 58,6~ 14~ ~Sd)le 1: Comparison of three methods stored directly in the nodes (in the tluasi-destructivc maturer) thcrc will be no ovcrhead for rctlccting the changes to gral)hs during unitic;ttion. We share the l)rittciph~ of storing changes in a rcsU)rablc way with [Karttuncn, 1986]'s rcvtwsilfle unification and copy graphs only after a socccsshtl unification. However, Kal'ttllllCll~S nlcthod (lots llOt list! strllctllrc-sharilig."]},{"title":"Also,","paragraphs":["}11 Kal'ttullcn's llltttll()t[ 31, whenever it destructive chaage is about to bc made, tile attribute vahle pairs a2 stored in the body of the tlodc arc saved illto all array. The dag node structure itself is idso saved in another arrlty. These wtlucs arc restored after the top lcvcI unification is c(mq)leted. {A t:opy is madc prior to the rcstoratiou Ol)cration if the unification wlus +t successful one.) '['has, ill Karttuncn's lncthod, clmh node ixI the entire argulllcnt gral)h that hius been destructively modified must t)c restored SCl>aratcly by l'eXricviltg the attributc-values savcd ill an array and rcsctting th,! values into the (lag structure skeletons sltvcd in another array. Ill the Q-D method. Olt(! illCl'ell/ellt to the global COlllltcr c.q.ll iav+didatc all tht'. changes made to tilt! no<tern [Karttunen slid Kay, 1985] suggests the use of lazy evaluation to delay dcstructive chalLges during unificatiou. [Goddcn, 1990} presents one method to delay copying until a destructive change is al)out to take phtcc. Godden uses delayed closures to directly imphm|cnt lazy evaluatitm during unification. While it may be concel)tually straightforward to takc iulvantagc of delayc(I cVahla-tion functionalities ill progranuning laagtlages, actllal efficiency gain fl'on! such a schelnc may not bc significant. This is l)et:aase such a schenle siml)ly shifts t4e time and space consmned for Col)ying to creating and evaluating closures (which couhl be very costly compared to 'dcfstruct\" operations to create COl)ics 31The discussion of Karltunen's lnethod is ba.e,l on the D PATR imphnuent;ttion on Xerox 1109 machines ([Karttunmt, 1986]). 32I+e., arc stru(:turen: 'label\" and 'vld[l(~' ])ilii'~ ill oUr w~cabulary.","Num of Arcs W qD OS 113 123 36 2441 1917 760 182 183 62 2408 2191 879 9373 7142 2272 874 797 204 113 123 36 2572 2334 710 17358 12427 3394 20323 15375 5116 3089 2712 992 14321 10218 3059 19014 13055 4471 893 983 199 2436 2185 793 2436 2185 793 97946 73950 23776 100~ 76% 24~ which arc often effectively ()l)timized lit many tom ...... • cial ....... lfilcrs). [Kog,|l'C, 1990] anti [Eulelc. 19611 also use the lazy evaluation i(h',a to delay destructive changes. Both Kogurc all(l Eme, h~ avoid direct usage of delayed evMuation by using pointer Oln:rations. As b3mchr suggests, KogurCs method also requires a special dcl)endcncy inf(,rmation to bc mifintained which adds all overhead ahmg with the cost fin' traversing tile dCl)cudency arcs. Also, a secon(I travcrsa] of the set of dellelldellt liodes i8 required for actually pcrfl)rming the copying. Emele proposes a method of dcrcfercncing by adding enviromnent in-forlltatioli tllld, carries it scqtl(Hl(:t! of gCllCl'atioll COllll* tcrs so that a specific generation node (:all I)(~ fOlllld by traversing tim forwarding links until a node with that generation is found. While this allows undoing destructive changes cheaply by backtracking the envirolllOCllt, every tinlc a spccilic graph is to bc at:- (:cssed the whoh! gt'aph ilcctls tO bc rccollstrll(:ted by following the fol'wardillg pointers ,~cqucntildly as speciticd in the environment list (cxt:et)~ for the root node) to find the node that shal'CS the smne generation number as the root llOde. Therefore, similar to Pcrcira's mcthotl, there will be Nlog(d) ovcrhcad iLssociated with constructing t!ach graph every tinle & gral)h is accessed, where (1 is the llUillbCr of nodes ill the graph and N is the average depth of the tmvironlllClttal dcfcrcncc chain, This would cause a probh!nl if the algtlrithm is adolltcd fin' a large-sclde systcm ill which result graphs arc unified agidnst other graphs many times. Like Wroblewski's method, \"all three lazy methods (i.c, Godden's, Kogure's and Emele's) suffer fi'mn the t)roblenl of"]},{"title":"Early Copying ms","paragraphs":["defined in [Tonlabcchi, 1991]. This is because the copies that arc incrcnmntally created u 1, to tile point of failure during the same topAcvel unification arc wasted. The problent is inherent ill increlnental copying scheme and this probhml is elinfil|ated completely in [Karttuncn, ACRES DE COL1NG-92, NANTES, 23-28 Aotrr 1992 4 4 5 PROC. oF COLING-92, NANTES, AUO. 23-28, 1992 19861 and ill tile Q-D nmtltod. 3a There is one l/otential problent with the structure,- sharing idea whMt is shared by each of the schemes inchlding tile proposed tnethod. This ltallpens"]},{"title":"when","paragraphs":["operations other tllan ttnification modify the graphs. (This is typical whco a parser cuts off\" a part of a graph for sltbsequellt analysisa4.) When such ol)- erations are perfornmd, structure-sharing of t)ottolll (vlu'iablc) nodes stay cause probhmts when a subgraph cotttaitdog a 1)ottmn is shared by two different graphs and these graphs are used as argtllllelltS of a utfification function (either ~Ls the part of the same input graph or as ehmumts of dgl and dg2). When a gt'aplL that shares st bottl)lO (lode iN llOt Ilsed ill its entirety, then the, represented i:lmstraint postulated by the path leading to the bottotn no(h; is no longer the same, Therefl>re, when such a graph appears in the same unification aloog with soIoe other graph with which it DS shares the same bottotn node. there will 1)e a false FS-Sharing. (If the graph is used in its entirety this is not a problem since the two graph paths would unify anyway.) This problenl happens mdy when neither of the two graphs that DS-Sltares the same I)ottolll node wan ultified against SOille other graph before al)pearing in the santo unification, as {If either was once unified, h)rwardiug wouht have avoided this prol)lent). The methods to avoid such a problent can be 1) As long as these convergence of bottoln nodes are used h)r features that are not pressed up during i)arsing, the ln'oblems does not affect the result of parse in any way whMt scents the ca,se with the gr~mtmars at ATII azl(l CMU. 2) A parser call tie modified so that when it modifies a graph other than through graph unification a6, it et'eatcs copies of the arc stru(:tures containing the bottotn nodes. In the prolmsed tnethod this can be done by calling the copy function without structure-sharing llefl)re a parser ntodifics a grallh. 3) A parser can lie rood(tied so that it does not (:lit off parts of graphs and use the graphs in their entirety (this should not add emnplexity (mcc strttctttre-sharing is introduced to unification). Thus, althtmgh the space and time reductioo attained by structure-sharing (Jail t)e significant. DS-Shariag can cause l)roblems unless it is ttsed with a eautiott (by making sure variM)le sharing aaLazy methods delay eopyiug until a destructive chaalge is to be perforlne.d Do that unnecessary copies are not created within a lmrticular recurs(on into a unification function; howover, 8il|ce each shared arc recllrsion is indellendent (llOlldeterlllillistic). (!villi if there are 11o unltecesa&ry copies created at ,dl iu otte particular relalrsioll, if there is a failure in 8Ollllr other shared art: recurs(on (at some depth), then the copied that are created hy successful shared arc recurs(ass up to the point of detection of failure will beconm wasted, As long as the haste contr<fl structure retnltins incremental, this is inher- (!lit ia the increlllental |uethod. In otheI wolds, the problem is inhereut in these ilmremental methods by definition. 34 For example, lnltny parse[.~ cut off a subgraph of the path 0 hJr applying further rules whmz it rule is accepted. 35Such cases lltay happen whell the 8allle rule (such as V V} augluented with a heavy use of convergence ill the bottonl nodes is applied malty times during a parse. 36Stlch as when a rule is accepted and suhgraph of O path is Cltt off. does not cause crroncous sharing by using these or some othm\" methods)."]},{"title":"6 Conclusion","paragraphs":["The structure-sharing scltemc introduced ill this paper made the Q-D Mg(~ritlnn run significantly f~mter. The original gain of the Q-D algorit, hnt was due to the fact that it does not create ally Over Copies or Early Col>ies whereas iIIcrelllelltal (:opyillg sfllI~Ille inherently produces Early Copies (iLs defined in [Totnal)echi, 19911) when a unification fails. Tilt: prol)osed schenm lllakes the Q-D algotfflmi fully i~vl)i(1 lh~dundaltt Collies as well by only copying the lowest nodes that need to be eoI)ied due to destrtt(:tive chatlges caused"]},{"title":"by","paragraphs":["successful unifications only. Since there will bc virtually uo overhead associated with structure=sharlng (except far returning two vahl(!s ill-stead (If oDc' to pa.ss tip :chattge(l illforltlatioll wht!ll rt!- curs(oil for copying rcturos), the perfornlatlee of the prol)osed strnl:ture-sharing schellle should llOt drop eveii when the granmlar size is significantly scaled Ul). With the denttmstratcd speed of the algorithm. as well as the ability to handle cyclicity in the graphs. mid ease of switching betwemt strueture-sharittg attd non-structure sharing, the algorithm couhl lie a viable alternative to existing tttfifit:ation algorithnts used in current nature| language systems."]},{"title":"References","paragraphs":["[Emele, 1991] Erode. M, \"Unificatimt with Lazy Non-Redundant Copying'. In Proc. of A CL-91, 1991. [Godden. 1990] Godden, K. \"Lazy Uuification\" In Proc. of ACL-90. 1990. [Katitunen. 1986] Karttuuen. L. \"D-PATR: A Deveh)pment EnyirOltlllellt for IJnifi(:a.til)it-13mued Gr0.llllllalrs\". In Proc. of COLING-86, 1986. (Also, Report CSLI-86-61 Stanford University). [Karttunen and Kay, 1985] Katttum)n. L. ~nd M. Kay. \"8tnutnre Sharing with Binary Tr(~s\". In Proc. of ACL-85. 1985. [Kasper, 1987] Kasper. R. \"A Unifice.tion Method for Disjunc-tive Feature Descriptim~s\". In Prec. of ACL-87, 1987. IKogute, 1989] Kogure, K. A Study oil Feature St1*l~cture.~ and Unificatim~. ATR TechuicM Report. TR-l-O032. 1988. [Kogure. 1990] Kogurc, K. \"Strategic Lazy Incremental Copy Graph Unification\". In Prom of COLING-go, 1990. [Marimoto. et el, 199(1I Morimoto, T.. H. Ilda, A. Kurem~tsu, K. 8hikano, and T. Aizawa. \"Spoken Language Translation: Toward Realizing an Automatic Telepholu! Interprelation System\". In P'roc. of l'nfoJapan 1990, 1990. [Pereira, 1985] Pereira, P. \"A Slructure-Sharing Representa-tion for Unification-Based Grammar Formallsms\". In Proc. of ACL-8& 1985. [Pollard ~nd Sag. 1987] Pollard, C. and L Sag. Infovmatio.-- based Syntax and Semantics. Vol 1. CSLI, 1987. [Yoshimoto and Kogure, 1989] Yoshilnoto, K. and K. Kogure. Japanese Senfence Analy.~is by means of Phrase Strltctu.re Grammar: ATR Technical Report. TR-1-0949, 1989. [Tolnabechi, 1991] Tomahechi, H. \"Quasi-Destructive Graph Unification\". lit Proc. of ACL-91, 1991. [Wroblewski, 1987] Wrohlewski. D.\"Noudestructlve Graph Unification\", In Proc. of AAAI87. 1987. AcrEs DE COLING-92, NANTES, 23-28 AOr3T 1992 4 4 6 PROC. OF COLING-92, NANTEs, AUG. 23-28, 1992"]}]}