{"sections":[{"title":"A Logic Programming View of Relational Morphology","paragraphs":["Harvey Abramson","Institute of Industrial Science, University of Tokyo Minato-ku, Roppongi 7-22-1, Tokyo 106, Japan e-mail: harvey@ godzilla.iis.u-tokyo.ac.jp","Abstract We use the more abstract term \"relational morphology\" in place of tile usual \"two-level morphology\" in order to emphasize an aspect of Koskenniemi's work which has been overlooked in favor of implementation issues using the finite state paradigm, namely, that a mathematical relation can be specified between the lexical and surface levels of a language. Relations, whether finite state or not, can be computed using any of several paradigms, and we present a logical reading of a notation for relational morphological rules (similar to that of Koskenniemi's) which can in fact be used to automatically generate Prolog program clauses. Like die finite state implementations, the relation can be computed in either direction, either from the surface to the lexieal level, or vice versa. At rite very least, this provides a morphological complement to logic grammars which deal mainly with syntax and semantics, in a programming environment which is more user-friendly than the finite state programming paradigm. The morphological rules often compile simply into unification of the arguments in the generated morphology predicate followed by a recursive call of the said predicate. Further speed can be obtained when a Prolog compiler, rather than an interpreter, is used for execution. Introduction. Kimmo Koskenniemi's so called \"two-level model\" of computational morphology (1983) in which phonological rules are implemented as finite state transducers has been the subject of a great deal of attention. The two-level model is based partly on earlier work of Johnson (1972), who considered that a set of \"simultaneous\" phonological rules could be represented by such a transducer, and of Kaplan and Kay (1983) who thought that ordered generative rules could be implemented as a cascading sequence of such transducers. Koskenniemi in fact implemented the phonological rules by a set of finite state tranducers running in parallel, rather than by a single large finite state machine into which many cascading machines could be combined. Subsequent to Koskenniemi's original work, there was a LISP-based implementation called KIMMO (Kartunnen 1983), and two-level descriptions of English, Rumanian, French and Japanese (Kartunnen and Wittenburg, Khan, Lun, Sasaki Alam 1983). A later LISP based implementation by Dalrymple et al (1987) called DKIMMO/TWOL helped the user by converting two-level rules into finite state transducers: in earlier implementations, and in the recent PC-KIMMO system (Antworth 1990), it was the user's task to generate the machine, s from two-level descriptions. However one very important contribution of Koskeaniemi to morphology, namely the notion that there is a"]},{"title":"relation","paragraphs":["between the surface and lexical \"levels\", has been somewhat overlooked by implementation issues having to do with the couversion of two-level rules into fiuite state automata in the various KIMMO systems. The two-level rules according to this notion, unlike the rules of generative morphology which"]},{"title":"transform","paragraphs":["representations from one level to representations in the other, express a correspondence between lexical and surface levels. Furthermore since no directionality is implied ill the definition of a relation, unlike geuerative rules, the same set of two-level rules applies both in going from surface to lexieal levels and vice versa. Rather than being procethtral rules, they are declarative. Consequently, any correct implementation of the two-level rules is a relational program which can be used either analytically or generatively. We will henceforth, in order to emphasize the fact that a relation is being defined by them, refer to relational morphology rules rather than to the mathematically neutral term \"two-level rules\". Despite the recognition that relational morphology rules are declarative, the main emphasis in using them has been obscured by the original finite state implementation technique. Recently, Bear (1986) has interpreted such rules directly, using Prolog as an"]},{"title":"implementation","paragraphs":["language. This, although an improvement on finite state implementations from the point of view of debugging and clarity, still misses an important aspect of relational morphology rules as a declarative notation, namely that if relational morphology rules define a relation between surface and lexieal levels, then that relation can be specified and implemented using any of several different relational programming paradigms. In this paper, we will show that logic programming, which can be viewed as a relational programming paradigm, can be used to give a declarative reading to morphological rules. Further, because of the execution model for logic programs, embodied in various logic programming languages such as Prolog, the declarative reading also has a convenient procedural reading. That is, each relational morphological rule may be thought of as corresponding to or generating a logic program clause. The entire set of logic program clauses generated from the relational morphological rules, coupled with some utility predicates, then constitutes a morphological analyser which can either be used as a stand alone program or which can be coupled as a module to other linguistic tools to build a natural language processing system. Since the roles have been transformed into logic program clauses, they gain in speed of execution over Bear's interpretive method, and further speed can be gained by compiling these clauses using existing Prolog compilers. At the very least, this provides a morphological complement to logic grammars (Abramson and Dahl 1989) which deal mainly with syntax and semantics, in a programming environment which we believe is more user-friendly than the finite state programming paradigm. It may be argued that this is a step backwards from the linear efficiency of finite state processing. However, when ACRES DE COLING-92, NN̂TES, 23-28 ô(rr 1992 8 5 0 PRoc. ov COI.ING-92, NANTES, AUG. 23-28, 1992 discussing \"efficiency\" it is very important to be very precise as to where the efficiency lies and what it consists of. Finite state processing is linear in the sense that a"]},{"title":"properly implemented","paragraphs":["finite state machine will be able to decide whether a string of length ,~ is acceptable or not in a time which is O(n), ie, for large enough n, a linear multiple of n. For small values of u, depending on how much bookkeeping has to be done, \"finite state algorithms\" may perform worse titan algorithms which are formally O(n 2) or higher. Any processing in addition to recognition may involve time factors which are more than linear. This entirely leaves aside the question of the userfriendliness of the finite state computing paradigm, a question of how \"efficient\" in human terms it is to use finite state methods. Anyone who has trieM to implement finite state automata of substantial size directly (as in Koskenniemi's original implementation, the first KIMMO systems, and KIMMO-PC) will have realised that programming finite state machines is distastefully akin to directly programming Turing machines. A substantial amount of software is necessary iu order to provide a development, debugging and maintenance environment for ea~y use of the finite state computing paradigm. There also remains the theoretical question as to the 'adequacy of finite state morphological descriptions for all, or even most, human languages. However, this is a topic we shall not venture into in this paper. In our method, a relatively small Prolog program generates logic programming clauses from relational morphology rules. The generated clauses (at least in the experiments so far) are readable and it is easy to correlate the generated clause and the original morphological rule, thus promoting debugging. The standard debugging tools of Prolog systems (at the very least, sophisticated tracing facilities) seem sufficient to deal with rule debugging, and the readability of the generated clauses should help in the maintenance and transference of morphological programs. Thus, from the software engineering point of view, logic progrannming is a more sophisticated, higher-level programming paradigm than finite state methods. Also, should finite state descriptions in the end prove inadequate, or even inconvenient, for all of morphology, logic programming provides expressive power for reasonable extension of the notation of relational morphology rules. The current availability of Prolog compilers, even for small machines, provides another increment of speedy execution of the generated programs. Many of the morphological rules produce logic program clauses in which checking of the lexical and surface elements and contexts reduce to unification followed by a recursive call of the morphology predicate. Compiled Prolog abstract machine code for such clauses is usually very compact. Prolog compiler indexing mechanisms often make it possible to access the correct clause to be applied in constant time. Notational Aspects. Our tableau notation for relational morphology rules is as follows: LexLeft <= Lex => LexRight <:> SarfaccLeft <= Surface => SurfaceRight which expresses the relation between a lexical and a surface uait (Lex aml Surface, respectively), provided that the left"]},{"title":"and","paragraphs":["right contexts at both the lexical and surface levels (LexLeft, LexRiglnt, SurfaceLeft, and SuffaceRight) are satisfied. Another kind of relational morphology rule which is allowed is: LexLeft => Lex <= LexRight<:> SurfaceLeft => Surface <= SurfaceRight. which expresses a relationship between Lex and Surface providing that the left and fight contexts at the lexical and surface levels are"]},{"title":"different","paragraphs":["from those specified by LexLeft, LexRight, SuffaceLeft, and SurfaceRight. This means that either LexLefl or LexRight is not satisfied, and also that either SurfaceLeft or SurfaceRight is not satisfied. More coutpact notation is also accepted, for example:","LexLeft:SurfaceLeft <=Lex:Surface=>","LexRight:SurfaceRight.","LexLeft:SurfaceLeft =>Lex:Sarface<=","LexRight:SurfaceRight. In the case where a pair of lexical and surface contexts are identical, or if the lexical and surface elements are identical, they need not be repeated. Such compressed rules as the following are also allowed: Left <= Element => Right. Left => Element <= Right. Sets of symbols may be specified: set(vowel,[a,e,i,o,u]). Lexical entries may be specified as follows: lexicon:: {eat=noun,root= craps}. lexicon::{cat=noun,root= pimlo}. This feature notation is that used in the author's Definite Feature Grammars (Abramson 1991)."]},{"title":"Logical reading of relational morphology","paragraphs":["roles. Corresponding to a set of relational morphology rules, a binary predicate morphology/2 specifies the relation between a lexical and a surface stream of characters: morphology(LexStrcam,S ufface Strcarn). In order to specify the logic program clause which corresponds to a relational morphology rule, we have to manipulate the left and right lexical and surface contexts. We can find the right contexts within LexStream and SurfaceStream, but we have to provide a specification of the left contexts, and we do this by defining the above binary predicate morphology/2 in terms of a quaternary predicate morphology/4:","morphology(LexS tmanLSurfaceS tream, LeftLexStream,I.,eftS ur faceStream). ACn'ES DE COIJNG-92, NArcri;s, 23-28 Aofzr 1902 1~ 5 1 P~toc. oF COLING-92. NANTES, A~JG. 23-28, 1992 LeftLexStream and LeftSurfaceStrcam are initially empty and are represented as reverse order lists of the left contexts which have aheady been seen. The top level definition of morphology/2 is:","morphology(LexS tremn,Sur faceSt~un) :- raorphology(LexStream,SurfaceSu'emn,I I,[1). The fundamental logic program chmse co~reslxmding to a relational morphology rule sneh am LexLeft <= Lex => LexRight<:> SurfaceLeft <= Surface => SurfaceRight. is morphology(LexS \"tman~,S ur faceS tremn,","LeftLexStream,l.~efiSl~'aceS \"Imam) :- LexStream = lLllLexRest]. SurfaceStream = [SllSurfaceRestl, [exeme(Lex,L1), surface(Surface,S 1), lex context (LexLefl,Le fd.exStre,'un ,LexRight,LexRest), sur face eontext(Sur faceLeft.lmftSurfaceStmam,","S ur f~eRight,Sur fhceRest), NewLeftLexStreaan = [Llll~eftLexStream], NewLeftS urfaceS \"tmanl = [S 111.eftS uriaceStream], morphology(LexRest,SurfaceRest,","NewLeftLexSlaeatm ,Newl.etiS urface£ hean 0 . Here, LexStream and SurfaceStreanl are analysed as consisting of the first characters LI and SI, and the remaining streams, LexRest and SurfaceRest. It is verified that L1 is the lexeme specified by Lcx, and S1 the surface character specified by Surface. (Lex, Surface, LexLeft, LexRight, SurfimeLeft, and SurfaceRight are as given iu rite morphology rule.) Contexts are checked by the subgoals lex_context and surface context. New left context streams are created by prefacing the old left context streams with LI ,and S1 (note again that the left context streams are built np in reverse order). Finally, the predicate morphology/4 is recursively called on the remainder of the lexical and surface streams, and with llu~ new left context streams. Although the logical reading of this appears to involve many subgoals, in fact tbr many relational morphology rules, the subgoals are compiled away into simple unifications. See the Appendix which contains at .set of relational morphology rules dealing with simple English plural forms and their corresponding logic program clauses. Space does not permit us to comnlent on file example, or how the compiler works, but the interested reader may contact the auttmr. Further papers will deal with these topics. Conclusions and future research. We have provided here in the setting of logic programming a morphological complement to the logic grammars which mostly concentrate on syntax and semantics. However, we have also provided a notation and a logical reading of that notation which suggests fi~rther exploration as to expressiveness and efficiency. If the context in a relational rule is specified by a regular expressimt, the appropriate context stream is parsed using a small logic grammar which defines such expressions. It may however make sen~, in approaching non-concatenative aspects of morphology, to be able to specify lexical contexts with more stnmtt~re thml regular expressions allow. The implementation would be easy: in place of the logic grammar used to parse regular expressions, a more complicated logic grammar (context free, at least) would be used for lexical context verification. It is also thought that metarnles (see Abramson 1988 or Abramson and Dahl 1989) will be u~ful in dealing with nonconeatenative aspects of morphology. Since the project is at an early stage, there is not yet an extonsive set of examples. We expect to develop a full set of rules for English morphology, and it specification of Japanese verb forms. Ackunwledgment.The author wishes to acknowledge the support of Ricoh Corporation as a Visiting Information Fusion Professor at the University of Tokyo's Institute of Industrial Science. The author \"also wishes to thank Prof. Akira Ishikawa of Sophia University, Tokyo, for comments on this work. Also, thanks to Profs. lshizuka and Ishikawa for help in translating the abstract. References. Abramsou, tl. 1988. Metarules and an approach to conjunctiou in Definite Clause Translation Grammars. Proceedings of the Fifth International Conlerence and Symposium on Logic Programming. Kowalski, R,A. & Bowen, K.A. (editors), MIT Press, pp. 233-248, 1988. Abramson, H. 1991. Definite Feature Grammars for Natural and Formal Languages: An Introduction to the Formalism. Natural Language Understanding and Logic Programming, III, edited by C.G. Browu and G. Koch, North-I Iolland, 1991. Abranlson, H. and Dahl, V. 1989. Logic Grammars, Symbolic Computation Series, Springer-Verlag. Antworth, iLL. 199(I. PC-KIMMO: A two-level processor for morphological analysis. Summer Institute of Linguistics, Dallas, Texas. Bear, J. 1986. A morphological recognizer with syntactic and phonological rules. In Proceedings of COLING '86, 272-276. Association for Computational Liuguistics. Dalrymple, M. et al. 1987. DKIMMO,cTWOL: a development environment lor morphological analysis. Stanford, CA: Xerox PARC and CSLL Johnson, C.D. 1972. Formal aspects of phonological description. The [[ague: Mouton. Kaplan, R.M. and Kay, M. 1981. Phonological rules and finite state transdt, cers. Paper presented at the 1981 Winter meeting of the ACL/USA. Kartmman, L. 1983. KIMMO: a general morphological processor. Texas Linguistic Formn 22:163 - 186. Kartammn, L. and Wittenburg, K. 1983. A twoqevel morphological analysis of English. Texas Linguistics Forum 22:217-228. ACRES DE COLING-92, NANt'ES, 23-28 AOI]: 1992 8 S 2 1';~.O{:. OI, COI,ING-92, NANI'ES, AUG. 23-28, 1992 Khan, R. 1983. A two-level morphological analysis of Rumanian. Texas Linguistics Forum 22:253+270. Koskenuiemi, K. 1983. Two-level morphology: a general computational model for wordqbun recognition and production. Publication No. 11 Helsiuki: University of Helsinki Department of General Linguistics. Lun, S. 1983. A two-level morphological analysis of French. Texas Linguistics Forum 22:271-278. Sasaki Alum, Y. 1983. A two-level molphological analysis of Japanese. Texas Linguistics Forum 22:229-252. Appendix. Elementary formation of plttrals in English.","(0) x <= '+' => [s,'#'l <:> x <= e => [s,'#']+","(1) z <= '+' => [s,'#'l <:> z <= e => [s,'#'l.","(2) y <= '+' => [s,'#'l <:> i <= e => Is,'#'].","(3) s <= '+' => [s,'#'l <:> s <= e => [s,'#'],","(4) o <= '+' => [s,'#'l <:> o <= e => [s,'#'].","(5) [c,h] <= '+' => [s,'#'l <:> [c,h] <= e => Is,'#'l. (6) Is,hi <= '+' => Is,'#'] <:>","Is,h] <= e => Is,'#'].","(7) <= y => '+' <:> in(con) <--- i =>.","(8) not(set([[c,h],s,[s,hl,x,z,yl)) <~: '+' ~:> Is,'#'l <7> not(set([[c,h,e],Is,eJ,[s,h,el,lx,e I,[z,el,[i,e] 1)) <= 0 => Is,'#']. %Note negative context here, (9) set([[c,hl,s,[s,h],x,z,y]) => e <= [s,'#'l <:>","set([[c,h],s,[s,h],x,z,il) =.- c <~ [s,'#'l. %This is a default tale. (10) ._ <= iu(X,char_ e) => _ <:>","_ <= in(X,char e) => . set(char e,[a,b,c,d,f,g,h,i,j ,k,l ,m,","u,o,p,q,r,s,t,u,v,w,x,y,z,'#' I). set(con,[b,c,d,f,g,h,j,k,l,m,u,p,q,r,s,t,v,w,x,y,zl), In addition to specifying characters such as s, x, etc., we can also deliue ~qnences of characters noted aS lists Is,h], not(characte0, uot(sequeuce ol characters), in(con) means any member of the ~t con, whereas iu(X,char c) is a member of the set char e ~ssigncd to the variable X for unification in another part of the talc. '+' is used as a mnrphenle lamm 'lary, 0 is used as the null symbol, '#' is used as an eadm~ker, and '' is used to specify a don't care context. By providing a complete specification of context we cnnld remove any consideration of ordering of the rides, lIowever, it is convenient to depart slightly l'i~m ~m order free formalism by allowing default rules such as our last one with don't care contexts which SlW.cify what happens to syuubols not dealt with in any of the atore-menlioned rules, to appear at the end. (*) moqfl|ology([l, [1, A, B). (0) morphology([+, s, #[A], [e, s, #1B], [xlC], [xlD]) :-","morphology(Is, #1AI, Is, #1B], [+, xlC], [e, xlD]). (1) monf~hology([+, s, #1A], [e, s, #1B], [zlC], [zlD]) :-","morphology(Is, #1A], Is, #1B], [+, zlCI, [e, zlD]). (2) ntorphology([+, s, #1A], It, s, #1B], [ylC], [ilD]) :-","mnq>hology([s, #IA], Is, #1B], I+, ylC], [e, ilD]). (3) morphology(l+, s, #1AI, It, s, #[B], Isle], [slD1) :-","men phology(Is, #1AI, Is, #1B], [~, slCI, [e, slD]). (4) moq>hology(l+, s, #1A], [e, s, #1B], [olC], [oiD]) :-","moq~hology(I s, #1AI, Is, #1BI, [+, olC.1, [e, olD]).","(5)","nlorphology(l+, s, #1A], [e, s, #1B], [h, clC], [h, clD]) :-","movpholngy([s, #1AI, Is, #1BI,","[+, h, clC], [e, h, clD]).","(~,)","moq)hology(l+, s, #[AI, le, s, #1B], [h, siC1, [h, slD]) :-","utorphology([s, #1A.I, [s, #Ill/,","[ ~-, h. sIC], [e, h, slD]). (7) morphology([y, +IA], lilB], C, IDLE]) :-","con(D),morphulogy([+lA], B, lylC], [i, DIE]).","(8)","mcnphology([-t., s, #IA], Is, #IB], C, 1)) :- not subslxings(C, [[h, el, s, [h, s], x, z, y]), not substrings(D, lie, h, e], le, s], [e, h, s], [e, xl,","[e, zl, It, ill), morphoh~gy([s, IliA], Is, #1BI, I+IC], D).","(9)","moqfl~ology([e, A, BIC], [e, D, Ell;I, G, |1) :- not (subsUiugs(G, [o, Ih, el, s, [h, si, x, z, y]),","match(Is, #1, IA, BI)), uot (substrings(H, [u, lh, el, s, [h, sl, x, z, i]),","umteh([s, #], ID, El)), moq)hology([A, BIC], [D, ELF], [elG1, [elHl). (10) moqfltology([AIBI, [AICI, f), E) :- char c(A),","utorpholngy(B, C, IAIDJ, [AIE]). Clause (*) is generated to termiuate morphological l)ft~cssing whcu bofll tile [exical and surface streams ~Ue empty. In this case, tile left contexts are ignored. Chmses 0-6 cotrcslx)ndiug to rules 0-6 follow the same pattern in which lcxicat and sud~lcc syml~Jls and contexts are specified within tile streams and m'e checked by unification, followed by a recursive call to the moqfliology/4 predicate on file remainder of tile lexical illl(l surface stfcums and wiflt new left context streams. S/IC[I clauses involving anilicatiou ol the head attd a AcrEs DE COl,ING-92, NANI~S, 23 28 Aoi)r 1992 8 S 3 l'l¢oc:. O|; COl,IN(;-92. NANIES, A/JC+. 23-28, 1992 body which is only a recursive call of the same predicate are efficiently handled by Prolog compilers. Clause 7 is similar except that it also involves a check to see that the first character in the left surface context is a consonant. Set definitions such as: set(con,[b,c,d,f,g,h j,k,l,m ,n,p,q,r,s,t,v,w,x,y,zl). generat~ unit clauses: con(b)., con(c) ...... con(z). In clause 7, if D in con(D) is instantiated (as it is since the D represents a left context which has already been seen), code generated for this by Prolog compilers amounts to something like an indexed table lookup which takes place in constant time. Similar remarks apply to clause 10 where it is checked that A is a member of the set char e. Clause 8 involves a combination of a unification check for the right context, and a check that the left context does not consist of any of the specified strings. Here, in order for the morphology clauses to work in both the analytical and generating directions, the negution must be logically safe notation, i.e., the arguments to the negation must be grounded. Logically safe negation involves the use of delaying evaluation of the negation until all arguments have been grounded. Clause 9 which involves a negative context, makes sure, using safe negation, that either the right context is not [s,'#'] or that the left context does not match any of the subslxings in the specified set."]},{"title":"Sample execution:","paragraphs":["?- morphology(P,cries). Root = cry %nonstandard plural formation {cat=noun, %original lexicon entry root=cry ) Suffix = s (cat=norm, %modified feature root=cry, plural=yes} P = cry+s ; %another solution? fail. %no. ?- morphology('fox+s',P). P = foxes ?- morphology('piano+ s',P). P = pianoes; %one plural form for some nouns","%which end in \"o\" P = pianos; %another plural form fail. %no others The same clauses for the predicates morphology/2 and morphology/4 are used in solving goals in both directions."]},{"title":"Japanese","paragraphs":["Summary."]},{"title":"~,\" h, 6 og fL-.)i","paragraphs":["KoskemtiemiO96J[~ {,:- ~ 5 ~ L~,~'~ ©~ t/.,-tOP"]},{"title":"5o }J~4, l~t (Koskenniemi~9~o09~L~Jf :) I~/t~-~ Harvey Abramson","paragraphs":["ACI~S DE COLING-92, NANTES, 23-28 AOfJ'r 1992 8 5 4 Pl~OC. oi: COLING-92,"]},{"title":"NANTES,","paragraphs":["AUG. 23-28, 1992"]}]}