{"sections":[{"title":"A TREATMENT OF NEGATIVE DESCRIPTIONS OF TYPED FEATURE STRUCTURES","paragraphs":["KIYOSHI KOGURE","NTT Basic P~esearch Laboratories","9-11, Midori-cho 3-chome, Musashino-shi, Tokyo, 180 Japan","kogure@atom.ntt.jp Abstract A formal treatment of typed feature structures (TFSs) is developed to augment TFSs, so that negative descriptions of them can be treated. Negative descriptions of TFSs can make linguistic descriptions compact and thus easy to understand. Negative descriptions can be classified into three primitive negative descriptions: (1) negations of type symbols, (2) negations of feature existences, and (3) negations of feature-address value agreements. The formalization proposed in this paper is based on A'it-Kaci's complex terms. The first description is treated by extending type symbol lattices to include complement type symbols. The second and third are treated by augmeriting term structures with structures representing these negations. Algorithrrts for augmented-TFS unification have been developed using graph unification, and programs using these algorithms have been written in Conmaon Lisp. 1 Introduction In unification-based or information:based linguistic frameworks, the most important objects are structures called 'feature structures' (FSs), which are used to describe linguistic objects and phenomena. A feature structure is either atomic or complex: an atomic FS is denoted by an atomic symbol; a complex FS consists of a set of feature-value pairs each of which describes an aspect of an object. Partial information on aJ~ object is merged by applying the unification operation to FSs.","ILeseareh on unification-based linguistic theories has been accompanied by research on FSs themselves. Several extensions on FSs or on feature descriptions and formal treatments of the extensions have been proposed. Disjunctive and negative descriptions on FSs help make the linguistic descriptions simple, compact, and thus easy to understand. For disjunctive feature deacrq)tions, Kay[14] introduces them into FUG (lqlnctmnal Unification Grammar) and gives the procedural semantics. Karttunen[ll] also proposes procedural treatments of disjunctions in conjunction with relatively simple negations. ILounds and Ka.sper[19, 13] propose a logic-based formalism--feature logic-which uses automata to model FSs and can treat dis-Junctive feature descriptions, and they obtain important results. For negative descriptions of PSs, one of the most. fundamental properties of FSs, the partiality of information they carry, makes its insufficient to adopt relatively simple treatments. Classical interpretation of negation, for example, does not, allow evaluation of negations to be freely interleaved with unification. Moshier and Rounds[17] propose a formal framework which treats negative feature descriptions on the bà~is of intuitionistic logic. Ilowever, their |bHnalism has trouble treating double negations. Dawar[5] l)rOl)OSeS a formal treatment b~ed on three-valued logic. In order to treat feature domains of complex FSs and to treat taxonomic hierarchies of symbolic tim ture values, type (or sort) hierarchies have been in-troduced, allowing definition of typed (or sorted) feature-structures (TFSs). A TFS consists of a type symbol from a lattice and a set of rearm:e-value pairs. A TFS can be seen as a generalized concept of both atomic and cornplex FSs. Pollard and Sag/18] iatt'o-duce sorts into IIPSG (Ilead-drivcn Phr~Lse Strllcttn'e Grammar) and use sorted FSs to describe linguistic objects. Ait-Kaci[1] proposes an Mgebraie fratnewot'k using the C-types and ~-types, one of promising lbt'maliza-tions of TFSs, based on lattice theory. This lbrmalization was originally ainmd at formalizing and in-tegrating various kinds of knowledge representat.ioiT frameworks m AI. In this approach, types are defined ,as equivalence clmsses of complex term structures. A subsumption relation is defined on these term struc-. tures. The join and meet operations on thenT correspond to tile generalization and uniilcation Ol)era-tions on TFSs, respectively. This approach essentially adopLs 'type-as-set' seulantics. Subtype relationships on type correspond to subsnmption relationships on denotations of types. Based on this framework, an extension to Prolog, LOGIN[2], has becn developed. Smolka[20] proposes a feature logic with subsorts. In this approach, negative descriptkms can be decomposcd into three kinds of prinfitivc negations, namely, negations of sorts or complement sorts which denote tile complements of sets that positive counterlmrl.s lienote, negations of feature existences, and negations of feature-address agreement or feature-address dis agreement. Slnolka extends t~aturc descriptions but a feature-structure interpretation of an extended de scription does not include negat.iw~ information and corresponds to a simple TI\"S. Some TIeS based m~tural language processing systems have been developed[7, 24, 12, 15, 8, 22]. Carimnter and Pollard[4] propose an interlhce to buikl type lattices. Formalizations of extended FSs and of extettd('d feature-descriptions, described above, arc classilicd into two classes: (1) extensions of FSs themselves, and (2) extensions not of FSs themselves hut of Dature-descriptions. Previous attempts to introduce type hierarchies fall into the former clzLss while pre vious treatments of disjunctive and neg~diw~ &'scriptions mainly fall into the latter. ACRES DE COIJNG,92, NAMES, 23-28 AOt33\" 1992 3 8 0 Pl~oc. OF COL1NG-92, NANTES, AUG. 23-28, 1992 This paper proposes an extension to Ait-Kaci's ~/,- type that incorporates three kinds of the primitive negative descriptions described below into the q:-type. Ai't-Kaei's t-type formalization uses term structures. In this paper, both these type structures and the tyl)e symbol lattice on which term strnctures are delined are e×tcuded to treat negative descril)tions. Nega tions of type symbols are treated by extending type symbol lattices, aud negations of feature cxistmmes attd feature-address disagreements are treated by extending term structures. This extension can be seen as intuitionistie. The extension is classified into class (1) abow'.. Based on this paper's formalization, unilieation algorithms have been developed usiug graph unification techniques[23, 16]. Programs based on these alger rithms have been implemented in Common Lisp."]},{"title":"2 Requirements of Negative Descriptions of TFSs","paragraphs":["In describing linguistic information using (tyl)ed) feature structures, negative descriptions make the de-. scription compact, intuitive, and hence easy to understand. For example, we want to deserihe the gramrnaI, ical agreement for an English verb, say \"eat\", naturally a.s follows. ......... , I. r ,,e,. ....."]},{"title":":'\"h] sg (1)","paragraphs":["This description specifies compactly and directly that it is not the case that the person attribute is third and that the number attribute is singular. If we could not use such complex negative descriptions, we would write it using disjunctive descriptions with simple complement types as follows. sy,(ag,'eeme,d ag,{l ...... ,, ~3rd] ]'[ syii(agreeme;',l all, tinumbe'r msg] I J\" (2) or"]},{"title":"{ sy,(.g,~,ae,,t ,,g~[ve~ .... 1st]] 1","paragraphs":["sy,ftag,'eemenl aglIp ....... 2nd]]} (3)","sy,( a.qreeme,d ag, f,,umber pl]] J In this case, (1) is e*Lsier to understand than (2) or (3). In the above ease., we can describe the information because the complex negative descriptions C~tll be transformed into the disjmlction of simple negative descriptions {with ml almost same inteuded mean-ing) and because both person and number features take their values from {lst, 2nrl, 3rd} and {st, pl}. However, it is not always the case that such transformations are possible and that feature takes its value from a finite set. Let us consider more. complicated cases using dif-","t 1 ference lists expressed using featm'e structures. The empty list of categories is represented as follows. x~"]},{"title":"H)","paragraphs":["In the above example, the tag symbol, X1 shows that features in and out must take the same value.","tin HPSG and JPSG (Japanese Ptlrase Structure Grammar), a difference list is very convenient ['or express-ing subcat and slash feature values. llow can oniy nomemptiness be expressed? This is impossible using complement type symbols or dis junctions becmlsc we can consider the set of MI finite length lists whose elements can bc taken froltl inlinitc sets. l)ireet or indirect extension of feature struetures is required. So far, we have discussed the requirement of negative descriptions of type symbols and of l;eature-value agreeumnts from the viewpoint of capability of describing linguistic inR)rmation. There are other ad vantages of allowing negative descriptions. Consider, for exannlde , debttgging processes of gramJt,atical de-scriptlous by parsing sample sentences. We may ob taiu unexpected results Sllch ll.~ il ~l'FS with an tlnex peeled type symbol, a TFS with an unexpected lea tare value agreement and so on. [1/ such sittlations, negatiw~ descriptions can be usefld tools R)r delecting their re~mons. To t/l;tke linguistic descriptions compact and thus ea.uy to understand, to treat natural language efllclently, and to detect error reasons rapidly, it is necessary to develo 1) formalizations and nu'.thods of treating negative descriptions."]},{"title":"a Formal Treatment of Negative Descriptions of TFSs","paragraphs":["As stated earlier, a typed t~:at, ure structure (TI\"S) cousists Of ~t tYl)e syulbol alld a set of feal, tlre-vs.ble pairs. Thus, descriptions of TFSs are chLssitied into descriptions of TFSs having: (1) a certain type symbol (or having a subtype syn,-","hol of a certain type symbol), (2) a feature, and (3) two feature-address vahtes that agree. A TFS can be described by using conjunct, ions and disjunctions of such kinds of descriptions. A eonjmletiw* and disjunctive TFS can be formalized as Nit-Kaei's t-type and ~-type, respectively. That is, a t-type, which has a complex term structure called a g, term a.s its syntax, represents a conjunction of such kinds of descriptkms or at col0unctiw~ typed feaLltrl! structure, and an e-type is a maximal set of ¢ types representing the disjunction of them. Negative counterparts of these descriptions are ebLssified into deseriptions of TFSs: (1') not having a certain tyl)c symbol (or having a","type symbol which is not subsunmd by a certain","type symhol), (2') not having a certain feature, and (3') having two thature-addrcss values that do not","agree. By ineorporatiug strllettlres represelll, illg stlch lll!g-ative descriptions into a O term, a'FFS with the net ative descriptions can be formalized. Such a lerm is called an allglnented t-term and a type with an allg-mented ~/, term ~m its syntax is called an allgllu!nted O-type. From augmented g:-t.erms, an augmented terul eilll be COllStl'lleted ill the S~Lllle Illallll#!l\" tlHlt fill (-terlu is eonstrlleted frolu ¢-t, errns. Next, augmented C-terms and C-types are defined. Terln structures are first allglueuted with strtlctllres representing inhibited features and disagreement of feature address values. Then, type symbol htttiees are extended to inch,de complement type symbols as suggested in [1]. AcrEs DE COLING-92, NAN'rgs. 23-28 AO£~r 1992 3 8 1 1)l~oc. OF COLING-92, NANTES, AUG. 23-28, 1992 3.1 Typed Feature Structures as","Augmented C-Types In order to define complex term structures, a signature is used to specify their vocabulary. It serves as the interface between their syntax and semantics. A signature is formally defined as follows. Definition 1 A signature is a quadruple"]},{"title":"(7-,<_T ,2-,","paragraphs":["V) consisting of: 1. a set 7- of type symbols containing T and _L, 2. a partial order _<7- on 7\" such that","(a) ± is the least and T is the greatest element,","and","(b) every pair of type symbols a, b E 7- have a","least upper bound or join, which is denoted","by a VT\" b and a greatest lower bound or","meet, which is denoted by a AT b, 3. a set .T\" of feature symbols, and 4. a set I] of tag symbols where 7-, 2- and l? are pairwise disjoint. A simple 'type-as-set' semantics is adopted for these objects. That is, a type symbol in 7- denotes a set of objects in an interpretation. Here, 7- and .1_ denote the sets called the universe, written as U, and the empty set 0, respectively. Another element a denotes a nonempty subset of U, written as [a]. The partial order <~- denotes the subsumption relation between these sets; for any type symbols a, b, and c,"]},{"title":"1. a <~ b if","paragraphs":["and only"]},{"title":"if Is| c lb],","paragraphs":["2. a Y:r b = c if and only if [a] O [b] = [el, and 3. a AT- b = c if and only if [a]N [b] = [c]. A feature symbol denotes a function from a subset of U to U. A feature path is a finite string of feature symbols and denotes the function obtained by tile composition of the functions that tile feature symbols denote. A term is defined from a signature. First, a term domain is defined as a skeleton built from feature symbols. Definition 2 A term domain A on 2- is a set of finite strings of feature symbols in 2\" (inclnding the empty string ~) such that 1. Aisprefix-elosed:"]},{"title":"Yp, q(52-*,ifp.q(s A, then","paragraphs":["p (5 A; and 2. A is finitely branching: if p (5 A, then {f (5","2\"1 p .f (5 A} is finite where '.' is the string concatenation operator. An element of a term domain is called a feature address or a feature path. By definition, the empty string e must belong to all term domains and is called the root address. A term domain is represented by a rooted directed graph within which each arc has a feature symbol as its label. A suhdomain of a term domain, corresponding to a subgraph, is defined ms follows. Definition 3 Given a term domain A and a feature address p t5 A, the subdomain of A at p is defined to be the term domain"]},{"title":"Alp","paragraphs":[":= {p' I P' P* (5 A}. The set of all subdomains of A is denoted by Subdom(A). Next, flesh is put on the term structure's skeleton as defined as a term domain by assigning several kinds of objects to each feature address. Ait-Kaci's term structure, the basis of the C-type, is defined by assigning a type symbol and a tag symbol to each feature address as follows. Definition 4 A term is a triple (A, r, v) where A is a term domain on .T, r is a type symbol function fi'om 2-* to T such that r(f* - A) = {T}, and v is a tag symbol 5ruction front A to Y. Given a tag symbol fimction v, Addr. denotes the function from a tag symboJ to tile set of addresses:","Addro(X) :-- {pGAIv(p)=X}. (5) In order to treat negations of feature existences attd feature-address value disagreement, the term structure defined above is augmented by assigning additional objects, a set of inhibited features and a set of disagreement tag symbols, to each feature addrcss. Definition 5 An augmented term is a quintuple (A,r,o,¢,X) where A is a term domain on 5 v, r is a type symbol timer(on from ~'* to T such that r(2-* - A) = {T}, v is a tag symbol function front A to V, ¢ is an inhibited feature filnction front 5 r* to 2 ~ such that ¢(p) is finite for any p (5 A and ~(~'* - A) = {0}, and X is a disagreement tag symbol function from J'* to 2 v such that X(P) is finite for any p (5 A and X(f'* - A) _- {0}, 2 The inhibited feature fimction ¢ specifies which features cannot exist at a given address. There is thus inconsistency if there is an address p in A such that"]},{"title":"¢(p)n{fe2-lp.f(sA} # O.","paragraphs":["(6) The disagreement tag symbol fimction X specifies, for a given address, substructures with which its argument disagrees. There is thus inconsistency if there is an address p in A such that"]},{"title":",(p) e x(1,). (7)","paragraphs":["The disagreement address function Disagr., x frmn A to 2 ~:', based on v and X, takes an address as its argument, and gives the set of addresses with Milch the argument address must disagree, called the disagreement address set and defined as:","Disagrv,x(P) := U Addr.(X), (8)","Xex(v) Augmented terms are hereafter referred to simply as terms unless stated otherwise. Definition 6 Given a term ~ : (A,r,v,¢,X) and a feature address p in A, the subterm of/at the address p is the term"]},{"title":"tip = (A/p,r/p,v/p,~b/p,x/p)","paragraphs":["where"]},{"title":"rip :Jr* ~ T, v/p : Alp ~ V, ¢/p","paragraphs":[":2-\" ~ 2 F, and"]},{"title":"X/P","paragraphs":[": .T\" ~ 2 v are defined by"]},{"title":"(r/p)(q)","paragraphs":[":= 7-(p-q), (9a)"]},{"title":"(v/p)(q)","paragraphs":[":="]},{"title":"v(p.q),","paragraphs":["(91)"]},{"title":"(¢/p)(q) := ¢(p.q), (9r) (X/P)(q)","paragraphs":[":="]},{"title":"X(P'q).","paragraphs":["(9(1) For a term t = (A, r, v, ¢, X), a type symbol a (similarly, a tag symbol or a term t') is said to occnr in t if there is a feature address p in ,X such that r(p) = a (similarly,"]},{"title":"v(p)","paragraphs":["= X or X (5"]},{"title":"X(P),","paragraphs":["or"]},{"title":"lip = t').","paragraphs":["A term t = (A r, v, ¢, X) is said to be regular if the set of all subterms of t, Subterm(t) :="]},{"title":"{t/p ] p (5","paragraphs":["A}, is finite, tlereafter, we will consider mdy regular terms. Ill a regular term, only finite numbers of type symbols and tag symbols occur. 2For any set S, 2 s denotes the set of subsets of S. ACRES DE COLING-92, NANTES, 23-28 AOt3T 1992 3 8 2 PRO(=. OF COLING-92, NANTES, AUG. 23-28, 1992 ~e,apty"]},{"title":"Xl:{}:{}","paragraphs":[":dlist :"]},{"title":"['\"o,,, x2:{j...,~:{}:r ]x2","paragraphs":["Xa:{}:{}:dlist [ X4:{}:{X6}:list ]","= in [first X5:"]},{"title":"{}","paragraphs":[":"]},{"title":"{}","paragraphs":[":"]},{"title":"T","paragraphs":["] out X6 : {} : {X4} : list Figure 1: Examples of Augmented Terms ill Matrix Notation"]},{"title":"lem~ty tnonempty Xl:{} :{}:dlist X3:{}:{) :dlist ,. (~o.t .Clio,,, x4:{}:{x6}.(_ .... _%. X2:{fi,'st}:{} list I x6:{}:{x4}","paragraphs":["ll.t"]},{"title":"li\"~t I ii.,, xs:{}:{}","paragraphs":["T Figure 2: Examples of Augmented 'l~rms ill Directed Graph Notation In a term, any two feature addresses bearing tile same symbol are said to corefer. Thus, tile coreferenee relation g of a terln is a relation defined on A ,as the kernel of the tag flnlctiou v; i.e, ~ := Ker(v) = v -I o v. IIere, g is an equivalence relation and a ~- class is called a corefereuee class. Definition 7 A terln t is referentially consistent if the same subtern* occurs at all feature addresses in a coreference class. If a term is referentially consistent, then by definition, for any Ph p:Z E A, if v(pl) = v(p2) then, for all p such that Pt ' P C A, it follows that P2 ' P (5 A and v(pl \" p) = v(p~ . p). Therefore, if a term is referentially consistent, g is a right-invariant eqnivalence or right-eongrueuee on A. That is, for any Pl, P2 E A, if Pt*¢P2 then (Pl ' P)~:(P2 ' P) for any p such that Pl .pEA. Definition 8 A well-formed term (wft) is a referentially-consistent regnlar term. The set of all well-formed terms is denoted by 14,'.TtrT. A term can be represented in matrix notation. Examples of terms are showu in Figllre 1. In this figure, T, dlist and list are type symbols, in, out and .first are feature symbols, and X1, X2, ... are tag symbols. A matrix represents a set of feature-value pairs preceded by a tag symbol, followed by a set of iuhibited features and followed by a set of disagreement tag symbols. In the term te,,vlv, its snbterms at in and at out corefer while t,~o,,,,,vty is a term ill which its subterms at in aud at out should not corefer. The term te.m£1y should not have the feature address in ..first Willie tnonempty II&S that address, A term can also be represented by directed graphs (DGs). t~,,~,t~ anti t ........ ply in Figure 1 are shown as DGs in Figure 2. The set WY5 r of well-formed terms includes many terms that llave tile same type syml)ol function, tile same coreferenee relations, the same inhibited feature function, and the same disagreelnent address fllllClion but different tag symbol fiUlCtions. These terms have the same infornlation and can describe the same liugttistic object or tile same linguistic phenomena. These ternls construct equivalence classes by reuallllug tag symbols in a certain manner. Delinltion 9 Two terlns tl = (Al,rl,Vl,¢q,?(1} and t~ = (A2, r2, V~, ~2, X-~) are altlhabetical variants of each other if and only if 1. Al = A2, 2. Ker(vl) = Ker(v2), 3. rl = r2, 4. ¢1 = ¢2, and 5. Disagr~,,x ̀= Disagr~,x ,. This is written as 11 ~t~. According to 'type-as-set' semantics, tile symbols T aud ± denote, respectively, tile le&st informative type tile whole universe U aud the overdefined or incousistel,cy type.--the empty set 0. Therefore, a term containing ± should be interpreted as inconsis tent. Such an inconsistency is called a type inconsistency. 'Ib treat such inconsistency, a relation 1~1 on W.~'T is llefiued as follows. Definition 10 For ally two terms tl, t=, G ]4,'.T'T, tl gl t2 if and mdy if.£ occurs in both tl and i 2. There are other kinds of inconsistency as mentioned earlier. If a term contains an address p such that ¢){P)fq {f ~: J:'lp'f (~ A} i¢ 0, it is inconsistent because it means that there are features that should uot exist at. the address. Such an inconsistency is called a feature inconsistency. Ill addition, if a terln contains an address p such that v(p) E X(P), it is inconsistent because it means that tile subterm at p does not agree with itself. Such an inconsistency is called a tag illconsisteucy. llence, the three kinds of inconsistency are treated integratedly by a relation .~ on )4,'S'T delincd as follows. Definition 11 For any two terms it, Z2 C W.T'T, tl U 12 if and ouly if each of them contaius at legist one address p such that t. r(p) : ±, 2. ¢(p)n{f e Jlp.f e A} ¢ O, or"]},{"title":"3..(p) e x(v).","paragraphs":["Clearly, if J~ occurs in a terln, it also occurs in all ternls in its ¢~-class. This is also trne for feature inconsistency and tag inconsistency, lh.'nce, the relations (~ and -U are such that their union ~ becomes an equivalence relation. Thus, we call detincd the augnlented t-types as follows. Definition 12 An augmented &-tyl)e (or ~b-tyl)e for short) It] is an element of tile quotient set, q~ := Syutactic structures of augmented g,-tyl)es will I)e (:ailed augmented ~p-ternls. An augmented typed-feature-structure Call t)e formalized as an anglllented t-type. The set of type symbols 7- has the partial order ~7-which denotes a subsumption relation between the set denoted by type symbols. The partial ordering on 7 can lie extended to augnmuted g~-terms and t-types. Tile sul)smnption orders on )&.T\"T and on are ilefined t~s follows. Acrgs DE COLING-92, NANTES, 23-28 AO~' 1992 3 8 3 PROC. OF COLING-92, NAm'ES, AUG. 23-28, 1992 Definition 13 Let tl = (AI, rt, vl,~bl, Xt) and t2 ="]},{"title":"(A2,r~,v2,C~,X2)","paragraphs":["be WFTs. il is said to be subsumed by t2, written tt _< i2, if and only if either"]},{"title":"tt","paragraphs":["~J_or 1. A~ __ At, 2. Ker(v~) C_ Ker(vl),"]},{"title":"3. vp e Y', n(p) _<r r~(v), 4. Vp E 2-*, #:(p) _c ~t(p), ~nd","paragraphs":["5. Yp (5 5 r*, Disagr~,x,(p) C_ Disagro~,x ~ (p)."]},{"title":"The","paragraphs":["subsumption order on • are defined by [/1] _< [t2] if tl _< t2 is well-defined. Lattice operations on • can be defined to be compatible with the above subsumption order relation as follows. Theorem 1 If (7\";_<7\") is a lattice, then so is ~. Proof. This theorem can he proved in a very similar manner to the counterpart for A'/t-Kaci's 0-terms. Therefore, instead of providing the proof in detail, only the definitions of the least upper bounds-- or joins--and greatest lower bounds~r meets--are provided below. Let t t :","(ml,7\"l,Pl,g])l,XI) and t~"]},{"title":"= (A~,r~,v2,ck2,X2)","paragraphs":["be WFTs. First, the join of t~ and"]},{"title":"t2, ta = tl V t2 =","paragraphs":["(Aa, ra, Va, ~ba, Xa), is defined as follows:"]},{"title":"Aa","paragraphs":["="]},{"title":"Alna=","paragraphs":["(10a) va : Aa ---* ~1 such that Ker(va) = ~x Ntis, (lOb) and Vp"]},{"title":"E .T*","paragraphs":["rs(p) = rx(p) Vz T~(p), (10c) ~ba(p) =-- (pl(p)N~b2(p), and (lOd) XS(P) = {us(q) I q E (Disagro,,xt(p)","NDisagro~,x~ (p))}. (10e)","Next, the meet of t, and t2, t4 = t, A t~ =","(A4, r4, v4, ~b4, X4), is defined as follows:","A 4 = At*], (lla) v4 : A~ ~ I; such that Ker(v4) = r[*l, (llb) and Vp G 9 r\" r4(p) :"]},{"title":"VT{7\"i(q)]P~pq,","paragraphs":["i : 1,2},(lie)"]},{"title":"U{~i(q) lpnpq, i=","paragraphs":["1,2}, (lid)"]},{"title":"~(v) =","paragraphs":["and x4p) = where A['] = Al,,l = g[.l ="]},{"title":"U{v4(q) lqaqr,","paragraphs":["r C (Disagrv~,×~(p) oDisagro~.×~(P)) }~1 le) co U At\"l, n=0"]},{"title":"{","paragraphs":["A1 UA~ for n = O, A ['-q U {p E 9 r I ptct'lq, q E Ai\"-q}","for n > I,","x[\"], n=0 tempty V tnonempty","X/:{} :{}:dlist = [in XS:{}:(}:llst ]"]},{"title":"out","paragraphs":["X9 {} {} list","~etnp[y A ~Tlollelllpl~ X10 : {} : {} : dlist I Xll :"]},{"title":"{first}","paragraphs":[": {Xll} : list","= it, [first X12:{} : {} :T ] out Xll Figure 3: Examples of Join and Meet. of Augmented tb-Terms","o /£2 ) ' for n = 0, i¢['d = ~[,- l] O"]},{"title":"{(p~ • p,p~. v) I pl~t\"-'lv2),","paragraphs":["for n> 1 attd r~,uA~ is the rellexive extension of ~i from Ai to A1UA2 for i= 1, 2. The conditions (lla-lle) define a meet, that collapses to J- whenever conditions (lie--lie) l)roducc some address p such that type inconsistency, feature inconsistency, or tag inconsistency occurs at p. The V is a join operation and A is a meet operation which are compatible with the subsumptiou order defined in Definition 13. [] Examples of join and meet operations on augmented e-terms are shown in Figure 3. The join and meet operations on augmented ~-types correspond to the generalization and unification operations on TFSs. A'it-Kaei defines an ~-type as a maximal set of ~b-types. It is also possible to defir, e an augmented ~- type as a maximal set of augmented ~b-types in the same manner, making disjunctive and negative descriptions possible. 3.2 Type Symbol Lattice Extension to","Include Complement Type Symbols q_¥eating a negative desGil)tion of a given type sylnbol, say a, requires a type symbol I) such that b has only information that unification of it with a yiekls inconsistency, or such that aVT h = -V and aAT b = ±. Such a symbol is called a complement type symbol of a and written as a ~. If a given type symbol lattice (7-; _<7\") is a Boolean lattice, that is, a comI)lcmented 3 distributive lattice, we do not need to do anything. Otherwise, we nmst extend the lattice to include the cmnplements of the type symbols contained in the given lattice. For a finite type symbol lattice T, for example, a Boolean lattice T ~ can he constructed a.s follows. Let ..4 := {at ..... aN} be the set of atolns of 7-, that is, type symbols which cover j_.4 If there are ,ton-atomic type symbols which cover only one symbol, for each such symbol a, a new atom is added aA lattice is called complemented if its all elements have complements.t3] ~a is said to cover b if b <7 a attd b <7 c <7- a implies e = b. Ac'IXS DE COLING-92, NANTES, 23-28 ôtrr 1992 3 8 4 Paoc. OF COLING-92, NANTES. AUG. 23-28. 1992","tsymbol: node structure","{a type symbol}","arcs: ~a set of arc structures) __","~a set of feature symbols) es: ~a set of rtode structures) anoaes:"]},{"title":"fo~a~: ~a .odo s.nc*nro/ I NZL","paragraphs":["arc structure [ #atn,~! I (a feat .... ymbol} [ vM .... I {a node structure} Figure 4: Data Structures","Fnnetion Unify(nodel, node~) begin node1 := Dereference( node l ); node~ := Det,e]erence( node2 ); if node1 = node2 then return(node1); qodel .forward := node~; node2.tsymbol := nodel.tsymbol AT node2.tsymbol; if node2.tsymbol = J_ then return(J_) node2.ifeatures := nodel.i]eatures LI node~.J]eatures; if node2.ifeaturesr'l","{arc.feature I arc • nodel .arcs LJ node2.arcs}","# 0 then return(.L ); aodee.dnodes := node1 .dnodes O node2.dmMes; if {node1, node2} {7 node2.dnodes # ~ theai return(.L ); arcpairs := Shared-Arc-Pairs(node1, node~); for (arc1, arc2) in arcpairs do begin value := Unify( arcl .value, arce.value); if vMue = .1. then","return(l); end; arcs :: Complement~Arcs(node1, node'2); rlodcS2.aFcs := arcs LJ llode~.arcs; return(node*);","end Figure 5: A Destrnctive Graph Unification Function so that a covers all additional type symbol. The extended lattice \"T ~ is tile set of subsets of A with set inclusion ordering. An element {al}iet E \"T' denotes Uie/[al]. The join and mcct operations on T' are the set-nniou and set-intersection operations, respectively. The complement of an element {ai}ie/ in T' is the set-complement of it with respect to .4, that is,"]},{"title":"{~ • .4 l a ¢ {ad,e~}. 4 Implementation of Augmented TFS Unification","paragraphs":["The unification operation for augmented 1/,-terms or augmented TFSs has been implemented using graph unification techniques. A term structure is represented as a directed graph by assigning a graph node to each x-class as in Figure 2. The unification operation for such DGs corresponds to a graph merging operation. This takes two DGs and merges ~-cla.sses of the same feature-aAdress into a n-class. In a destructive graph unification method, which is very simple, suci~ a graph is represented by tile data structures in Figure 4. A node structure consists of live fields: lsymbol for a type symbol, arcs for a set of feature-vafile pairs, ifeatures for a set of inhibited features, dnodes for a set of disagreement nodes i.e., disagreement K-classes, and forward. The field for'warY1 is used for the Union-Find algoritfim[9] to calculate unions of K-classes in tile salne nlanner ,'Lq lluet's algorithm[10}. By traversing two DGs' nodes with the same feature-address sinmltaneously, calculating the union of their x-classes, and copying arcs, their unification can be calculated as in Figure 5. The function Unify takes two input nodes and puts them in a K-class by letting one input be tim forward field values. The flmction then examines three kinds of inconsistency; namely, type inconsistcncy, feature inconsistency, and tag inconsistency. Tim fimction finally treats arcs in order to make tile result graph right-cougruent. For treating arcs, tile function Unify assumes two fimctions, Shared_Arc_Pairs and Complement_Arcs. The function Shared_Arc_Pairs takes two nodes as its inpnts aud gives a set of arc pairs each consisting of both inputs' arcs with a shared feature. The flmctiou Complement_Arcs also takes two nodes and gives a set of arcs whose features exist in the first node but not in the second. An inhibited feature fimetion is implemented using tile tfeatnres field of nodes. When unification of two nodes results in a node witfi an arc witfi a feature in i features, it yields J- because of feature inconsistency. A disagreement tag symbol fnnetion is implemented using dnodes. Unification of two nodes which have each other in their dnodes yields 3. because of tag inconsistency, q_'hese computations require negligible additional computation. qb simplify the exphmation, the destructive version of graph unification is used above. Other versions based ou more efficient graph unillcation methods such ;~s Wroblewski's and Kogure's method[23, 16] have also been developed. 1,'urthermore, it is easy to modify other graph unification methods[21, 6] to allow augmented TFSs."]},{"title":",5 Conclusion","paragraphs":["]'his paper has proposed an augmentatiotl of feature structures {FSs) which introduces negative information into FSs ill unification-based tbrmalisms. Unification-based linguistic formalisnm nse l\".qs to describe linguistic objects and phenotneua, l~ecanse linguistic information (:an |)e described compactly using disjunctive and uegatiw: descriptions, FSs and feao ture descriptions are required to treat such (lescriptrans, in this paper, FSs have been augnlent.ed, using a promising method of fornudizat.iou, Ait-l(aci's $~ type, to allow three kinds of negatiw~ descriptions of them to be treated. In a formalizalion of typed feature structures, negative descriptions can be decomposed rata three kinds of negations: negations of type sytnbols, negations of feature existences, aud llegations of feature-address value agreements. It. is shown thai the second and third kinds Call be treated by ailglncIItlllg tlrl'nl stlill% Lures to include structures representing such kinds of descriptions. Subsnmption relations on augmented terms are defined. It. is also shown that the first kind call be treated by exteuditlg type symbol lattices t() include complement type synd)ols. The proposed formalization cau provide efficient al-AcrEs DE COLING-92, NANTES, 23-28 AOl3\"r 1992 3 8 $ PROC. OF COLING-92, Nhr, n'Es. AUG. 23-28. 1992 gorithms for generalization and unification operations as well as treat primitive negations. The formalization can be integrated with logic-based frameworks such as [20] which can treat wider ranges of descriptions but which do not have such efficient algorithms for these operations. Logic-based frameworks can be used to obtain the data structures for this paper's formalization. Unification algorithms for augmented terms or augmented TFSs have been developed using graph unification techniques. Unification programs based on these algorithms have been developed in Common Lisp. The augmentation of TFSs makes linguistic descriptions compact and easy to understand. In an HPSG-based grammar, for example, non-emptiness of a subcat or slash feature value can be easily described by nsing feature-address value disagreement. Moreover, negative descriptions make debugging proeessss of grammatical descriptions easier. Acknowledgments This research was performed in the VCAT project of the Takeuchi Research Group in NTT Basic Research Laboratories. The author would like to thank Ikuo Takeuehi, Akira Shimazu, Shozo Naito, Masahito Kawamori, Mikio Nakano, and other colleagues of the group for their encouragement and thought-provoking discussions.","References","[1] Hassan Ait-Kaei. An algebraic semantics approach to the effective resolution of type equations. Journal of Theoretical Computer Science, 45:293-351, 1986.","[2] Hassan Ait-Kaci and Roger Nasr. Latin: a logic programming language with built-in inheritance. Journal of Logic Programming, 3:185-215, 1986.","[3] Garrett Birkhoff, Lattice Theory. Americau Mathematical Society, Providence, Rhode Island, USA, 3rd edition, 1967.","[4] Bob Carpenter and Carl Pollard. htclusion, disjointhess and choice: the logic of linguistic classification. In Proceedings o] the 29th Annual Meeting of the Association for Computational Linguistics, pages 9-16, ACL, University of California, Berkeley, California, USA, 1991.","[5] Annuj Dawar and K. Vijay-Shanker. A three-valued interpretation of negation in feature structure descriptions. In Proceedings of the 271h Annual Meeting of Association for Computational Linguistics, pages 18-24, ACL, Vancouver, British Columbia, Canada, 1989.","[6] Martin Emele. Unification with lazy non-rednndant copying. In Proceedings o] the ~9th Annual Meeting of the Association ]or Computational Linguistics, pages 325-330, ACL, University of California, Berkeley, California, USA, 1991.","[7] Martin Emele and Rdmi Zajac. RETIF: A Rewrit-ing System ]or Typed Feature Structures. Technical Report TR-I-0071, ATR, Kyoto, Japan, 1989.","[8] Martin Emele and Rdmi Zajac. Typed unification grammars. In Proceedings of the 13th International Conference on Computational Linguistics, Vol. 3, pages 293-298, 1990.","[9] J. E. ltopcroft and R. M. Karp. An Algorithm for Testing the Equivalence of Finite Automata. Technical Report TR-71-114, Dept. of Computer Science, Cornell University, lthaca, New York, USA, 1971.","[10] G~rard Huet. Rdsolution d'Equations dans des Langages d'Order 1, 2, ..., w. PhD thesis, Universit6 de Paris VH, France, 1976.","[11] Lauri Katttunen. Features and values. In Proceedings of the lOIh International Conference on Computational Linguistics, pages 28-33, Stanford, California, USA, 1984.","[12] Robert T. Kasper. Unification and classification: an experiment in information-hazed parsing. In Proceedings of the International Workshop on Parsing Technologies, pages 1 7, Pittsbnrgh, Pennsylvania, USA, 1989.","[13] Robert T. Kasper and William C. Rounds. A logical semantics for feature structure. In Proceedings of the 241h Annual Meeting o] the Association for Computational Linguistics, ACL, New York, New York, USA, 1986.","[14] Martin Kay. Parsiug in functional unitication grammar. In D. R. Dowty, editor, Natural Language Parsin9, chapter 7, pages 251-278, Cambridge University Press, 1985.","[15] Kiyoshi Kogure. Parsing Japanese spoken sentences based on HPSG. In Proceedings of the International Workshop on Parsing Technologies, pages 132-141, Pittsburgh, Pennsylvania, USA, 1989.","[16] Kiyoshi Kogure. Strategic lazy incremental copy graph unification. In Proceedings of the 131h International Conference on Computational Linguistics, Vol. 2, pages 223-228, 1990.","[17] M. Drew Moshier and William C. Rounds. A logic for partially specified data structures. In Proceedings of the ldth ACM Symposium on Principles of Programming Language, pages 156 167, Munich, West Germany, 1987.","[18] Carl Pollard and Ivan Sag. An Information.Based Syntax and Semantics--Volume 1: bhndamentals. CSLI Lecture Notes Number 13, CSLI, 1987.","[19] William C. Rounds and Robert T. Kasper. A complete logical calculus for record structures representing linguistic information. In Proceedings of Symposium on Logic in Computer Science, IEEE Computer Society, 1986.","[20] Gert Smolka. A Feature Logic with Subsorts. Technical Report LILAC Report 33, IBM Deutschland, 7000 Stuttgart 80, West Germany, 1988.","[21] Hideto Tomabechi. Quasi-destructive graph unification. In Proceedings of the 291h Annnal Meeting of the Association for Computational Linguistics, pages 315-322, ACL, University of California, Berkeley, California, USA, 1991.","[22] Yoshihiro Ueda and Kiyoshi Kogure. Generation for dialogue translation using typed feature structnre unification. In Proceedings of the 13th h~ter. national Conference on Computational Linguistics, Vol. 1, pages 64-66, 1990.","[23] David A. Wroblewski. Nondestructive graph unification. In Proceedings of the 6th National Conference on Artificial Intelligence, pages 582-587, AAAI, Seattle, Washington, USA, 1987.","[24] R6mi Zajac. A transfer model using a typed feature structure rewriting system with inheritance. In Proceedings of the PTth Annual Meeting of Association for Computational Linguistics, pages 1-6, ACL, Vancouver, British Columbia, Canada, 1989. Ac-rEs DE COLING-92, NANTEs, 23-28 ô~'r 1992 3 8 6 Paoc. oF COLING-92, NANTES, AUG, 23-28, 1992"]}]}