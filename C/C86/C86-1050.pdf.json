{"sections":[{"title":"A Simple Reconstruction of GPSG","paragraphs":["Stuart M. Shieber","Artificial Intelligence Center SRI International","and","Center for the Study of Language and Information Stanford University"]},{"title":"Abstract","paragraphs":["Like most linguistic theories, the theory of generalized phrase structure grammar (GPSG) has described language axiomatically, that is, as a set of universal and language-specific conattaints on the well-formedncss of linguistic elements of some sort. The coverage atttl detailed analysis of English grammar in the ambitious recent volume by Gazdar, Klein, Pullum, and Sag entitled Generalized Phrase Structure Grammar [2] are impressive, in part because of the complexity of the axiomatic system developed by the authors. In this paper, we examine the possibility that simpler descriptions of the same theory can be achieved through a slightly different, albeit still axiomatic, method. Rather than characterize the well-formed trees directly, we progress in two stages by procedurally characterizing the well-formedness axioms themselves, which in turn characterize the trees."]},{"title":"1 Introduction I","paragraphs":["Like most llngafistic theories, the theory of generalized phrase structure grammar (GPSG) has described language axiomatically, that is, as a set of universal and language-specific constraints on the we[l-formedncss of linguistic elements of some sort. In the case of GPSG, these elements are trees whose nodes are themselves structured entltics from a domain of categories (a type of feature ~trueture [6]). The proposed axioms have become quite complex, culminating in the ambitious recent volume by Gazdar, Klein, Pullum, and Sag entitled Generalized Phrase Structure Grammar [2]. The coverage and detailed analysis of English grammar in this work are impressive, in part because of the complexity of the axiomatic system developed by the author. In this paper, we examine the possibility that simpler descriptions of the same theory can be achieved through a slightly different, albeit still axiomatic, method. Rather than characterize the well-formed trees driectly, we progress in two stages by procedurally characterizing tim well-formedaess axioms themselves, which in turn charaetei'ize the trees. In particular, we give a procedure which converts GPSG gramma~ into gramma~ written lThls research was m~de possible by a gift. from the System Development Foundation. I am indebted to Lauri K~rttuncn and Ray Perrault for their eomrael~te on earlier drafts, and to Roger Evans, Gerald Gszdsr~ Ivan S~.$t ltenry Thompson, and members of the Foundations of Grammar project at the Center for the Study of Language and Information for their helpful discussions during the development of this work. in a unification-b~qed formalism, the PATR-II formalism developed at SRI International (henceforth PATR) [5], which h~s its own declarative semmltics, and which can therefore be viewed &s an axiomatization of string well-formedness constraints. 2 The characterization of GPSG thus obtained is simpler and better defined than the version described by Gazdar et al. The semantics of the formalism is given directly through the reduction to PATR. Also, the PATR axiomatization has a clear construe-tire interpretation, unlike that used in Gazdar et al., thus mak-ing the system more amenable to computational implementation. Finally, the characteristics of the coml~ilation--the difficulty or ease with which the various devices can be encoded in PATR-- can provide a measure of the expressiveness and indispensability of these devices in GPSG."]},{"title":"2 The GPSG Axioms","paragraphs":["2.1 A Summary of the Principles GPSG describes natural languages in terms of various types of constraints on local sets of nodes in trees. Pcrtlncnt to the ensu-ing discussion are the following:","• ID (immediate dominance) rules, which state constraints of immediate dominance among categories;","• metarules, which state generalizations coI~ccraing classes of ID rules; ¢ LP (linear precedence) rules, which constrain the Ihwar order of sibling categories; • feature cooccurrencc restrictions (FCR), which constrain the feature structures as to which arc permissiHe categories; a feature specification defaults (FS1)), which provide values for features that are otherwise unspecified; and, most importantly, 21towever, a caveat is ]n order th:~t the detailed ~u~alysis from this perspective of the full range of GPSG devices (especially immediate dominance (ID) rules, and feature cooccurrence restrictions) is not discussed fillly here, nor do I completely understand them. (See Section 3.4.} And while in a confessional mood, I should add that the Msorlthm given here has not actually been implemented. 211 ® universal feature instantiation principles, which constrain the allowable local sets of nodes in trees; these feature instantiation principles include the head feature convention (HFC), the foot feature principle (FFP), and the control agreement principle (CAP). In GPSG all of these constraints are applied simultaneously. A local set of nodes in a tree is admissible under the constraints if mad only if there is some base or derived ID rule (which we will call tile"]},{"title":"licensing rule)","paragraphs":["for which the parent node's category is an extension of the left-hand-side category in the rule, and the children arc respective extensions of right-hand-side categories in the rule, and, in addition, the set of nodes simultaneously satisfies all of the separate feature instantiation principles, ordering constraints, etc. By"]},{"title":"eztension,","paragraphs":["we mean that the constituent has all the feature values of the corresponding category in the licensing rule, and possibly some additional feature values. The former type of values are called"]},{"title":"inherited,","paragraphs":["the latter"]},{"title":"instantiated.","paragraphs":["The feature instantiation principles are typically of the following form: if a certain feature configuration holds of a local set of nodes, then some other configuration must also be present. For instance, the antecedent of the control agreement principle is stated in terms of the existence of a"]},{"title":"controller","paragraphs":["and"]},{"title":"eontrollee","paragraphs":["which notions are themselves defined in terms of feature configurations. The consequent concerns identity of agreement features. 2.2 Interaction of Principles Much care is taken in the definitions of the feature instantiation principles (and their ancillary notions such as controller, eontrollee, fl'ce features, privileged features, etc.) to control the complex interaction of the various constraints. For instance, the FFP admits local sets of nodes with"]},{"title":"8la~h","paragraphs":["feature values on parent and child where no such values occur in the licensing ID rule, i.e., it allows"]},{"title":"instantiation of slash features.","paragraphs":["But the CAP's abovementioned definition of control is sensitive to the value of the"]},{"title":"slash","paragraphs":["feature associated with the various constituents. A simple definition of the CAP would ignore the source of the slash value, whether inherited, instantiatcd by the FFP, or instantlated in some other manner, llowevcr, the appropriate definition of control needed for the CAP must ignore"]},{"title":"instantiated","paragraphs":["slash features, but not"]},{"title":"inherited","paragraphs":["ones. Say Gazdar et al.: We must modify the definition of control in such a way that it ignores perturbations of semantic type occasioned by the presence of instantiated"]},{"title":"FOOT","paragraphs":["features."]},{"title":"12, p. 87]","paragraphs":["Thus, the CAP is in some sense blind to the work of the PFP. As Gazdar ctal. note, this requirement makes stating the CAP a much more complex task. The increased complexity of the principles resulting from this need for tracking the origins of feature values is evident not only in the CAP, but in the other principles as well. The head feature convention requires identity of the head features of parent and !,,ad child. The features ayr and"]},{"title":"slash--features","paragraphs":["that can be itfimrited from an ID rule or instantiated by the CAP or FFP, respectively--are head features and therefore potentially subject to this identity condition. However, great care is taken to remove such instantiated head features from obligatory manipulation by the tIFC. This is accomplished by limiting the scope of the ItFC to the so-called"]},{"title":"free","paragraphs":["head features. Intuitively, the"]},{"title":"free","paragraphs":["feature specifications on a category [the ones the HFC is to apply to] is the set of feature specifications which can legitimately appear on extensions of that category: feature specifications which conflict with what is already part of the category, either directly, or in virtue of the FCRs, FFP, or CAP, are not"]},{"title":"free","paragraphs":["on that category. [2, p. 95] That is, the FFP and CAP take precedence (intuitively viewed) over the ItFC. Finally, all three principles are seen to take precedence over feature specification defaults in the following quotation. In general, a feature is exempt from assuming its default specification if it has been assigned a different value in virtue of some ID rule or some principle of feature instantiation. [2, p. 1001 Qazdar et al. accomplish this by defining a class of"]},{"title":"privileged","paragraphs":["features and excluding such features from tile requirement that they take on their default value. Of course, instantiated head features, slash features, and so forth are all considered privileged. However, a modification of these exemptions is necessary in the case of lexical defaults, i.e., default values instantiated on lexical constituents. We will not discuss here the rather idiosyncratic motivation for this distinction, bnt merely note that Icxical constituent defaults are to be insensitive to changes engendered by the HFC, as revealed in' this excerpt: ftowever, this simpler formulation is inadequate since it entails that lexical heads will always be exempt from defaults that relate to their ttEAD features .... Accordingly, tile final clause needs to distinguish lexical categories, which become exempt from a default only if they covary with a sister, and nonlexieal categories, which become exempt from a default if they covary (in relevant respects) with"]},{"title":"any","paragraphs":["other category in the tree. [2, p. 103] Thus the interaction of these principles is controlled through complex definitions of the various classes of features they are applicable to. These definitions conspire to engender the following implicit precedence ordering on tire principles, principles earlier in the ordering being blind to the instantiatlons from later principles, which are themselves sensitive to (and exempt from applying to) features instantlated by the earlier principles) CAP ~.4 FFP ~'- FSDuz ~ tlFC >- FSDno,a~ Of course, all ID rules, both base and derived arc subject to all these principles; yet met,rule application is not contingent on instantiations of the base ID rules. Conversely, LP constraints are sensitive to the full range of instantiatcd features. The precedence ordering can thus be extended as follows: SCurrent efforts by at least certain GPSG practitioners are placing the GPSG type of analysis directly in a PATR-like formalism. This formalism, Pollard's head-drlven phrase structure grammar (ltPSG) variant of GPSG, uses a run-time algorithm similar to the one described in this paper [4]. Highly suggestive is the fact that the ]IPSG run-time algorithm also happens to order the principles in substantially the same way. 4We use the symbol ~- to denote one principle \"taking precedence over\" another. 212","META ~- CAP ~- FFP >- FSDttx ~- ItFC >- FSDno,u~ ~\" LP The existence of such an ordering on the priority of axioms is, of course, not a necessary condition for the coherence of such an aximaatic theory. Undoubtedly, this inherent ordering was not apparent to the developers of the theory, and may even be the source of some surprise to them. Yet, the fact that this ordering exists and is strict leads us to a substantial simplification of the system. Instead of applying all the constraints simultaneously, we might do so sequentially, so that the precedence ordering-- tile blindness of earlier principles in the ordering to the effects of later ones emerges simply because the later principles have not yet applied. This solution harkens back to earlier versions of GPSG in which the semantics of the formalism was given in terms of compilation of the various principles and constraints into pure context-free I~lles. This compilation process can be combinatorially explosive, yielding vast numbers of context-free rules. In-deed, the whole point of the GI'SG decomposition is to succinctly express generalizations about tile possible phrasal combinations of natural languages, ltowever, by carefully choosing a system for stating constraints on local sets of nodes--a formalism more compact in its representation than context-free grammars--we call compile out the various principles and constraints without risking this explosion in practice. The GPSG principles are stated in terms of identities of features. What we need to avoid the combinatorial problems of pure CF rules is a formalism in which such equalities can be stated directly, without generating all the ground instances that satisfy the equalities. What is needed, in fact, is a unification-based grammar formalism [6]. We will use a variant of PATR [5] as the fi)rmalism into which (H)SG grammars are compiled. In partieular, we assume a version of PATR that has been extended by the familiar decomposition into an immediate-dominance and linear-precedence component. Ttfis will allow us to ignore the LP portion of GPSG for the nonce. PATR is ideal for two reasons. First, it is the simplest of the unification-based grammar formalisms, possessing only the apparatus that is needed for this exercise. Second, a semantics for the formalism has been provided, so that, by displaying this compilation, we implicitly provide a semantics for GPSG grammars as well. In the remainder of the paper, we will assume the reader's familiarity with the rudiments of the PATR formalism."]},{"title":"3 The Compilation Algorithm","paragraphs":["We postpone for the time being discussion of the metarules, LP constraints, and feature eooccurrence restrictions, concentrat-ing instead on the central principles of GPSG, those relating to feature instantiation. The following nondeterministic algorithm generates well-formed PATR rules from GPSG ID rules. A GPSG grammar is compiled into the set of PATR rules generated by this algorithm. is written in unordered PATR as"]},{"title":"Xo~Xt, X2 (Xo n) =- (Xo ~) =+ (Xo bar) = 2 (R~) (Xo s,,O) = +","paragraphs":["(Xl bar) = 2"]},{"title":"(x2 s.O) =- Note","paragraphs":["that abbreviations (like 5' for l-n, +v, bar2,-t.subj]) have been mad(; explicit.","In fact, we will make one change in tile structure of categories (to simplify our restatement of the HFC) by placing all head features under the single feature head in tile corresponding PATR rule. We do not, however, add an analogous fcature foot. s Tiros the preceding rule becomes","Xo --* Xi, Xz","(Xo head n) = .-","(Xo head v) = -t-","(xo head bar) = e (~)","(Xo head subj) = +","(Xt head bar) = 2","(X2 head sub l) = - We use an operation addc (read \"add conservatively') which adds an equation to a PATI~ rule conservatively, in Ihc sense that the equation is added only if thc equations arc not thereby rendered unsolvable. If addition would yield uosolvability, thcn a weaker set of unifications arc added (conserw~tively)instead, one for each feature in the domain of tile value being equated. For in-stance, suppose that the operation add~((Xo head) = (Xt head)) is called for, where the domain of the head feature wdues (i.e., the various head features) arc a, b, and c. If the equations in the rule already Sl)ccify that (X0 head a) # (X1 hc~,d a) then this operation would add only the two equations (X0 head b) = (Xl head b) and (Xo head c) = (Xt head c), sincc the addition of the given equation itself would cause rule failure. Thus the earlier constraint of values for the a feature is given precedence over the constraint to be added. In the description of the algorithm, a nonempty path p is said to be defined for a feature structure X if and only if p is a unit path (]) and f ~ dora(X) or p = (h?) and p' is defined for X(f). Our notion of a feature's being defined for a constituent corresponds to the GPSG concepts of being instantiated or of covarying with some other feature. As in the previous definition, we will be quite lax with respcct to our notation for paths, using ((a b) c) and (a (b e) ) as synonymous with (ab c) . Also, we will eonsistcntly blur the distinction betwcen a set of equations and the fcaturc structure it determines. (Sce Shleber [7] for details of the mapping that makes this possible.) 3.2 The Algorithm Itself Now our algorithm for compiling a G PSG grammar into a PATR grammar follows: 3.1 Preliminaries We first observe that a GPSG ID rule is only notationally distinct from an unordered PAI'R rule. Thus, the first step in the algorithm is trivial. For example, the ID rule"]},{"title":",'~ -+ x ~, II[- ,ub j] ( RI )","paragraphs":["5But recall that dawh is a head feature and titus would fall tinder the p~th (head slash) . 213 For each ID rule of GPSG (basic or derived by metarule) X0 \"--' X1,... ,X,,: CAP If"]},{"title":"Xi","paragraphs":["controls Xy (determined by"]},{"title":"Type(Xi) and Type(Xj)),","paragraphs":["then"]},{"title":"adde((Xl con) = (Xj con))","paragraphs":["where"]},{"title":"(head slash)","paragraphs":["if"]},{"title":"(head slash)","paragraphs":["is defined for Xi"]},{"title":"con = (head acr)","paragraphs":["otherwise FFP For each foot feature path p (e.g.,"]},{"title":"(head slash} ),","paragraphs":["ifp is not defined for"]},{"title":"Xo ,","paragraphs":["then"]},{"title":"adde((Xi p) = (Xo p) )","paragraphs":["for zero or more i such that 0 < i <_ n and such that p is not defined for X,'. 6","FSDtez For all paths p with a default value, say, d, and for all i such that 0 < i < n, if"]},{"title":"(Xi bar)","paragraphs":["= 0 and p is not defined for"]},{"title":"Xi,","paragraphs":["then"]},{"title":"add,((X¢ 1) = d).","paragraphs":["HFC For X/the head of X0,"]},{"title":"add~((Xi head) = (Xo head)). FSDnont~z","paragraphs":["For all paths p with a default value, say, d, and for all i such that 0 < i _< n, if"]},{"title":"(Xi bar) # 0","paragraphs":["and p is not defined for"]},{"title":"X¢,","paragraphs":["then"]},{"title":"add¢((X¢ J) = d). 3.3 An Example","paragraphs":["Let us apply this algorithm to the prcceding rule RI. 7 We start with the PArR equivalent Rs. By checking the existing control relationships in this rule"]},{"title":"as currently instantiated,","paragraphs":["we conclude tbat the subject X1 controls the bead )(2. We conservatively add the unification"]},{"title":"(X2 head agr) = (XI).","paragraphs":["This can be safely added, and therefore is.","Next, the FFP step in the algorithm can instantiate the rule further. Suppose we choose to instantiate a slash feature on X2. Then we add the equation"]},{"title":"(Xo head .dash) = (X2 head slash).","paragraphs":["Lexical default values rcqulre no new equations, since no constituents in the rule are given as 0 bar at this point. The tlFC conservatively adds the equation (X0"]},{"title":"head) = (X2 head),","paragraphs":["as )(2 is the head of Xo. But this equation, as it stands, would lead to the entire set of equations being unsolvable, since we already have conflicting values for the head feature"]},{"title":"subj.","paragraphs":["Thus the following set of unifications is added instead: s {X0"]},{"title":"head n) = (X2 head n) (Xo head v) = (X2 head v) (Xo head bar)","paragraphs":["= (X2"]},{"title":"head bar)","paragraphs":["{X0"]},{"title":"head agr)","paragraphs":["="]},{"title":"(X2 head agr)","paragraphs":["(Xo head ;nv) = (x2 head in,) 6Several comments are pertinent to this portion of the algorithm. First, it is the FFP portion that is responsible for its nondeterminism. Second, the operation"]},{"title":"add¢","paragraphs":["is actually superfluous here. The equation can simply be added directly, since we have already guaranteed that the pertinent features are not yet instantiated. By a similar argument, we can conclude that only the"]},{"title":"addc","paragraphs":["operations in the CAP and HFG are actually"]},{"title":"necessary.","paragraphs":["We will use"]},{"title":"adds,","paragraphs":["however, for uniformity. Finally~ we assume that an FSD will place the value ~ on any remaining constituents unmarked for foot features. 7We do not include here the effect of the rule on every feature postulated by Gazdar etal. but only a representative sample. 8A more efficient representation of such sets could be achieved by the introduction of nonmonotonic operations such as overwriting or priority union. But such considerations need not concern us here. 214 Finally, nonlexieal defmdts are introduced for features not in the domains of constituents2 Since the path"]},{"title":"(head inv)","paragraphs":["is defined for the constituents X0 and X2, l° the defanlt value (i.e., '-' according to FSD 1 of Gazdar et al.) is not instantiated on either constituent. Similarly, the"]},{"title":"case","paragraphs":["default value"]},{"title":"(ace,","paragraphs":["FSD 10) is not instantiated on tile subject NP. But the"]},{"title":"conj","paragraphs":["feature default tt ('~') will be instantiated on all three constituents with the equations"]},{"title":"(Xo eo.~,) = ~ (xl conj) = ~","paragraphs":["(xz eonj) = ~ The (partial) generated rule is the following:"]},{"title":"Xs -* X~, Xz (Xo head n) = - (Xo head v) = + (Xo head bar} = 2 (Xo head subl) = +","paragraphs":["(X1"]},{"title":"head bar) = 2 (X2 head subl) = - (X2 head agr) = (X1) (Xo head slash) = (Xz head slash)","paragraphs":["(xo head .) = (xz head .)"]},{"title":"(Xo head v) = (X2 head v)","paragraphs":["(Xo head ~ar) = (xz head bar)"]},{"title":"(Xo head aor) = (X~ head a~r) (Xo head inv) = (-)(2 head inv)","paragraphs":["(x 0 co@ = ~ (X, co@ = ~ (X2 so.j) = ~"]},{"title":"3.4 Problems","paragraphs":["and Extensions Several problems have been glossed over in tile previous discnssion. First, we have not mentioned the role of LP rules. Two possibilities are available for their interpretation: a \"rtm-time\" and a \"eompile-tlme\" interpretation. We can augment tile PATR formalism with I,P rules in tbe same way as Gazdar et al., providing for local sets of nodes to satisfy an unordered PATR rule if and only if the nodes are extensions of elements in the ID rule such that the LP rules are all satisfied. Alteruatively, we can generate at compile time all possible orderlngs of tile unordered rules compatible with ttle LP statements, but this leads us into the problem of interpreting LP statements relative to partially instantiated categories, an issue beyond the scope of tiffs paper. Second, feature eooeeurrenee restrictions were ignored in the previous discussion. Again, we will limit ourselves to a brief diseussion of the possibilities. One alternative is to modify the lat-OWe have made the simplifying assumption that feature specification defaults are stated in terms of simple default values for features, rather than the more complex boolean conditions used in the Gazdar et al. text. The modifications to allow the more complex FSDs may or may net be straightforward. t°The value of the feature"]},{"title":"head on","paragraphs":["the constituent"]},{"title":"Xo","paragraphs":["has the feature"]},{"title":"inv","paragraphs":["in its domain because the unification"]},{"title":"(Xo head iuv} = (X2 head inv)","paragraphs":["gives as value to"]},{"title":"(Xo head inv}","paragraphs":["a variable, the same variable as the value for"]},{"title":"(X2 head ins) .","paragraphs":["Thus the path"]},{"title":"(head lay} is","paragraphs":["defined for Xo and, similarly, for X:. IIWe assume here, contra Gazdar et al., that '~' is a fnll-fledged value in its own right, at least as interpreted in this compilation. Since this value fails to unify with any other value, e.g., '+' or '-', it has exactly the behavior desired, namely, that the feature is prohibited from taking any of its standard values. tice of categories relative to which unification is defined tz in such a way that all categories violating the FCILs are simply removed. Then unification over this revised lattice will be used instead of the simpler w!rsion and FCRs will automatically always be obeyed. Unfortunately, tire possibility exists that unification over tile revised lattice may not bear the same ordcr-in(lependence properties that characterize unification over the freely-generated lattice.. Of course, if this turns out to be the ease, it c~,~ts doubt on the well-fomMedness of the original Gazdar et al. interpre: tation of FCRs as well, apd tlms is an interesting question to pursue. Another alternative involves checking the FCRs at every point in the algorithm, throwing out any rules which violate them at any point. In addition, FCRs would be required to be checked during rau-time as well. This alternative, though more direct, violates the spMt of the enterprise of giving a compilation from the eoml>lex Gazdar et al. formulation to n simpler system. A final problenl concerns the ordering of the III\"C and the (JAIL The definitions of eontroller and controllee necessary for stating ttw CAP depend on the assigmnent of semantic types tr) constitncnts, which in turn deltend on the configuration of features in {;he categorical. We have ah'eady noted that the features pertinent to tit(! definition of sen(antic type (and hence control) do not include instantiatcd fi)ot featttrcs. Indeed, Gazdar et al. claim that \"it is just IlEAl) feature specifications (other than those which are also I?OOT feature specifications) and inherited FOOT fl,aturc specifications that determitre the semantic types relevant to the definition of control.\" [2, p. 87] Unfortunately, the orderiug we have giveu lu'ecludes instantiated head features from participating in the definition of semantic type and hence the CAI)) \"~ It seems that the III\"C nmst apply before che CAP lot the (Mini[ion of semantic type, but after the CAP so that the CAI' instantiatlons of head features take ln,eeedence. Tbus, our earlier claim of strict ordering may be falsified by this case.","Of com-se, the :~et of features neeessat T for type determination and the :act; instantiated by tile CAP may be disjoint. In this case, we can merely split the application of the IIFC in two, in-start[taring the flu'met' class beibre the CAP and tile latter class after the FFP ms originally described. Alternatively, it might be possible to notate head features on the head constituent rather than tim l)arent as is conventlally dtate. In this case, tile information needed by tile CAP is inherited, (tot instantiated, head feature wdues, atnl titus not subject to the ordering problem.","On the other hand, if the sets are nondisjoint, this presents a problem not only for our algorithmic analysis, but for the detinltion of GI'SG given by Gazdar et al. Suppose that the IlFC determines types in such a way that the CAP is required to apply and instantiates head features thereby overriding the original values (since the CAP takes preeedence) attd changing the type determination so that the CAP does not apply. We wouhl thus require the CAP to apply if and only if it does not apply. This paradox :qtpears as an ordcring cych: in our algorithm; in the declarative detinition of Gazdar et al., it would be manifested in the inadmissability of all local set.~ of nodes 11], at( equally unattractive effect. We leave the resolution of this problem open for the time being, merely noting that it is a di|fieulty for GPSG iu general, and not only for our characterization. l~For the technicM background of st[d[ a move, see the discussion of PATR semantics [3]. ~uI am indt:bted to Roger Evens and William Keller for pointing this problem out, to me and for helpful discussion of solution alternatives."]},{"title":"4 Conclusion","paragraphs":["The axiomatic formulation of generalized phrase structure gram° mar by Gazdar et al. is a quite subtle and complex system. Yet, as we have qhown, GPSG grammars cm~ be substantially converted to grammars in a simpler, attd constructive, axiomatic system through a straightforward (albeit procedural) mapping. Intrinsic iu this conversion is the use of a unification-based grammar formalism, so that axioms can be stated schematically, without enumerating all nf their possible instantiations. In fact, we wouhl contend that defining the semantics of a GI)SG grammar in this way yields a much simpler fornmlation. The need for such a reconstruetinn is evident to anyone who has studied tit[: C;azdar et al. text. Of course, even if certain parts of the GPSG for'realism not discussed fully here, i.e., FCRs att(I l,l ) constraints, arc found not to be reducible to PATR, this in itself wouhl be an interesti,g fact. It wouhl slmw that exactly those porticos of the formalism were truly essential for stating certain analyses, i.e., that analyses using those formal devices do so necessarily.","We find a hopefid sign in the recent work in (]PSG that is pro-. ceeding iu the direction of using unilication directly in the rules, in addition to its implicit m~e iu featuce instantiation principles. Wc hope that this paper has provided evidence that such a system may be able to more simply state the kiuds of generalizations that linguists claim, and has pointed out I)oth the possibilities and difllcultics inherent in these tcehniques. i[t~ei~re~ces [1] Gerahl Cazdac. l'ecsonal communication, 1986.","[2] Gerald Cazdar, Ewan Klein, Geoffrey K, I'ullum, att(l Ivan A. Sag. Generalized Phrase Structure Grammar. Blaekwell Pnblishing, Oxford, l(,ngland, atnl l]arvard University Press, Candwidge, Massachusetts, 1985.","[3] l,'ernando C. N. l'ercira and Stuart M. Shieber. The semaa o tics of gran|mar formaIisms seen as COmlmter languages, In Proeecding,~ of the Tenth lntcrnational Conference on Com.. putation.l Linguistics, Stanford University, Stauh)r(l, California, 2-7 July 1984.","[4] Carl Pollard. l,ecture notes ou hcad-driven phrase-structure grammar. Fcbruary 1985. Center for thc Study of l,anguagc and Information, unpublished.","[5] Stuart M. Shieber. The design of a computer language for linguistic information. In Proeecding~ of the \"l~nth International Conference on Computational Lt'ngui,~tic~, Stanford University, Stanford, California., 2-7 July 1984.","[6] Stuart M. Shiel)er. Art Introduction to Unification-Ba.~cd Ap. proache~ to Grammar. CSLI Lectu)v Note Series, Center for the Study of Language aud Information, Stanford, California, Forthcoming.","[7] Stnart M. Shieber. Usiug restriction to extend parsing algorithms for complex-feature-based formalisms. In Proceedings of the 22nd Annual Meeting of the Association for Computational Linguistic.~, Univel~ity of Chicago, Chicago, lllinoi% July 1985. 215"]}]}