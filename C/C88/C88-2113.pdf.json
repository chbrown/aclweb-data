{"sections":[{"title":"Parallel Intersection and Serial Composition of Finite State Transducers","paragraphs":["Mike REAPE 13 and Henry THOMPSON t23","Centre for Cognitive Science l University of Edinburgh 2 Buccleuch Place Edinbm'gh EH8 9LW","Scotland","Department of Artificial Intelligence 2 and","Centre for Speech Tectmology Research 3 University of Edinburgh","80 South Bridge Edinburgh EH1 1HN","Scotland"]},{"title":"Abstract","paragraphs":["We describe a linguistically expressive and easy to implement parallel semantics for quasi-deterministic finite state transducers (FSTS) used as acceptors. Algorithms are given for detemain-ing acceptance of pairs of phoneme strings given a parallel suite of such transducers and for constructing the equivalent single transducer by parallel intersection. An algorithm for constructing the serial composition of a sequence of such transducers is also given. This algorithm can produce generally nondetemlinislic FSTS and an algorithm is presented for eliminat-ing the unacceptable nondeterminism. Finally, the work is discussed in the context of other work on finite state transducers. 1. Introduction Finite state transducers (FSTS) have been shown to be useful for modelling morphophonemic processes in an efficient way in (Karttunen 1983), (Kay 1983), (Kaplan and Kay 1985), (Karttunen, Koskenniemi and Kaplan 1987) and (Koskenniemi 1983) (but cf. (Barton 1986b), (Barton 1986a)). This paper presents a linguistically expressive parallel semantics for quasi-deterministic FSTS used as receptors and algorithms for taking the parallel intersection and serial composition of such FSTS. The intersection and composition algorithms generate composite FSTS from sets of FSTS with the same semantics as the parallel semantics of the set. §2 presents the parallel semantics; §3 discusses the parallel intersection algorithm. §4 discusses the serial composition algorithm. §5 discusses the elimination of unacceptable general nondete~rninism which can arise fi'om the composition algorithm. §6 discusses the implementation of the interpreter which is based on the semantics presented here and the three algorithms. §7 discusses this research in the context of other work in this area and draws some conclusions."]},{"title":"2. A Paraflel Semantics for Finite State Transducers","paragraphs":["In the discussion that follows, we assume that the reader is familiar with the work of Karttunen and Koskenniemi on FSTS and with finite state automata (FSA) generally. The notation used is slightly different than that usually used to describe FSA but is more convenient for our purposes. Also, rather than discuss the algorithms directly, we give their semantics. In contrast to Karttuuen and Koskenniemi's work, no higher level rule formalism is used. FSTS are stated directly. An FST, M, is a pair <NC~,Z> where N ~ is a set of start state urines and Z is a set of states. A state Z i ~ Z is a triple <N,T,A> where N is the name of the state, T is an ordered sequence of transitions Ti, l<i<n, n ="]},{"title":"ITI","paragraphs":["and A is the truth value T if the state is au accepting state and the troth value F if it is a nonaceepting state. (The notion of final state is not relevant here. Only the accepting/nonaccepting distinction is important.) A transition T i ~ T is a pair <~i,Ni> where q5 i is a transition pair <~x,~0~>. An element of a transition pair is either a phoneme, a phoneme class name, the symbol = or the empty string e. A phoneme is a character and is a member of the alphabet set. A phoneme class is a set of phonemes. We will refer to phoneme classes and their names interchangeably. N i is the new state, cI) i = <O~,~0P~> subsumes ~t = <~xt,t)of> if o~i subsumes O x, and ~0 i subsumes ~I~0,. qbi subsutnes (Pt if ~i = ~t or (~i = = or (~i is a phoneme class and ~t ~ q~i' The transition type or type a:(~) of a transition pair fi5 = <@,~P> is (x.x)' if both ~;~ and 0 o are phoneme classes and is x(@).,~(~o) otherwise where x(~) is the phoneme type of q~. (x is not a variable in this and the following definitions.) I! if ~ =","\"~(~) = if ~ = =","otherwise The set of types, TYP, and tile set of final types, TYP0~, arc defined below.","TYP = {=.= x.= =.x x.E E.x x.x =.e e.= (x.e)' (e.x)' (x.x)'} TYP~ = {(x.x)' x.x ..... x x.= x.e c.x e.e} Some examples should clarify the definitions. <s,s> is of type x.x. <s,z> is of type x.x. <sih,sih> is of type (x.x)' if sib is a phoneme class name. <=,=> is of type =.=. <=,e.> is of type 535 The type intersection of a set of transition pairs {~i I l<i<n} is n O'ff¢,~) where n x is a partial function from pairs of u'ansition i=I types to transition types as defined below.","\"q n' \"t 2 if x~ n,' x 2 e TYP \"~a n \"~ = undefined otherwise n,~' is defined as follows. (1) oc- n x' =:13 = (a.[3)' (2) ~.= n./(&.~)' = (a.~)'"]},{"title":"(3) =.f~ %' (cc[~)' = (a.D'","paragraphs":["(4) tx.D n,~' (a.[3)' = a.~"]},{"title":"(5) a.[~ %' c~.l~ = a.~","paragraphs":["(6) =.= nx' a.L3 = ot.13 (7) c~.= n.~' a.l~ = a.I 3"]},{"title":"(8) =.1~ %' c~.~ = a.l~ (9) a.~ c~' ~i.~, = 5.~/c~\" a.[~","paragraphs":["An unprimed type \"c indicates that the transition type is supported. A primed type q:' indicates that the transition type is unsupported. That is, there have been no e.x, x.e or x.x types in tim set of intersected types that produced the primed type. (1) is the origin of unsupported types. (2) and (3) state that neither ct.= nor =.ct can support a transition. (4) states that an unprimed type supports the corresponding primed type. (5) states that the intm'section of two identical .types is the same type. (6) States that the intersection of =.= and any type is that type. (7) and (8) state that the intersection of either =.o~ or co.= and a supported type is a supported type. (9) states that n, c' is commutative and that the commutative closure of (1)-(8) also holds. A set of transition pairs {cI)i} which subsmne (1\"5 t is licensed w.r.t. (I) t if LICENSED({Oi},Ot) holds."]},{"title":"LICENSED({Oi},O t) if n,t'ffOi) e TYP and (nx'c(Oi) e {x.x x.e e.x} or n,~x(Oi) e {(x.x)',","paragraphs":["=.=, =.x"]},{"title":"x.=} and Ot = <¢'¢> )","paragraphs":["This definition implements the \"daisywheel\". That is, although a set of transition pairs {Oi} is excluded in the general case if the type intersection of {O i} ~ {(x.x)', =.=, =.x x.=} we make an exception if qb t is a pair of identical phonemes. So, for example, if the type intersection of {O i} is =.x and ~t = <s,s> then {~i} is licensed. In practical terms, this means that the user does not need to encode a large set of \"default\" transition pairs of the foma <0,¢> for each state. This effect is usually achieved, in other FST fomaalisms in the rule compiler. However, such a compilation depends on the existence of an alphabet declaration. As we do not use a rule compiler, we have found it more convenient to build the effect into the parallel semantics. A machine, M in state N accepts a phoneme pair • t with accepting transition pair • and new state N' if ACCEPTS (M,N,~t,~,N') holds.","ACCEPTS(M,N,Ot,O,N' ) if M = <Net,Z> and Z i = <N,T,A> e Z and 3T k = <Ok,Nk> e~ P(T) ) Ok subsumes Ot and","= <,I,j,Nj> P(r)","1Sj<k and ~j subsumes • r (ACCEPTS replaces the more usual state transition function ft.) P(T) is a total function that takes the transition sequence T as argument and returns a transition sequence T' containing the same set of elements as T with the following ordering of the elements of T'. All =.= transitions follow all non-=.= transitions. All =.~ or f~.= transitions precede all =.= transitions and follow all other transitions. Relative ordering of transitions in T' is as in T otherwise. The definition above implies that transition precedence is by citation order with two exceptions. All transition pairs which have non-= first and second elements take precedence over any pairs of the form <o~,=> and <=,a> and all non-<=,=> transition pairs take precedence over a transition pair of the form <=,=>.","A set of machines {Mi} in states {Ni} accept a phoneme pair","t~ t with accepting transitions pairs {Oi} and new states {Ni' } if",".","(","t","S-ACCEPTS({Mi},{NiL I)t,{N i }) holds.","S-ACCEPTS ({ Mi}, { Ni},Ot, { Ni'}) if Vi 30 i ACCEPTS ({Mi}, {Ni},Ot, {Oi},{Ni'}) and LICENSED({qDi},Ot}). A string is a sequence of phoneme pair elements. A string pair <It,v> is a pair of strings g and v. <oql3> is a prefix of the string pair <g,v> and the string pair <~t',v'> is the corresponding suffix of <It,v> if CONCAT(<oq~>,<It',v'>,<g,v>) holds.","CONCAT(<0~,~>,<g',v'>,<I.t,v>) if","= ~g' and v = 13v' and ~ (a = e A f~ = e). In particular, this means that prefixes can be of the schematic types x.x, x.e and e.x but not e.e. A set of machines {/Vii} in states {Ni} accept a string pair <It,v> with new states {Ni' } if STR ~ ACCEPTS({ Mi}, { Ni} ,<ll,v>, { Ni'})holds.","STR-ACCEPTS({M i } ,{Nil ,<e,e>, { Nil).","STR-ACCEPTS ({Mi}, { Ni},<II,v>, { Ni'}) if ~<OC,[~> ~<[x',V'> 3Ni\" CONCAT(<~,I3>,<~',V'>,<g,V>) and S-ACCEPTS({ Mi}, {Ni},<a,13>, { Ni'}) and STR-ACCEPTS({ M i}, { Ni\"},<l.t',v'> , { Ni' }). The following definition is the top-level relation of our semantics. A set of machines {Mi} accepts a string pair <it,v> if ACCEPTS({Mi},<It,v> ) holds. 536 ACCEPTS({ Mi},<l.t,v> ) if","VM i = <NC~,E> e {Mi} ~Ni a E N a ~Z i = <Ni,T,T> ~ E","STR-ACCEPTS ( { Mi}, {N~\" } ,<bt,V>, { Ni} ), The reader may have noticed that there is no explicit declara-tion of the set of phonemes which define the alphabet of the FSTS. This is the reason that no mention was made of the alphabet in the definition of an FST above as is usually done for finite state machines. This complicates the algorithms to be discussed below a groat deal. In particular, phoneme classes cannot in geaeral be replaced by their definitions, the = notation cannot be compiled away nor can transition sequences be replaced by transition sequences in which d0 ~ and ~P are both phonemes fi)r every transition pair • = <d?k,~)P>. However, explicitly declaring the alphabet is unnecessm'y and a certain flexibility ill the semantics of the FSTS is gained by not doing SO. 3. The Parallel Intersection Algorithm As (Karttnnen and Wittenburg 1983) points out, it is possible to merge a set of pm'allel FSTS into one large FST. In the worst case, the number of states of tile intersected FST is the product of the numl~er of states of the intersected FSTS. In theory, this number can be very large. Ill practice, it is usually much smaller becaase the intersection of most state pairs is undefined. Parallel intersection is associative and commutative. Thus, tile tbllowing detinition of the intersection of a sequence of FSTS is adequate n","N<[VI1 ''' Mn> = (\"h Mi' i=1 The intersection M 1 c~ M2, of two FSTS M t := <N~,Y-.,I> and M 2 = <N~,Y_,2> is their cross product <N{* x N~',E 1 x Z2> The cross product of two state name sets {N i' [ l_<i_<n} and","p tt,.~ {Nj\" ] l<i_<_m} is tile set {<N i ,Nj~ . ] l_<i_<n and l<_j_<m}, The intersection Y'<I,a> = E1 ~ 22 of two states E 1 := <NpT1,AI> and E 2 = <Na,Ta,A2> is )2<1,2 > = <<NI,N2> , T 1 × \"1\"2, A 1 A A2>, I,e., the nanm of the intersection is the pair of the names of the two intersected states. The intersection is an accepting state if both of the intersected states are accepting states and is a nonaccepting state otherwise. The cross product of two transition seqnences T 1 and T 2 is a sequence T t x 'I'~ = <T',_<> where T' is tile set defined below and -<- is a total ordering.","T' = {T k [ T i e T 1 and Tj e T 2 and T k = T i n Tj is defined}. < can be any total ordering which satisfies the following partial ordering on T':","VT m ~ T' 9","V m=T in~I iandr iE r landTje T e VT e T' -9 T n=T oc3 TpandT O c T 1 andTp ~ T 2","(Ill < n go-),","-7 (o < i and p _< j) and-1 (o -< i and p < j)) In particular, the ordering of tile following sequence satisfies the partial order: <T<III > ''\" T<l,n > ... T<m,l > T<m,n>> where T<i,j > names tile intersection of the transitions T i ~ T l and Tj e T 2, m = IWl[ and n = IT2], The intersection T i c5 Tj of two transitions T i = <t~i,Ni> and Tj = <(bj,5> is <tl) i (5 q)'.l' <Ni'Nj>>' If (1) i = .<(zi,[~i> and (l)j = <~,[3j> then • i (-i ~j is defined as follows <a i n cry, ~i n [3i> if ~(d)i) c~' x(Oj) a"]},{"title":"7'YP","paragraphs":["4~ i n cI~) = undefined otherwise The intersection of two phoneme pair elements x and y is defined as follows x ny= x ifx =y x ify = = y ifx = = x if y is a phoneme class and x c: y y ifx is a phoneme class and y ~ x x ¢~ y if both x and y are phoneme classes undefined otherwise The composite FST is nondeterministic with respect to ~; and the set of start states and is deterministic otherwise. All phoneme class and = notation is preserved in the intersected transitions. This is actually quite useful for debugging purposes. In general, it will often be the case that elements of all intersected transition sequence are subsumed by preceding elements in the same sequence. It is a simple matter to remove such transitions (although this is not necessary as they are unreachable). Furthermore, it is often the case that transitions with phoneme classes are partially subsumed by preceding elements in the same transition sequence. It is straightforward to split the phoneme class transitions into disjoint phoneme class transitions which are not subsumed by preceding transitions in the same sequence. Our implementation uses both of these optimisations. Notice that the intersection algorithm does not \"compile in\" the effect of the daisywheel. This is because the semantics of a set of parallel FSTS includes the daisywheel and so the composite FST need not have its effect \"compiled in\". Furthermore, the intersection algorithm must not build in the daisywheel because the composite FST would have the wrong parallel semantics 537 and could not be correctly used as input to tbe intersection algorithm. (I.e., we cannot eliminate = or phoneme classes from any transition pairs.) The cross product of two transition sequences T 1 and T 2 is a sequence T 1 x T 2 = <T',<> where T' is defined below and < is a total ordering. 4. Tile Serial Composition Algorithm Just as parallel FSTS can be intersected, a cascade of FSTS may be composed into one FST. Such a cascade is most useful for representing ordered sequences of rules. For example, a theory which orders assimilation processes before morphophonemic processes could be modelled by a cascade of two parallel sequences of transducers where the first parallel sequence models the assimilation processes and the second models the morphophonemic processes. As is the case with parallel intersection, the number of states of a composed FST is the product of the number of states of the composed FSTS in the worst case. Again, the number of states in the composed FST is usually much smaller in practice. Serial composition is different in several ways from the parallel intersection problem. Fit'st, each FST in the composition must have the parallel semantics of §2 \"compiled in\" before it is composed. This means that type intersection as defined for parallel intersection is irrelevant for composition. On the other hand, we must include the effect of the daisywheel before composition on any transition pair <Op;~,OpP> where both gpX and ¢0 are phoneme classes. As a result, we can replace all such transitions with one or more transitions <¢x,, CO,> •where ¢~' and ~' are both phonemes. This simplifies the composition algorithm considerably. However, we must still check that the type of each transition pair in each FST to be composed is an element of TYP e . (In particular, users may encode illegal transitions.) Also, although serial composition is associative, unlike parallel intersection, it is not commutative. So, a cascade of FSTS must be composed in the same order as they appear in the cascade. The composition of a sequence of FSTS *<M 1 ... Mn> is defined by"]},{"title":"f","paragraphs":["M ifn=l","*<211/t '\" M>: *<M l ... M.t>* M ifn>l k","T'= {TklT i ~ T I and Tje T 2 and T k = T i * Tj is defined}. < must satisfy the same partial ordering as that given for parallel intersection (modulo the substitution of * for n). Again, we use the ordering given in §3. If Z i = <Ni',TI,Ai> and Ej = <Nj',T2,Aj> and T i E T 1 and Tj T 2 then the composition T i * Tj of two transitions T i = <Oi,Ni> and Tj = <~j,Nj> is defined by"]},{"title":"r,*~=","paragraphs":["<<=,=>,<NvNj >>"]},{"title":"<<~,I3>,~/vF> <<a,~>.<v~ ~v/>> <<~,~>,~,':v~>> <<a,~>,~v, Svj>>","paragraphs":["undefined if ~/= <=,=> and Oj = <=,=> if Oi = <=,=> and ~ = <~,13> and <<a;0t>,Nk> fl T 1 ~ k<i if • i = <a,13> and Oj = <=,=> and <<13,13>,Nk> ¢ T 2 ~ k<j if Ot = <a,e> if Oj = <e,[~> if O i = <a.13> and O/= <13,$> otherwise (The fourth and fifth clauses are due to Martin Kay (Kay 1983).) Note that if • i = <a,e> and Oj = <e,13> then both <<(z,e>,<Ni,N'j>> and <<a,~>,<N'i,Nj>> are defined. Their • order relative to each other is irrelevant since the semantics is nondetemainistic with respect to e transitions. Also, note that the second and third clauses dealing with <=,=> transitions are further constrained to eliminate any \"instantiation\" of <=,=> which has lower precedence than a transition with the \"instantiati0n\" in the transition sequence which contains <=,=>. E.g., if <<=,=>,Nj> e T 1 and <<=,=>,Nil * <<b,c>,Nk> = <<b,c>,<Nj,Nk>> and there is a transition <<b,b>,Ni> e T 1 and i<j then <<b,b>,Ni> takes precedence over <<=,=>,Nj> and so the composition is undefined. The composition M 1 * M 2 of two FSTS M 1 =<N~,Y.I> and/Vl 2 =<N~,E2> is their cross product"]},{"title":"<v~","paragraphs":["x"]},{"title":"te~,X 1","paragraphs":["x"]},{"title":"X2>","paragraphs":["The composition Z<l,2 > = Z 1 * Z 2 of two states Finally, note that nondetemainistic transition sequences may be defined. That is, two or more transitions with the same transition pair may be specified which have different new states. E.g., the composition of the transitions <<a,b>,sl> and <<b,c>,tl> is <<a,c>,<sl,tl>> but the composition of the transitions <<a,d>,s2> and <<d,c>,t2> is <<a,c>,<s2,t2>>. Both compositions have the transition pair <a,c> but the new state is the <sl,tl> for the first transition and <s2,t2> for the second transition. This form of nondeterminism is genuine and must be eliminated if the quasi-deterministic semanties that we have outlined is to be maintained. X 1 = <NI,T1,AI> and Z z = <N2,T2,A2> 5. The Determinisation Algorithm is Z<l,2 > = <<Ni,N2>, T 1 x T2, A 1 A A2> I.e., the name of the composition is the pair of the names of the two composed states. The composition is an accepting state if both of the composed states are accepting states and is a nonaecepting state otherwise. As (Barton 1986b) points out, FSTS used as aeceptors are finite-state machines (FSM) with an alphabet of pairs of characters. As such, an equivalent deterministic FST can be construtted.for any nondeterministic FST used as an acceptor since a deterministic FSM can always be constructed that accepts exactly the same language as a nondeterministic FSM (Hoperoft and Ullman 1979). Because the serial composition algorithm may produce nondeterministic FSTS, a determinisation algorithm is required to produce equivalent deterministic FSTS. 538 The algorithm collapses all transitions in a transition :~equence with common transition pairs but different new states into one transition with a complex new state name. This new state name is the name of a state which is the parallel intersection of all the new states\" of the transitions with the common transition pairs. The only fundamental difference between this type of parallel inteisection and the definition presented in § 3 is that a state in the intersected FST is an accepting state if any of the intersected states is an accepting state. Although it may not be obvious, the determinisation algorithm is guaranteed to terminate. The following argument shows why. The new states of simple states are always simple states so complex states are the intersection of only simple states. The number of simple states is finite. The number of transitions within a simple state is finite. It follows that the number of transitions in a transition sequence with common transition pairs is bounded, the number of possible complex states is bounded and the size of a complex state is bounded. Therefore, there is an upper bound on the size of the equivalent deterministic machine and so the determinisation algorithm is guaranteed to terminate."]},{"title":"6. Implementation","paragraphs":["The second author designed the parallel semantics and implemented an interpreter for it in Interlisp-D on a Xerox 1186. The first author designed and implemented the parallel intersection, serial composition and determinisation algorithms in Lucid Common Lisp on a Masscomp MC5700. The programs exhibit reasonable performance (about ten minutes using compiled Lisp for composite FSTS with approximately 160 states). 7. Conclusions and Related Work Although it has been reported in the literature that the algorithms described here have been implemented, we are unaware of the publication of any such algorithms to date. The algorithms themselves are of interest because they formalise the semantics of finite state transducers. Also, these algorithms are similar to graph unification algorithms. Specifically, the parallel intersection and determinisation algorithms can be viewed as cyclic graph unification and graph disjunction elimination algorithms respectively. As Barton points out, a determinisation algorithm like the one presented here will not work on transducers used for generation and recognition (as opposed to simple acceptance). He claims that many FSTS are not determinisable at all. The current work provides a formal basis on which to investigate the class of detemlinisable transducers used for generation and recognition. 9."]},{"title":"References","paragraphs":["Barton, G. E. (1986) Constraint Propagation in Kimmo Systems. In Proceedings of the 24th Annual Meeting of the Association for Computational Linguistics, Columbia University, New York, N.Y., June, 1986, pp45-52.","Barton, G. E. (1986) Computational Complexity in Two-Level Morphology. In Proceedings of the 24th Annual Meeting of the Association for Computational Linguistics, Columbia University, New York, N.Y., June, 1986, pp53-59.","Hopcmft, J. and Ulhnan, J. D. (1979) Introduction to Automata Theory, Languages and Computation. Reading, Mass.: Addison-Wesley.","Kaplan, R. and Kay, M. (1985) Phonological rules and finite.- state transducers.","Karttunen, L. (1983) KIMMO: A general morphological processor. Texas Linguistic Forum, 22, 165-186.","Karttunen, L. and Wittenburg, K. (1983) A two-.level morphological analysis of English. Texas Linguistic Forum, 22, 217-228.","Karttunen, L., Koskenniemi, K. and Kaplan, R. (1987) A Compiler for Two-level Phonological Rules. Technical Report, Center for the Study of Language and Information, Stanford University, 1987.","Kay, M. (1982) When meta-rules are not recta-rules, in Sparck-Jones, K. and Wilks, Y. (cds.) Automatic Nat,ra! Language Parsing, pp74-97. Chichester: Ellis Horwood. Also in M Badow, D Flickinger and I A Sa!, (eds.) Developments in Generalized Phrase Structure Grammar: Stanford Working Papers in Grammatical Theory, Volume 2, pp69-91. Bloomington: [ndiatm University Linguistics Club.","Koskenniemi, K. (1983) Two-level morphology: A general computational model for word-form recognition and production. Publication 11, Department of General Linguistics, University of Helsinki, Helsinki, 1983."]},{"title":"8. Acknowledgments","paragraphs":["This research was supported by the Alvey Speech Input Word Processor and Workstation Large Scale Demonstrator project, ESRC Grants D/29611, D/29628 and 1)/29604. The first author has been supported during the writing of this paper by"]},{"title":"the","paragraphs":["EEC Esprit Project 393 ACORD: the Construction and Interrogation of Knowledge Bases using Natural Language Text and Graphics. 539"]}]}