{"sections":[{"title":"Emergent Parsing and Generation with Generalized HASIDA KSiti Electrotechnical Laboratory 1-1-4 Umezono, Tukuba, Ibaraki 305, J~,pan E-mail: hasida@etl.go.jp Chart Abstract","paragraphs":["A new, flexible inference method for Horn logic program is proposed. It is also a drastic gencndization of chart I)aming, partial instaatiation of clauses in a program ronghly corresponding to arcs in a chart. Chartlike i)al~ing and semantic-head-driven generation emerge from this method. With a parsimonious instantiation scheme for ambiguity packing, the parsing eoml)lexity reduces to that of standard chart-based algorithms."]},{"title":"1 Introduction","paragraphs":["Language use involves very complex interactions anmng very divm.'se types of information, not only syntactic one but also semantic, pragmatic, and so forth. It is hence inappropriate to assmne any specific algorithm for syntactic parsing or generation, which prescril)es particular processing directions (such as left-to-right, top-down anti bottom-uI) ) and is I)iascd fl)r specific types of domain knowledge (such ,'~s a eontext-fl'ee grammar). To accmmt for the whole language use, we will lmve to put many such algorithms together, ending up with an intractably complicated model.","A better strategy is to i)ostulate no specific algorithms for parsing or generation or any particular t~k, but instead a single uniform computational method from which emerge various types of computation in-eluding parsing and generation dei)ending ui)on various computational contexts.","For example, Earley deductiml (Pereir:t & Warren, 1983) is a general procedure for dealing with Horn clauses which gives rise to Earlcy-like parsing when given a context-free grammar and a word string as the inlmt. Shieber (1988) has generalized this method so as to adapt to sentence generation as well. Those nmthods fail to give rise to cllicieut conq)utation for a wide variety of contexts, however, because they prescribe processing directions such ,~ left-to-right f(Jr parsing and bottom-up for generation. They also hu:k a general way of efficient anfl)iguity l)acking unlimited to context-free grammars. Hasida (1994a) i)rol)oses a more general inference method for clausal form logic l)rograms wtfich accounts for efficient parsing and generation ~m emergent l)hmmmena. This mctho(l prescribes no fixed processing directions, and the way it packs ambiguity is not specific to context-free gnunmare. However, it is rather complicated an(l has greater computational complexity than standard algorithms do.","In this i)ai)er we propose another inference method for tlorn logic programs based on Iiasida (1994a), and show that efficient parsing and generation mnerge from it. Like that of Ilasida (1994a), this metlmd is to-tally eonstraint-1):med in the sense that it prcsupl)oSCS no taxed directions of information llow, but it is more ellicicnt owing to a p:trsimonious nmthod of instantiation. In Section 2 we deline this inference method, which is a generalization of chart parsing, and may be also thought of :m a connection method or a sort of l)rogram transformation. Section 3 illustrates how etficient parsing and gencratiml emerge from this method witlmut any procedural stipulation specific to the t:mk and the domain knowledge (syntactic constraints). Section ,1 introduces a parsimmfious instantiation nmthod for ambiguity packing. We will show that owing to this nmthod the ciliciency reaches that of the standard algorithms with regard to context-free l)arsing. Section 5 <:on('huh~'s the paper by touching upon further research directions."]},{"title":"2 Partial Instantiation","paragraphs":["A constraint is represented in terms of a Horn clause prograln such am below."]},{"title":"(a) -p(A,B) -A=a(C).","paragraphs":["(b)"]},{"title":"p(X,Y)-X=a(Y). (c) p(U,W)-p(u,v)-p(v,w).","paragraphs":["Nanms l)cginnlng with eapltal letters rcpreseat variables, ;md the other names l)rc(li(:ates .'unl funetors. The atomic formulae following the maims sign are negative (bo([y) laterals, an(l the others are positive (head) laterals. A cl.'mse without a positive literal is called a top clause, whose negation represents agoM (top-level hYl)othesis), which corrcspomls to a query in Prolog. For instance, top clause (a) in the above l)rogram is regarded as goal"]},{"title":"~_IA, B, C{p(A,","paragraphs":["B) A A = a(C)}. In general, there may be several top clauses. The purpose of computation is to tell whether any goal is satisfiable, and if so obtain an answer substitution for the terms (variat)les) in a satisfiabh~' goal. We consider the minimal Herbrand models as usual. So the set of answer sul)stitutions tbr A in the above i)rogram is {a(B),"]},{"title":"a(a(B)), a(a(a(B))),-..}.","paragraphs":["A graphical representation of this program is shown in Figure 1. Here each clause is the set of the litends enclosed in a dim closed curve. A link connecting argmllnents in a clause is the term (varial)le) filling in 468 Figure 1: A graphical representation of a program. those arguments. (It is a hyperlink when there arc more than two arguments.) A transclausal link represents the unifiability between two corresponding arguments of two unifial}lc It)orals. (Neglect the arrows for a while.)","A hypothesis is a conjunction of atomic formulas and I)indings. The premise of a clause (i.e., the conjunction of the atomic formuhts and bindings which appear ~ negative literals) is a hypothesis. An expansion for a hypothesis is a way of conll)ining (ill-stances of) clauses by resolutions so ~m to transl:tte the hyl}othcsis to another hypothesis involving bindings only. We will refi,~r to an expausion by the sequence of clauses iu the order of lcftnlost aplfiication of reselution using their instances. 1 In the above l}rogram, for exami}le, expansion (e, b, Ii) translaLes the tol)-level hylmthesis s(A,B) A A=a(C) to a hypothesis A=a(C) A C=a(B). An expansion of a clause is an exl)ansiou of its premise. We will simply say 'an exi}ansion' to mean all expansion of the top-level hyl}othesis. A l)rogranl represents a set of expansions, and the COml}ut~tion ~m discussed later is to transform it so a.s to ligure out col rect hypotheses while discarding the wrong expansions (those entailing wrong hypotheses).","We say that there is a dependency between two terms whetl those ternls are unified in some exl);tllSiOll , and the sequence of terms (including them) ntcdiating this unification is called the del)endency l)ath of i, his dependency. In Figure 1, for instance, the dependcacy 1)etween A and X is mediated by dependency path A.X, A.U.X, A.U.U.X, and so on. There is a dependency I}etween C and B, among others, be, cause of the uniliability of the two -o=a(o)s, though ~his unifiability is not explicitly shown in Figure 1. We say a dependency between two terms is consistent when they at'(: not bound 1)3' inconsistent bindings. All tile dependencies in Figure 1 are consistent.","A solution of the program is an expansion ill which every dependency is consistent. St) the {:Oml)utation we propose in this paper is to transform the given program in such a way that every del}endeney be consistent. ~lb figure out dependencies, we use a symt)olic oI)eration called subsumption, and delete the parts of the l}rogram which contrilmtes to wrong exl}ansi{ms","tllere we meution the order anlong the literals in a clause just for explanatory convenience. This order is ltot .sigaificanl, in the computation discussed later. only. For example, suppose there is an inconsistent dependency between terms <~ and ft. We create an instance fl' of fl 1)y substunption operations to be discussed shortly, so that every expansion containing an instance of [31 contains an instance of a del}cndeney path between ¢x and ft. We can then delete tit,\" clause containing flJ and probably sonte more parts of the progranl without affecting the declarative semantics of the program. Below wc will dciine a computational i}roccdure in such a way that the, set of the possil)le expansions eventually represent the set of all the soluti(ms.","Subsmuption operation is to create subsumption relationship. We regard each part (clause, atomic fornmla, term, etc.) of a program as the seg of its instances, and say that a part ~ of the program subsumes another Itart 't I to mean that we explicitly know that ( D ~/. We consider that a link is subsumed by 5 if and only if one of the terms it links is sul}smncd by 5. We say term 5 is an origin of ,q when ~/is sul)sumed by 5. In this )taper we consider that every origin is a bound term (the term filling in the Iirst argmnent of a I)inding). Let us say that two clauses (or two literals) are equivalent when tltey are of the same form and for each pair of correslmnding terms the, two terms have the same sel; of origins.",",qubsuntption relation restricts the possibility of expansions so that if term ~l is subsumed by auother to, rl)l (~,)hell evel'y expansion containing an instance. of 7] 1)ll)St also contain an instance of 5. SttbsUlnl)tion relation is usefld to encode structure sharing among CXIt&IlSiOIIS. [ll Sl)bSlll)ll}[;ioll-});tse{[ ~tppro:tehes~ a ter)lt n)ay subsume several non-unilial)le terms and thus the first term is shared among the latters. IIowever, thai; is intpossibh; in unification-I)ased approaches, where difl'ercnt expansions (:ltl)llOf5 share the same instance of it ~erll) Ol\" [t C[allse.","A partially instantiated clause is a el,'utse some ol7 whose terms is subsumed by another terln in possibly another clause. For instance, O) a(A~,Z)-b(~,~)-c(~,Z). is a I}arti;tl instant)at)on of Lhe followin~ clause:"]},{"title":"(2) a(X,Z)-b(X,Y)-c(Y,Z).","paragraphs":["represents a term sul)sumed I,y t{!l.1]t) A, 2 IIercafter wc say just 'clause' l.o refer to 1)oth uninstantiated clauses al)(l partially instantiatcd clauses.","A program consisting of such clauses is a generalizatiou of a chart (Kay, 1980). A chart is a graph whose node, s denote positions between words ill a selltenee and whose ares are regarded as context-free rules each instant)areal partially with respect to at most two such positions. For instance, an active are front node i to node j labelled with [A -* * H • C] is an instance of rule A -~ l~' C with I}oth sides of B instantiate{l by positions i and j. This arc approxintatcly corresponds"]},{"title":"to (1)2","paragraphs":["2This notation is i)ro]iIelllati(: I)e{:itll,~(! it i8 illlch!~ll' whether ~,w{} OC¢;III'I'I~IICtL~ of A ill il, CIallS(! (IellOt(} the .q;ill|{! t{!l'lll. Ill this paper they alway,'; do.","311owevcr, an arc in a chart does not 1}reclsely {:orl'e,ql}olld to a partlany in.stantlated dau:~c derived fi'om a program enc,}dlng 469","A subsumption operation is to extend subsumplion relation by possibly creating a partially instantiated clause. A subsumptiml operation is characterized by the origin, the source, anti the target. The origin (let it be 5) is a bound term. Tit(.' source (a) and the target (r) are arguments, a should already be subsumed by the origin, but r shmfld not be so. They should be connected through a transclausal link ~. Let the literal containing a be p. Also let the literal containing r be 7r, and the clause containing thmn be (IL There are two cases for subsumption, and in both cases a comes to be linked through ~ with an argument which is an instance of r subsmned by 5.","In the first case of subsumption operation, which we cdl unfolding, a partial iustantiation ,I)' of iI~ is created. They are cquiwdent except that the instance r' of r in (I)' is subsumed by & After the unfolding, a is linked through ~ to tile iustance of r in (D' instead of the originM r, and accordingly p is linked to the instance of 7r in 4)'. Let r\" be ~- after the unfolding. Then r I U r\" = % \"# N \"1\"\" = ~, and r I = \"r ~ a hohl. This impliesr'Caandr'VIo =~. Sot\" atndo are not unifial)le.","For instance, the two suhsumption operations indicated by tim two arrows in Figure 1 are unfohlings. In either case, the origin and the source are both A. The target in the left is X and that in the right is U. We obtain the program in Figure 2 by these operations,"]},{"title":"/","paragraphs":["Figure 2: After subsumi)tions to X and U by A. where partial instantiation (bl) and (el) of (b) atnd (c) have been created, respectively.","In Figure 1, the subsumption opm'atiml through the (invisible) link connecting C and Y is not executable now, because the unification represented by this link presupposes the unification of A and X through the dependency paths A.X, A.U.X, A.U.U.X, and so on. That is, it is only when C subsumes an instance (let it be Y') of Y that subsumption from C to Y' is Imssible. (This subsmnption is an unfohling without any e.opy, a context-fl'ee grammar in a standard w~ty. See Section 4 for further discussion. ? $ because then C automaticMly subsumes Yq) Same for the. subsumption ill the opposite direction.","Tile second ease of subsmnption operation is called folding. It takes place when there is already a literati 7d equivalent to qr except that its argument r' col responding to r is subsumed by 5. In this case, no new instance of clause is created, but instead link h is switched so that it links a with ~\" anti accordingly p is linked with ~'. Let r\" he T after the unfohling. Then r n ~J = 0 both I)efore and after the fi)lding, and o n r is subtracted from r and added to r ~ 1)y tile folding. Fohling is triggered when there exists literal ~' as deseribed abow~', and unfolding is executed otherwise. If the.re existed several such ~ds, folding takes place, creating as nlally iltstauees of ~ and eotllteetitlg to those, 'KIS.","The two subsumption operations indicated in Fig-are 2 are fohlings. Actually, in the. left, the p(.,.) in (bl) att(l tlutt in (b) are equivMent except that the tirst argument of the former is subsunmd by A. So tile link with the arrow arm the paralle.l aceoml)anyiug link are switched up to p(o,.) in (bl). Similarly for tile right subsuml)tion. Shown ill Figure. 3 is the result. /.....,.- ...................... .."]},{"title":"(bU /\" Pt, t,~) \",,\",,~ //x\" P g',',). \\,, (A-~/ ~ ~A~ f / fA2/'---'\\ \"1","paragraphs":["Figure 3: After Rfldiugs.","Note that the original program encodes a im)lflem of partial parsing of a string beginning with \"at\" under the context-free granunar consisting of the following rllles. 1~ ~ a P ~ P P The re.suit in Figure 3 encodes the iutinitely many posstifle parses of this incomplete se,lteuee. Note also that here the subsuml)tiou from C to tit(', instance, of Y in (1)1) would bc possible if C were bound. ']~he next section contains relevant examl)lcs.","When a link is subsumed by two terms bound by two hmonsistent bindings (such am °=a and o=b), then that link is deleted, surrounding clauses possibly be-ing deleted if some of their attomie formubm are linked with no atomic fornmla any more.","For the sake of simplicity, we mainly consider input-bound programs in this paper. We say it program is inlmt-bound when every dependency path between bound terlns eOlluects a tertu ill a top clause and olte in a non-top clause. 'l~he program in Figure 1 and tile ones for parsing ;and geue.ration in the billowing section are all inlmt-lmund programs. For input-bound 470 programs, we have only to eonsider subsumt)tions by terms in top clauses: inl)ut-driven conqmtation. Also, in inlmt-driven computation for inpnt-bound l)rogr~uns we do not have to worry about duplications of origins by subsmnl)timm.","Both subsmnl)tion and deletion preserve the declarative semamtics of tlm program (the set of the solutions), tlmugh we skip at detailed proof due to the sl/ace limitation. 8o when they arc ,rot ;q)plicablc rely more, every expansion is a solutiml atnd vice versa. For input-l)ound programs, the inlmt-driven COmlmtattion alw;tys terminates within time polynomiM as to the size of the program. This is 1)ecanse there are at nmst n ',~ liar - tially instantiated clauses deriv(:d front a clausc with m terms, where n is the size of the inlmt (the trundler of bound terms in the top clause(s)), and accordingly"]},{"title":"there are","paragraphs":["polynomially many tr;umclausal links. Obviously, partially instantiated clauses atnd new transel,'msal links"]},{"title":"are each","paragraphs":["created in constant time.. It is also clear that each fohling ternfinates in polynomial time."]},{"title":"3 Parsing and Generation tlere","paragraphs":["we show that chart-like l)arsing and s(muultic- ]le,%d-driven generation emerge fronl the ;t})ove (:()lll[)llrational method. We discuss examph!s of parsing ~tnd genenttion l)oth on the basis of the Mlowing gratnm~tr."]},{"title":"(3) s(Sem,X,Z)-np(SbjSem,X,Y) -vp(Sem,SbjSem,Y,Z). (4) vp(Sem,SbjSem,X,Z) -v(Sem,SbjSem,ObjSem,X,Y -np(ObjSem,Y,Z). (5) n p(Sem,X,Y) -Sem--tom -X=\" Tom\" (Y). (6) ,p(Sem,X,Y) -Sere=mary -X=\" Ma ry\" (Y). (7) v(Sem,Agt.Pat,X,Y) -Sem=love(Agt,Pat) -X=\" loves\" (Y).","paragraphs":["Since we h&ve ah'e&(ly nle.ntioned aunl)iguity lta(:king ' in the previous section, below we do not explMtly deal with ambiguity but instead discuss jusl; (tit(: senten(:e strneture in both parsing and gener;ttion.","Let us first consider parsing of sentence 'rl?oln lov(:s Mary'. The i)roblmn is encoded I)y the wogram in Figure 4. Tit(: inl)ut-driv(:n COmlmtation l)ro(:eeds as shown by the arrows, which represent subsuml)tio,t op- (:rations taking l)la(:(: in tlm ordering itMic~tted I)y tit(: labclling numbers. A thick del)endency l)atth is llrocessed by successive subsmnptions with the sam(; origin. Tile only subsuml)tion operations exeeul:abh~ in tire initial situation is the one mmfl)ered 1 and ,'tfter that the one nmnbered 2, along the thick I)ath l)etween A0 and X in (5). As the result of these unfoldings, we"]},{"title":"obtain","paragraphs":["the following clauses."]},{"title":"(8) s(Sem,~o,Z)-.p(SbjSem,~0.Y) -vp(Sem,SbjSem,Y,Z). (9) np(Sem,~0,~ll) -Sem=tom -Aoo=\" To.,\" (~).","paragraphs":["Of course other partially instanti~Lted (:l~tuses nmy b(:"]},{"title":"created","paragraphs":["lmre from definition clauses nf"]},{"title":"s","paragraphs":["other than (3) and those of np other tlum (5), but we omit them here iul(l (ZOtl(!(,~lltril.te Oll just one solution,","Now the copy of link with the arrow numbered 3 connected to (9) (:tin mediate subsumption operations. So the subsuml)tion oper~tion indicated tlu~t arrow is triggered, though that does not duplicate (9) because A1 ah'eady subsumes the target. The result is already refieete.d in (9). The subsequent subsumption Oln:r-ations mmtbered ,1, 5, aud 6 will yield the. following claAtses."]},{"title":"(I(I) s(Sem,Ao0,Z)-np(SbjSem,A0,A,) -vp(Sem.SbjSem.Al ,Z). (11) vp(Sem,SbjSem,~,Z) -v(Sem,SbjSem,ObjSem,A1 ,Y)","paragraphs":["-np(ObjSem,Y,Z)."]},{"title":"(12) v(Sem,Agt,Pat,A1,A2)-Sem=love(Agt,Pat) -AI ='' loves\" (A22).","paragraphs":["Now the subsmnl)tion operations by A2 ~L,'e commenced, due. to the creM;ion of (12). Accordingly, tit(.\" following dauses are m'eated, and the parsing is finislw.d.","(13) s(Sem,A0,Aa) -np(SbjSem,A0,A, ) -vp(Sem,SbjSem,A1 ,Aa). (14) vp(Sem,SbjSem,A1,Aa)"]},{"title":"-v(Sem,SbjSem,ObjSem,Al,A2) --n p(ObjSem,A2,Aa). (15) np(Sem,~,Aa) -Sere=mary -A-~2=\" Mary\"(AT).","paragraphs":["From tit(; earlier discussion in the cam'. of context-free parsing tit(', tt(ttllber of ttl[~uses created tl,ere is O(nm), where n is the number of the input words and M the lnaxilnttltt ltlllltb{w of the occurrences of nou-termimd symbols in a eontext-fi'ee rule. This is l~trger than tit(.\" space complexity of the st~tndal'd l)ars - tug Mgorithms, but latter we will show how to improve i;he ellicien(:y so as to be equiwdent to tlt(; standltrd algorithnts.","No l)~wti(mbtr order ~tntollg the subsmnptioa operations is ltrescril)ed in the M)ove COml)utation , ~tnd so it is not inherently limited to toll-down or bottom-up. Note also that tlt(' left-to-right l)rocessiug or(ler among the input words is derived fi'om the dellnitiou strong link, rather than stilmlated a~s in Earley dedue- [i()ll, ltlllOllg others. We can m:(:onnt [or islatn(|-dl'iV(.ql parsing ;Ls well, by Mlowing links between bindings to trigger sul)smnl)tions more earlier.","Let (ts ll(.'xt take. it look at selltellee genel'atioli. Consider the program shown in 1,'igure 5. IIere. the inlmt is semantic structure love(tom,mary). Again the comltutationM pro(:ess is indicated by the numl)ere.d atrrows. (i) (;M~es l)ht(:( ',atfter 5, but the. order ~tm()ng 6, 7, and 6t is ~u'l)itratry ~m long as 6 should be before 7. So the only 1)ossible sultsmnption <)Iteration in the b(:ginning is the ones I)y Love, wlfieh go through the thick curv(: connecting Love ;rod the X in (4). This creates tlt(: following cl~ume, ~unong othm's."]},{"title":"(16) v(Love,Tom,Ma ry,X,Y) - Love= love(To m, M a ry) -X =\"loves\" (Y).","paragraphs":["471 Fig~ure 4: P~u'sing"]},{"title":"Love","paragraphs":["......................................... ............."]},{"title":"=tom","paragraphs":["............. ."]},{"title":"n~ Mary \"i ~e~,~mary. ... . '' \\., -rl","paragraphs":[",J / L '\\\\","=tOlll ..\" /. / i %.•.",". ...... vp ../ j i \"'..,.....","Z",".........................",".-.","....."]},{"title":"'\"\"\"'.,...,....","paragraphs":["\".... .% .... • ...... ,.............."]},{"title":"=mary","paragraphs":["..... \"/"]},{"title":"\\ ..................................... Y Fi#;ui'e S:","paragraphs":["Cener~d;ion 472 Now subsumption operations Call go through the coI)iCs of the other two thick curves. So we arc creating the. following clauses, among others. (17) ~(VO~,X,Z)-,p(Y--o-om~,X,V)-vp(~Y~m,V.Z)."]},{"title":"(18) vp(L-o~,]-om,X,Z)-v(Love,Tom,Mary,X,Y) -np(~,¥,Z). (19) np(To-m,X,Y) -Tom=tom -X=\" Tom\" (Y). (20) .p(M---~,X,Y) -Mary:mary -X=\" Mary\"(Y). Not(:","paragraphs":["tlmt this generation process iunounts to"]},{"title":"a","paragraphs":["gem eralization of semantic-head-driven generation (Shieber, van Noord, & Moore, 1989). The order among the retriewds of semantic heads is the or(h;r of sul)sumI)- tion operations by dilfi;rent terms iu tile input semantic structure, just as with the iiroccssing order iunt)ng words ill the case of parsing. 4 Also its ill the case of i),'trsing, the computational comillexity of such a generation is polynonfial with respect to the siz(: of the inImt semantic stru(.ture, provided that the I)rogr~tnl is inlmt-bound and tile c(unputation is input-driven. Although the above cxami)lc deals with only a single sentence structure, ill general cases ambiguity packing mtturally takes lllace just as with parsing of ambiguous sentences.","Under the restriction that the program be input-bound, tile grammar caunot employ feature stru(:turcs l)rewdcnt ill the current linguistic theories, and also nmst be semantically monotonic (Shiebe, r et al., 1989) ~ The proposed nlcthod can be generalized so as to remove this restriction, though the details do not lit ill the allowed space. This gcneraliz;ttion makes it"]},{"title":"possible","paragraphs":["to deal with fc,'tturc structures and scnumtieally non-nmnotonic grammars. Of course tile cOnll/utlttion is not any nmre generally guantntced to terminate. (because Horn programs can encode '.t~uring machines), but our method still has a t)etter tcxmination prol)crty than more simI)listic ones such im Pro[og interl)retcr or Earley deduction. For instanre, endless cxpansiou of left rceursion or SUBCNF list, which wouhl hal)pen ill simple top-(Iowa conrIlutations, is avoidrxl owing to folding."]},{"title":"4 Incremental Copy","paragraphs":["The parsing process (liseussed above is conllmtatioually more eomplcx than chart parsing, ilere wc iml)rove our method by introducing a more clfi<:ient st:heine for ambiguity I)a(:king and thus reduce the plu'sing complexity to that of chart l)~trsing, which is O(n:) for space aud O(n 3) for time.","Tile present inelfi(:icncy is due to excessive umltiplieation of clauses: much more I)artially instantiate.d (:l~uses arc created than arcs ill a chart. So let us snpposc that a subsumption Ol)eratiml does not dul)li- (:ate a whole clause I)ut only s()me part of it, so tlu~t a clause is coiffed incrcnlentally, as shown in Figure 6. We ,'Lssumc that a subsumption to an argument of a aSo the semantic-head-driven gen[~nttiou parallels bett~n' with left-to-rlg, ht parsing than with syntactic-heard-driven l)arslng;. 5The sem~uttlc monotonicity is practically same as the iuputboun(lness with regard to sem~mtlc structures. literal copies the term filling in tlutt argulnent, the lit-I;ra[, ll, lld sonic othP, r literals which lllelltioll that tel'Ill, unless there have ah'eady been the terms and literals to be thus created. Subscrii)t i of ~t liter;d indic~tes that it is created by the i-th subsumption operation.","Wc must ensure that this partial copying be semantically equiwdent to the copying of whole chumes. That is a trivial business when there ~tre just one or two litcrals in the original clause. The case where there arc more than throe litcrals reduces to tim e,~se where there are exactly three literals, l>y grouping several literals e<)nne<:ted directly (through terms) and treltt thenl i~-'~ if they were one literal. So below let us consider the cruse where there are three' litcrals ill a clause."]},{"title":"A","paragraphs":["non-trivild chet:k must be (loll(! ill Stlch ~L (tas{. ~ as ill the lower right of I\"igurc 6. Here you must copy"]},{"title":"-r(.,.)~ a,.l-q(.,.)~ t)ut .ot -q(.,.), I,~ause-~(...)~","paragraphs":["is compatible with-q(-,.)l but not with -q(.,.). Wc slty that a set of liter.'ds ;trc coml)atible when there is an instance of the obtuse, which involves all instance, of each of those literals. Also, two literals arc said to bc heterogeneous when thc, y haw' different originals in the original uninstanti~tted clltuse. (The original of an origimd literal is itself.) Ill general, when a subsumption Ol)erldfion copies two heterogeneous, directly connected litcrals anti creates two directly connected literals, the nct:r.ssary and sullicient c(mdition fl)r this partiM copy to 1)e semantie:dly equivalent to the full-clause Col)y is obviously that the fin'nmr two literals be conlpatibh:.","When two of the original litcrals ,'tre not (:onnccte(l directly with each other, two heterogeneous literals whic.h have ~ directly conne('.tcd originals are compatible iff they arc also directly emmected; wr. need not eonsi(ler two literals whose originals are not directly (:onnccted, I)ccaus(~ one sul)sullq)tion ollerlttion (lt)(~s not copy such literals at a time.. When MI of the three original literals arc. connectt:d directly with each other, two hetcro,e;e.neous literals are compatible if[' they are ctmnected not only (lirectly but ~dso through another literal heterogeneous to both. Ill flu:t, -r(.,.)~ and -q(*,')l are (:mme(:ted both through tcrnl ~ and through P(°,o)2, but -r(°,°)2 an(l-q(°,.) are not conm~(:ted through any inst,;ume of the original p(.,°).","In the case, of context-free parsing, O(n '~) litr.nd.~ are crt~ate(1, where ,. is tile mnnl)er of words ill the, input string, 1)rovided that the origins o1' sul)suml)tions are the posit.ions I)ctween tilt: inllut words only, (lue to the input-driven COml)utation. Since then; ~u'c jusl; i~ constant times more links than literals, the space (:om-1)Iexity of context-free llarsing hence l)econles"]},{"title":"O(n '2) ill","paragraphs":["our method. The time conq/h.'xity is"]},{"title":"O(n3),","paragraphs":["I)eclulse there are"]},{"title":"O(n)","paragraphs":["different ways of making each literal. Now the correspon(len(:c with vhart pltrsing is more exact. All art: ill the c.h;u't t:orresl)onds to an instantiated lit, oral. For instance, arc [A ---* * H • C] fi'om nolle i to node j corrc~sl)onds to iustanti~tte.d literal -b(A//,,~j), an(l [A -+ • B C *] fi'om n<)(le~ i to node j corresponds to a(~,i,Aj.), l,'t)r .'t contc.xt-free rule with more than two symbols ill tile right-hand side, we can group several literals to oar, ~uu in(!lltiolll2d above &l)d rP.dtlce it to It rule with j,st two symbols ill the right-hand si(h~."]},{"title":"473 subsumption Z'<--_ q(,~.._~,~) subsumption _q(~'~') 0(~,])2 -- P0',~)2 ~ s ubsumption _q(,,, ),~./~<...~_~ - _q(~))","paragraphs":["Figure"]},{"title":"6:","paragraphs":["Sul)sumptions with I,mremcntM Copy"]},{"title":"5 Concluding Remarks","paragraphs":["We have proposed a flexible iufi~'renee method for Ih)rn logic programs. The computation l>;mcd on it is it sort (>f program transformation, and chart l>arsing an<l semantic-head-driven generation are epil)henomena emergent thereof. The proposed method has uothing Sl)C-cific to parsing, generation, context-free gramm~tr, or the like. This indicates that there is no need for any si)ecial algorithms of parsing or generation, or perhaps any other aSl)CCt of natural language l)rocessing.","The i(lelt reported al)ove ha.s already been partially implemented and applied to spoken language under-standing (Nagao, tbusi(ht, & Miyat;t, 1993), and an itCCOllllt Of how the roh:s of speaker ltll(l hcatrer IIHly switch in the midst of it sentence (tlasida, Nagao, & Miy,'tta, 1993). Although this line of work It;us into> porated a notion of dyn,'unics (Ilmsi(la, 1994b) ,'us the declarative semantics to control coutext-sensitive computation, we ;u:e planning to rel)laee dynamics with probability. For inlmt-bound programs together with input-driven (:omputation, it is quite straightforward to deline probabilistie, semantics auq ~t natm'M extension of stochastic context-free grammars, aunong others, because all the body literals are prol)abilistieally independent in that case. We wmfld like to report soon on ,'t generM treatment of probabilisticMly dependmlt literMs whih., preserving the cflieim~t struetm'c sharing, which will gmtrantee etlieient computation and learning."]},{"title":"Reference","paragraphs":["tImsida,"]},{"title":"K., Nagao, K., & Miyatat, T. (19!)3).","paragraphs":["Joint Utterance: Intrmsentential Sl)eakcr/IIearcr Switch as an Emergent I)henonmnon. In Bajcsy,"]},{"title":"R. (Ed.),","paragraphs":["PTveeedinfls of the lgth InteT~zational Joint Conference on Artificial h~telligence Chamb4ry.","llausida, K. (1994a). Common Ihmristies for P~trsiug, Generation, ~md Whateww .... In Strzalkowski, T. ([,~d.), l~eversible Grammar in Natural Language lb'oeessing. Kluwer Ae~ulemie Publisher, Dordrecht.","tlasida, K. (19941)). l)ynamies of Symbol Systems. New Generation ComFitling , 12(3). to ~tppear in May 1994.","Kay, M. (1980). Algorithm Schenmt;t and Datt;~ Structures in Syntactic Processing. Tceh. rep., XE-I/.OX Palo Alto II.escarch Center, PMo All:(), California.","N~tgao, K., Ibusida, K., & Miyata, T. (1993). Under-standing Spoken Natm'M Lauguage with Omni-Directional hfformation Flow. In Proceedings of the 13th International Joint Conference on ArtiJicial Intelligence.","Pereirat, I,'. C. N., & Warren, D. H. ]). (198:/). Parsing as Deduction. In Proceedings of the 21st Awnual Meeting of ACL, I)1 ). 137 14,1.","Shieber, S. M. (1988). A Uniform Architecture. for Parsing and Generation. In Proceedings of the 12th International Conferenee. on Computational Linguistics, pp."]},{"title":"614-619.","paragraphs":["Shieber,"]},{"title":"S. M.,","paragraphs":["v;m Noord,"]},{"title":"G., & Moore, R. C. (1989).","paragraphs":["A Semantic.-th:ad-Driven Generation Algorithm for Unilication-B~sed Forn,Misms. In Proceedings of the 27th Annual Meeting of the Assoeia-tion for Computational Linguistics, 1)i ). 7 17."]},{"title":"474","paragraphs":[]}]}