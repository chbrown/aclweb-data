{"sections":[{"title":"","paragraphs":["DATABASE SYSTEM BASED ON INTENSIONAL LOGIC Naoki Yonezaki, Hajime Enomoto DEPARTMENT OF COMPUTER SCIENCE TOKYO INSTITUTE OF TECHNOLOGY 2-12-1, OOKAYAMA, MEGURO-KU","TOKYO 152, JAPAN","Model theoretic semantics of database systems is studied. As Rechard Montague has done in his work, 5 we translate statements of DDL and DML into intensional logic and the latter is interpreted with reference to a suitable model. Major advantages of its approach include (i) it leads itself to the design of database systems which can handle historical data, (ii) it provides with a formal description of database semantics.","1. INTRODUCTION","There have been developed several knowledge-base systems which utilize mathematical logic, however they can Great facts or rules at the current world only. ~~","In the medical fields or the area of artificial intelligence there are many applications in which the database systems with historical data handling capability are required. For example, in a query to a medical database tHas a sterum treatment been applied to John?' historical data is essential.","One of the reasons why existing database systems provide poor support for such historical information is probably because very few theoretical study has been done yet.","Intensional logic (IL) which Rechard Montague developed to describe semantics of natural language formally seems to be useful to the theory of such database. The first application of modal logic to the logic of database was done by Lipski, though he treated incompleteness of database only.","In the Montague's approach, concepts of intension and extension are used. 5'6 The same concepts can be applied in the theory of database. Correspondence between IL and semantics of database is shown in Fig.l. [Intensional Logic] : possible worlds extension intension meaning postulates :","[Database] states of database data at some state historical data integrity constraints","Figol Correspondence between Intensionals Logic and Database system","The extension of a constant predicate P in IL which corresponds to a relation in database corresponds to the contents in the current database state.","The main purpose of this paper is to describe in a implementation-independent way aspects of those database semantics, which are characterized by interpretation of update operations and queries . And we show the feasibility of using intensional logic for description of the semantics.","The treatment of update of database is closely related to that of assignment in programming language with data type specification facility.","Firstly we use Montaguets intensional logic and later we will introduce two-sorted type theory to treat queries which refer state indirectly.","In section 2, we define a data model treated in this article. This data model is considered as hierachical relational model. In section 3, syntax of intensional logic is defined and its semantics is stated in section 4. In section 5, 6, syntax of query statements and their Montague semantics are given. In section 7, 8, data manipulation statements are introduced and their semantics is also defined. In section 9, semantics of two kinds of null value is stated as meaning postulates. In section i0, we introduce two-sorted type theory and give semantics of statements referring states. Section II is a concluding section.","2. DATA MODEL","In this section we define a data model which corresponds to relational model exploiting hierarchical structure of relations, that is, each component of relation may be also a relation or set of relations recursively. In the Relational Model which Codd 7 introduced, 3rd-normal form or 4th-normal form is exploited to avoid the update anomalies, though we regard it as an implementational matter. Hierachical structure of relation is quite natural for representing information in the real world.","As a part of a data definition language (DDL), schema declaration is formally defined as follows. This DDL describes hierachical schema of database, name of each relation and attribute names or selector names of a relation. When we consider schema of relation, we do not concern the name of relation.","Let S O be the set of all elementary data types e.g. integer, real or string of characters and so on, and F be the set of selector names. Schemas of database are constructed from S O recursively as strings on C t = S O u {[,],',:} F. Def. The set S of schemes is the smallest set S 2 satisfying (i),(2). 220 (i) SimS0US 2, (2) t I ..... tneS I, s I ..... SnEF (si~s j for imj)","=> [sl:t I .... ,Sn:tn]ES2 (l~n). Schema declaration in our DDL is of the form Relation name = t • where t E S.","Now we can define the hierarchical relational database (HRDB) as follows. Def. The set HD of HRDB is defined as","HD= U D t .","t~S For t E S, D t is the set of database whose schema is t defined recursively with the following rules (I), (2).","(i) tES 0 => Dt=E~, where E~ is the set of data -- 5 L havlng elementary type t,","(2) tES and t=[Sl:t I ..... Sn:t n] =>","Dt=2Dt~ ×Dt~ ×...×DL' L n , where Dt~DtiU{NULL1,NIJLL2}.","An exampIe of a database is shown as follows. Example i","Now, we consider an employee relation comprising of tuples which have hierarchical structure. Each such tuple consists of employee number, name, education relation, age, a set of skills and children relation.","Corresponding schema declaration is as follows.","EMPi=[$E:int, NAME:string, EDUCATION:[SCHOOL:string, DEG:string, YR:int], SKILL:[SNAME:string], KIDS:[KNAME:string, AGE:int, SEX:string], SAL:int]","Fig.2 is an instance of database with this schema at some state or world. EMPI","EDUCATION SKILL SE NAME SCHOOL DEG YR SNAME","i CARY J 2 JONES 3 SMITH A NULL2 58 SA B i B 64 SE","SM C A 72 D C 74 NULL1 A NULL2 80","C ! A 50 SB SD SE","KIDS KNAME AGE SEX'SAL JACK 8 M i JILL 5 F 15K JOHN i0 M NULLI !14K MARY 17 F 20K Fig.2 Instance of the Employee Relation","The value 'NULL1' means nothing, however in some state there may be some values. The value 'NULL2' means absolutely no value exists in any state. The order of selector in each tuple is insignificant and order of raw is also insignificant. This hierarchical schema can be visualized by tree graph. Fig.2 is a two-dimensional representation of hierarchical data which reflects the images of data instances. EMPi i $E INAME I sAL I"]},{"title":"I I l","paragraphs":["EDUCATION SKILL Fig.3 A tree graph of hierarchical data","Note that the data declaration in our DDL and this graph show the data structure only while the graph provides a convenient means to visualize the instances. ! KIDS KNAME AGEJ SEX ~","3. SYNTAX OF INTENSIONAL LOGIC","Intensional logic used in the Montaguets approach is based on the theory of types. In this section we describe the extended version of IL according to Gallin. 8 The set of all possible types is recursively defined as follows • Def. Let e, t, s be any three objects. The set of types of IL is the smallest set T satisfying (1)~(3). (I) e, t ¢ T, (2) a, b ~ T => <a, b> E T, (3) a E T => <s, a> E T.","Objects of type e correspond to entities. Type of IL corresponds schema of our DDL or DML. Our schema supports n-ary relations, and it is considered as n-ary function whose range is truth values. For any function of two (or more) arguments there exists an equivalent one which takes one argument at a time, 9 i.e. (Di×D2 × ... ×D n) -> Dn+ 1 corresponds to (D 1 -> (D 2 -> (...-> (D n -> Dn+l)))) ...). In this way we can make the types in IL correspond to schemas of our DDL. Dtype which is a subset of type T in IL is now introduced as follows. Def. Dtype is the smallest set of T A satisfying (1)~(4).","(i) e E T B,","(2) a E T A => <s, a> ~ T B,","(3) a E T B => <a, t> e T A,","(4) be T B, a e T A => <b, a> ~ T A.","Constants of type <s,a> (a E Dtype) correspond to relations with schema corresponding to type a. Such translation will be defined formally in section 6. Intuitively speaking, constants of type <s,<e,t>> --221 corresponds to relations with schema [s: int], [s: real] or Is: string], i.e. single flat domain relation. Constants of type <s,<<s,a>,t>> correspond to relations with schema [s: [...]] i.e. hierarchical relations of single domain whose value is not flat but a relation with schema corresponding to type a. By rule (4), we can define the type of IL corresponding to n-ary relation schemas. Example 2","The type of constant in IL corresponds to relation in Example 1 is which","<s,<e,<e,<<s,<e,<e,<e,t>>>>,<<s,<e,t>> ,<<s,<e,<e,<e,t>>>>,<e,t>>>>>>>. We take CON a (VAR a) to be the set of constants (variables) of type a. Now, we define the set Tm a of terms of IL of type a as follows. Def. (i) CON a c Tm a, (2) VAR a c Tma, (3) A, B E Tm e => A+B, A-B, A,B, A÷B ~ Tm e, (4) A e Tm<a,b >, B £ Tm a => A[B] ~ Tm b, (5) A ¢ Tm b, x E VAR a => ~.x(A) ~ Tm<a,b >, (6) A, B E Tm a => (A-B) E Tm t, (7) A E Tm a => hA E Tm<s,a >, (8) A e Tm<s,a > => VA ETm a' (9) A, B E Tm a, P E Tm t => (P + A, B) e Tm a,","(i0) A ¢ Tm a, c E CON<s,b >, B e Tm b => {B/Vc}A £ Tm a, (Ii) A e Tm t => PA e Tm t, FA e Tm t.","The additional construct (i0) is introduced by Janssen. I0 Following Henkin, II we define sentential connectives, quantifiers and modal operators as follows. Def. (I) T = [kxtxt-~.xtxt]. (2) F = [~,xtxt-AxtT], (3) ~ = Xxt[F'xt], (4) A ="]},{"title":"AxtkYt[If<t,t>[fx.y].~f<t,t>[fT]] ,","paragraphs":["(5) ÷ = kxtkYt[[xAy]'x], (6) V = ~xtAYt[,-.x+y], (7) YxaA = [AxaA'AxaT], (8) ~XaA = ~¥xa~A, (9) [Aa~B a] = [AAa'ABa], (I0) []A = [A~T]. (ii) OA = ~[]~A.","We write [AAB] instead of [[hA]B] where A and B are formulas, similarly for the other binary connectives.","4. SEMANTICS OF IL","The terms of intensional logic are interpreted in an intensional model. Such a model is a system M = (Ma, <, m)a£T, where M a is a frame based on non-empty sets D and I, and < is a linear ordering on S. To simplify following arguments, we make no distinction among 'int', 'real' and 'string', and they are represented by D. Def. Frame is defined as the indexed family (Ma)aE T of sets, where"]},{"title":"(i) Me=D u {NULL1, NULL2},","paragraphs":["(2) Mt=2={0,1}, (3) M<a,b>=MbMa={FIF:Ma->Mb}, (4) M<s,a>=MaI={FIF:I->Ma } U {NULL1, NULL2}.","Function m must be such that if c is a a constant of type a, then m(Ca)eM<s,a >.","Tile assignment g is a function from variable to value such that if x e VAR a then g(x a) e M a. If x a is a variable of type a, and x e M a then g(x/X) denotes the value assignment exactly like g except that it assigns the value X to the variable x.","Now we define the interpretation of a term A a in a model M with respect to the state s and the assignment g. It is denoted by VM,s,g(Aa) and defined inductively as follows. (We dropped the subscript 'Mr.) Def. (i) Vs,g(Xa)=g(Xa), XaEVARa, (2) Vs,g(Ca)=m(Ca)(S), CaeCON a,","(3) Vs,g(Ae+Be)=Vs,g(Ae)+Vs,g(Be) and similar for the other arithmetical operations, (4) Vs,g(A<a,b >[ Ba])=Vs, g(A<a,b>)[Vs,g(Ba)], (5) Vs,g(XXaAb)=the function f with domain M a, such that whenever XeM a then f(x)=Vs,g,(Ab), where g'=g(x/X). By using meta-operator [, we express the above as [ X[Vs,g,(Ab)] ,","(6) Vs,g(Aa-Ba)=l if Vs,g(Aa)=Vs,g(Ba), and 0 otherwise, (7) Vs,g(AAa)=[ j[Vj,g(Aa)] , (8) Vs,g(VA<s,a>)=Vs,~~(A<s,a>)(s),","(9) Vs,g((Pt+A a, Ba))=Vs,g(Aa) if Vs,g(Pt)=l, and Vs,g(B a) otherwise, (10) Vs,g({Bb/VC<s,b>}Aa)=Vt,g(Aa ), where t=<c+V s,g(B b) >s, (II) Vs,g(PAt)=I if there is some s' in S such that s'<s and Vs,,g(A)=1, 0 otherwise, (12) Vs,g(FAt)=l if there is some s' in S such that s<s' and Vs, g(A)=l, 0 otherwise. 222","In the rule (10) t denotes the state in which all constants have values exactly like in s except that the value of Vc is the value of the expression B b in the state s.","We must clarify the notion of state in our model to define the meaning of database. State is understood to present the internal situation of a database. A state is altered by update operations. A new state s I preceeds an old state s 2, i.e. (s2<sl). Clearly a state sEl determines the value of all relations. The effect of update operation is that it modifies the value of single relation, and in order to model this update operation, it should be assumed that the resulting state always exists and is unique.","So we restrict our model for IL which satisfies the following postulates. I) Update postulate","For every t I ~ I, every c ¢ CON<s,a > (a E Dtype) and every i e M a, there exists a unlque t 2 E S such that I Vs,g(C)(t I) = i, Vs,g(C')(t I) = Vs,g(C')(t2),","for all constants c' m c.","2) Uniqueness postulate","For every t i, t 2 e I (t I ~ t$), there","exists c ~ CON<s,a > (a e Dtype) such t~at Vs,g(C)(t I) ~ Vs,g(C)(t2), that is, the result of update operation should be distinct from all of the other states.","Therefore, we can identify a state with contents of database. The database is translated into constant in IL. So the set I of states is defined by"]},{"title":"-N- T","paragraphs":["I = aeDtype c~CON<s,a>Ma","5. QUERY STATEMENTS","Now we introduce a syntax of queries in our","data manipulation language (DML). The set Q of","queries is defined as QiuQ2 recursively. Def. (i) O, I c Qi' (2) d E descriptor => d E QI' (3) ql' q2 ~ Qi => -ql' (ql+q2)' (ql°q2)' (ql÷q2), always ql' past q1' future q2 ~ QI' (4) f ~ Q2' q ~ Q1 =>","q when f, q whenever f c QI' (5) T, F ~ Q2' (6) ql' q2 E Q1 => ql=q2 e Q2' (7) fl' f2 E Q2 =>'If1' (flVf2)' (flAf2)'","(fl=>f2), always f, past f, future f,","f2 when fl' f2 whenever fl E Q2\"","Qi is the set of queries for which an answer is a set of objects. For a query in Q2 an answer is yes or no.","Every descriptor is of the form <R, s I, s 2, A>, where R is a relation name, s], s 2 are sequences of selectors, and A is the ~ubset of D t which is accessed by s 2.","<R, s I, a 2, A> is used to denote the set of ~ element of tuples in the relation R whose s 2","ement is in A. In the above rule (3) all descriptors in (ql+q2), (qloq2) or (q1÷q2) must have the same selector sequence s I as their second component.","We assume certain auxiliary language for describing A which is a subset of the domain D t. Example 3","Let us consider a query, tWas every employee who has a child named Jack educated at school B or C?' on the database given in the previous example. We have a expression","<EMP, NAME, KIDS.KNAME, {Jack}> o -<EMP, NAME, EDUCATION.SCHOOL, {B, C}>=0. Let us consider another example as follows. 'Get all names of employees who always earn more than I0000 or less than 500. I The corresponding expression is","always(<EMP, NAME, SAL, {xlx>10000}> + <EMP, NAME, SAL, {xTx<500}>).","6. SEMANTICS OF QUERIES","We have already defined a model theoretic meaning of IL. Thus the remaining part of Montague semantics is defining a translation which gives for each syntactic structure of the language some meaningful expression of IL. For a part of statement E, its translation into IL is denoted E t. Relation name R is translated into a constant R' of IL whose type is determined by its schema declared at DDL. More precisely this type is determined with next rules. If there is a statement VRname: t' in a data definition part, then type of the constant Rname' is G(t), where G is a function satisfying, Def. G: S -~ Dtype (i) t = [Sl:t I, s2:t 2 ..... Sn:t n] =>","G(t)=F(t)=<s,<F(t I) ,<F(t 2) ..... <F(t n) ,t>>...>, (2) tE S O => F(t) = e.","Each descriptor <R, s I, s 2, A> is translated according to the schema of R and sequences of selectors s I and 82. Let s o denote the common maximal prefix of s I, s 2 and Is0i'~=n, Is I [=n+k, Is 21=n+q, i.e. s I, s 2 are represented as Sl=S01.s02...S0n.Sll.Sl2...Slk, s2=s01.s02 ... S0n. S21.s22...S2q. t For string s, Isl denotes length of s. 223 [<R, s I, s 2, A>]'=","~iSlk (~iSon([R(s01\"'S0n)]'[R'][is0 n] ~̂. • (3il...~im iSll31S21","(VlS0n' [il]...[iSll. ]\"'[is 21]'\"[im]) A [R(Sl2\"\"Slk)]'(iSll )(islk)","̂~iS2q([R(s22...S2q)]'('is21)(is 2 )","V̂A'[ is ])))~ , where the sequence 3ii...3i m 2~oes~ not contain ~iSll or ~'is2 I. The number m and positions of [i ], [i ] in the sequence of","Sll s21 [il]...[i m] are determined self evidently by the DDL statement about R. If n=0 then the first component [R(So1...S0n)]'[R'][i] of the above conjunctive form is replaced by R'-i. If k=0 or q=0 then an appropriate but obvious modification is also needed. It is possible to construct this IL expression systematically according to a micro syntax of a descriptor, however it is somewhat tedious so we do not concern it. When a is a type of sub-schema corresponding to the selector s9], A' is a predicate of type <a, t> in which Aqi) has the value i when an object corresponding to i is an element of A.","Each i s is a bounded variable whose type is the one determined by G and sub-schema corresponding to a selector s used in a relation R.","Translation of R(Sl...Sn) is defined as follows. [R(Sl...Sn)]'=~i~is(3il...~im(Vi[il]...[im ] A[R(s2...Sn)]'(i)(is))) [R(Sn)]'=~i~is(3il...~im(Vi[il]...[is]...[im])) , where, each bounded variable il,..0,i_ has the same type determined by G and su~-schema corresponding each selector which appears in the same level of relation R as the selector s n appears. Moreover the sequence 3ii,..., 3i n does not contain ~i_.","According to the syntax of Q, translation into IL expression is defined as follows. Def. (1) [O]'=A~xEF][x],"]},{"title":"(2)","paragraphs":["[l]'=~̂x[T][x], (3) [-q]'=AXx(~(V[q]'[x])), (4) [ql+q2]'=Axx(vEql]'[x]vV[q2]'[x]), (5) [qloq2]'=A~x(V[ql]'[x]AV[q2]'[x]), (6) [q1*q2]'=A~x(~V[ql]'[x]vV[q2]'[x]), (7) [always q]'=A~x(~V[q]'[x]), (8) [past q]'=A%x(eV[q]'[x]), (9) [future q]'=A~x(FV[q]'[x]), (I0) [q when f]', [q whenever f]': these will be defined in section I0, (11) [T]'=AT, [F]'=AF, (12) [ql=q2]'=A(V[ql]'mV[q2]'), (13) [~f],=A(V[f],), (14) [flVf2]'=A(V[fl]'vV[f2]'), (15) [flAf2]'=A(V[fl]'AV[f2]'), (16) [fl=>f2]'=(̂~V[fl]'VV[f2]'), (17) [always f],=~v[f],, (18) [past f],=pV[f], (19) [future f]'=FV[f] ',","(20) [f2 when fl ]', [f2 whenever fl]': these will also be defined in section i0.","In case of [0]'. [I]', type of x is determined by the context of its usage in a query.","7. DATA MANIPULATION STATEMENTS","Insertion, deletion and update of tuples in database are now considered. We concern the case where we can manipulate either one tuple at a time or a set of tuples with a single command.","Syntax of update statements is defined as follows. Update statements are built up from certain descriptor and operation. More exactly, the set M of data manipulation statements is defined with the following four cases:","I~ (se t oriented update) d: descriptor, <f,d> ~ M , where f means arbitrary operation on the object in the answer of d,","(2) (individual insertion)","(2-i) <R, t> E M , where, R is a relation name and t is a tuple which is intended to be inserted into R,","(2-2) d: descriptor, <d, t> £ M,","(3) (individual deletion)","(3-1) ~<R, t> e M,","(3-2) d:descriptor, ~<d, t> £ M,","(4) (set oriented deletion) ~<R, S, A> ~ M , where, R is a relation name, s 2 is a sequence of selectors and A is the subset of D t which is accessed by s 2.","A set oriented update statement (i) changes all elements in a relation R that are elements of answer for query q by values which is a result of operation f on them. An individual insertion (2-1) means insertion of a tuple t into a relation R as usual, and an individual insertion (2-2) means insertion of a tuple t into the all relations which are elements of answer for query d. We can define the meaning of individual deletions (3-1), (3-2) in the same manner as in the case of insertion by changing the word 'insert w by 'delete v. Set oriented deletion statement (4) deletes all tuples whose values accessed by B 2 are in A from relation R. ~224"]},{"title":"8. SEMANTICS OF DATA MANIPULATION In the Montague semantics, a data manipulation statement is translated into forward predicate transformer, which is a function from a state predicate to a state predicate whose type is <s, t>, and which has the format of an intension of an assertion. So the predicate transformer has a type <<s, t>, <s, t>> and has the format kP(~), where P~VAR<o +> and ~ is a term of type <s, t>. For set orlented update statement, we define the translation into IL as follows. In this definition symbol ,+t is used to designate the • . , + , inverse of the translatlon, i.e. [[E] ] =E for a term E of IL. [<f,d>]'=[R:=[~i l...~is01 ..,~im(~J s01(VR'[il ] ... [Js01] ... [im] A [%R(s02...S0n)]' [ j s01] [ is01 ]))]+]', [%R(s02...S0n)]'=lj~i(i-A(~il...),is02...~i m (~ j s02(vJ[ i I ]...[ j s02]\"'[ i m] ̂[%R(s03...S0n)]' [Js02][is02])))), [%R(S0n)]'= ljNi(i\" A(%i l...Xis0...~im(~-js0n( vj[il]...[Js0n]...[im] A iS0 n\" A( %ii... )~iSll...lis2 I...%im(3 j Sl 1 (Vj SOn[ il ]... [Js11]\"\" [is21]'\"[i m] ̂([$R(s22...S2q)]' [is2 I] ÷ [*R(Sl2...Slk)]'[js ][i s ], • 1.1 11 Zs11\"JSll)))))))), [$R(s22...S2q)]'=li(~il...~is22...~im(Vi[i I] \"\"['Zs22]\"'[im] ̂[$R(s23\"'S2q)]'[is22]))' [ SR(s2q)]'= ~i(~ il...] i2q...~ im( Vi[il]... [is2 ]...[i m] V̂A'[i s ])), • 2q [*R(Sl2...Slk)] '=xjTki~i'A(),il... ~zSl2... Aim (~ Jsl 2 ( vj[ il ]...[ j Sl 2]...[ im ] ̂ ][ • )))), [*R(s13\"\"Slk) ]' [Jsl 2 zSl2] [*R(Slk)] '= Aj Ni(i\" (̂ ki I ...~iSlk..,%im(~ j Slk(Vj [il]'\"[Jslk ]'''[im] ̂iSlk= f'( 3Slk' )))))\" For individual insertion or deletion their translations are as follows. [<R,t>]'=[R:=[lil...lim(il=tl A ... A im=t m -+ T, R'[il]...[im])]+] ', [~<R,t>]'=[R:=[Xil...~im(il=t I ̂... ̂im=t m -+ F, R'[il]...[im])]+] ' • where we assumed t=<t I, t 2, ... ,. t~>.. If n=0, k=0 or q=0 then appropriate modlflcatlons are needed as in the case of query statements. For insertion operation <d,t> and deletion operations ~<d,t>; ~<R,S,A>, we can define their corresponding IL expressions in the same manner as shown in the case of set oriented update. By using an intensional version of Floyd's semantics of assignment 12 [A:=B]'=IP~̂z[{z/VA'}VpAVA'-{z/VA']B'], and semantics of composition [A;B]'= %P[ B'(A'(P))], we complete the definition of the semantics of the update statements, Now, we consider the following simple example for comprehension of the above definition. Example 4 Suppose relation EMP2 is declared at data definition part as EMP2=[ KIDS:[NAME:string, AGE:in,I, SAL:int], and that before the update, <*2,<EMP2, SAL, KIDS.NAME, {Jack}>> holds that A([<EMP2, SAL, KIDS.NAME• {Jack}>]' -AXx(x-20')). We denote this precondition by PC. The translation of the update statement is [<*2, <EMP2, SAL, KIDS.NAME, {Jack}>>]' = [EMP2:=[XiKXis(~js(VEMP2'(iK)(Js ) A(~iN~iA(ViK(iN)(iA)îA'Jack ') is-Js*2 , is=Js)))]+]' =%pA~z({z/vEMP2'}vpAvEMP2'-{z/vEMP2 ' } (%iK~is(~js(VE~2'(iK)(Js) A(~iN~iA(ViK(iN)(iA)AiA'Jack ') is-Js*2, is=is))))). PC=A(A~is(~iK(VEMP2'(iK)(is)A ~iN~iA(ViK(iN)(iA)AiN'Jack'))) -~̂x(x-20')). Then after the update, A~z(A~is(~iK(z(iK)(is)A~iN~iA(ViK(iN)(iA ) îN-Jack')))-A%x(x-20')) V̂EMP2''(%iK~is(~Js(Z(iK)(Js) (̂~iN~iA(ViK(iN)(iA)AiA'Jack ') ÷ is-Js*2, is'Js))))) • From this we derive that, %̂is(~iK(VEMP2'(iK)(is)A~iN~iA(ViK(iN)(iA ) AiN-Jack')))-A~x(x-40'). Example 5 As another example, we consider the relation as follows. EMP3=[NAME: string, MGR: string]. For this relation we perform an update such as the manager of manager of John is Smith, i.e. <=Smith,<EMP3,MGR,NAME,<EMP3,MGR,NAME,{John}>>>. The translation of this update statement is [<=Smith, <EMP3, MGR, NAME, <EMP3, MGR, NAME, {John}>>>]' --225","paragraphs":["=[ EMP3 : =[~ iN%iM( ~ jM ( VEMP3, (iN) ( jM ) A(V[<EMP3, MGR, NAME, {John}>]'(iN) + JM-Smith,, JMmiM)))]+] ' =[EMP3 :=[%iNAiM(~JM (vEMP3 ' (iN) (jM) A(VA~iM2(~iN2(VEMP3'(iN2)(iM2)","îN2-John')) (i N ) -+ JM-Smith,, JM-iM)))]+] '","=~P~̂z( { z/VEMP3' }VpAVEMP3'- (~iN%iM(~OM (z(i N ) (jM) ̂( ~ iN2 ( z ( iN2 ) ( i N ) ̂iN2-John ' )","-+ JM-Smith', JM'iN))))). Assume that before the update holds that (̂([<EMP3, MGR, NAME, {John}>]'-X̂x(x-John'))","A([<EMP3, MGR, NAME, {Smith}>]'-","A~x(x-Jack'))). Then we obtain that afterwards ~̂z(z(John') (John')ẑ(Smith') (Jack') V̂EMP3 \"( % iN%iM ( ~jM ( z( i N ) ( jM ) A(~iN2(z(iN2) (iN)AiN2mJohn ' ) ÷ JM-Smith', JM-iM))))). This implies VEMP3 ' ( John ' ) ( Smith ' ) ̂VEMP3 ' ( Smith ' ) ( Jack ' ).","9. SEMANTICS OF NULL VALUES","We can define various kinds of null values, indeed ANSI/SPARC interim report 13 cites 14 possible manifestations of null. However, the two important kinds of null value have the meanings 'value at present unknown' and 'property inapplicable'.","Formal treatment of the first kind of null value has been resolved by the ideas of null substitution principle and non-truth functionality princip i e. 4'14","In this article we study the second kind of null value more precisely. We introduced two null values NULL1, NULL2 of the second kind of null values. NULL1 is intended to mean that nothing exists at current state but there may be some states in which the value exists. NULL2 is intended to mean that there exists absolutely no value in any state.","Those semantics are formally defined by auxiliary update postulates. (i) Update postulate for NULL1","For every tlEl and every A ~ Tm<s,a > (a=<al,<...<an,t>>...> e Dtype),","if Vs,g(A) (tl) (fal)... (fak)... (fan)=l and f ak=NULL1 ,then Vs'g(A)(tl)(fal )'''(hak)'''(fan)=0","hak E MaC{NULL1] for all and there exists t2¢I such that V s,g(A) (t2) (fal)...(rak). . . (fan)=l for rake Ma~{NULLI , NULL2}. !2) Update postulate for NULL2","For every t1£I and every A ~ Tm<s,a > (a=<al,<...<an,t>>...> E Dtype),","if Vs,g(A)(tl)(fal)...(fak)...(fan)=l and f ak=NULL2 , then for every t 2 e I and every h c M -{NULL2}","a k a k","Vs,g(A) (t2) (fal) ... (hak) ... (fan)=0 •","i0. SEMANTICS OF STATE REFERENCE","To define the semantics of queries with 'when' or 'whenever', it is necessary to consider the case that s is a type. We define such a logic called Two-Sorted Type Theory, and denote it by Ty 2. Def. The set T' of types of Ty 2 is the smallest set such that (i) e, t, s E T', (2) a, b e T' => <a,b> E T'. Note that T c T' (T: the set of types of IL). Def____~ The sets Tm~ of terms of Ty 2 of type a are defined with the following rules recursively. (I) CON s c Tm~, (2) VAR a c Tm~, (3) A, B E Tm~ => A+B, A-B, A'B, A÷B e Tm~,","T ' ' => A[B] E m b, (4) A E TmSa,b>, B e Tm a (5) A E Tm~ => %XaA £ ' Tm<a,b>, (6) A, B ~ Tm~ => (A-B) ¢ Tm~, (7) A, B e Tmta, P E Tm~ => (P ÷ A,B) ~ Tm~,","(8) A e Tm~, c E CON<s,b>, x e VARs, B E Tm~ => {B/c[x]}A ~ Tm~, (9) A ~ Tm~ => PA e Tm~, FA e Tm~.","To define the semantics of Ty 2 the model M'=(M a, < , m)ae T, is introduced, where M a is a frame based on non-empty sets D, I, and < is a linear ordering on I.","We define the frame as the indexed family (Ma)aE T, of sets, where Def. (I) M e = D U {NULL1, NULL2}, (2) M t = 2 = {0, 1}, (3) M s = I, (4) M<a,b > = MbMa ={FIF: M a -> Mb} (for a~s), (5) M<s,a > = MaI = {FIF: I -> Ms}U{NULLi,NULL2}.","For each constant Cs, m(Ca) E M a, and for each variable x a, g(Xa) c M a. Interpretation of term A a which is denoted VM,g(Aa) is defined in such a way that the following conditions hold. (We dropped the subscript 'M'.) 226 Def. (i) Vg(x a) = g(Xa), x a E\" VAR a, (2) Vg(C a) = m(Ca), c a ~ CON a, (3) ~ (7) similar to the case of IL,","(8) Vg({Bb/C<s,b>[Xs]}Aa)=Vg'(Aa ), , where g'=g(xs/X), x s ~ VARs, X c I, such that for all constant C~s,b > except c, Vg(ci[Xs ]) = Vg,(Ci[Xs ]) and Vg,(C[Xs]) = Vg(B), (9) Vg(PA t) = 1 if there is some g' = g(xs/X) such that g'(x s) < g(x s) and Vg,(A) = i, 0 otherwise, (i0) Vg(FA t) = I if there is some g' = g(~s/X) such that g(x s) < g'(x s) and Vg,(A) = I, 0 otherwise.","For each term A a of IL we can define the translation of A a in Ty 2. Such translation is defined with next rules, and denoted A:. Def. (i) [Xa]* = x a,"]},{"title":"(2) [Ca]* = C<s,a>[Xs],","paragraphs":["(3) [A<a,b>[Bb]]* = A*[B*], (4) [hXaAb]* = kxA*, (5) [Aa-Ba]* = [A*-B*], (6) [Âa]* = ~XsA*, (7) [VA<s,a>]* = A*[xs].","Now we can define the semantics of query 'q when f' as a term of Ty 2. [q when f]'=~x~x(~x~([[f]']*[x~]A"]},{"title":"[[q]']*[x~][x]))","paragraphs":[", which means intuitively the set of objects which satisfy q in each states where f has a value I. Similarly we define the following. [q whenever f]'=Xx~x(Vx~([[f]']*[x~]A"]},{"title":"[[q]']*[x~][x])),","paragraphs":["Ef 2 when"]},{"title":"fl]':Xx~Xx(~x~(EEfl]']*[x~]̂","paragraphs":["[[f2]']*[x~])), [f2 whenever"]},{"title":"fl]'=~X~%X(VX~([[fl]']*[x~]A","paragraphs":["[[f2]']*[x~])).","Ii. CONCLUDING REMARKS","We believe we have demonstrated feasibility of the Montague's approach to the semantics of hierarchical database systems with historical data.","As for future reasearch directions, we would like to point out the importance of (i) finding normal forms which allows efficient evaluation of terms, and (ii) finding a set of axioms for equivalence transformations which derive normal forms from given terms. ACKNOWLEDGEMENTS","Our thanks are due to Mr. Kenichi Murata for fruitful discussions and encouragement and to Prof. Takuya Katayama and many other people whose ideas we have unwittingly absorbed over the years. REFERENCES","i. Gallaire, H., Minker, J., (1978) 'Logic and Databases', Plenum Press.","2. Reiter, R., (1977) 'An Approach to Deductive Question-Answering', BBN Report No.3649, Bolt, Beranek and Newman, Inc.","3. Wong, H.K.T., and Mylopoulos, J., (1977) 'Two Views of Data Semantics: A survey of Data Models in Artificial Intelligence and Database Management', INFOR, 15, 3, 344-383.","4. Lipski, W., Jr., (1977) 'On Semantic Issues Connected with Incomplete Databases', 3-rd VLDB.","5. Montague, R., (1973) 'The Proper Treatment of Quantification in Ordinary English' Approaches to Natural Language, Reidel Dordrecht.","6. Montague, R., (1977) 'Universal grammar', Formal philosophy-selected paper of R. Montague, edited by R~. Tomason, Yale Univ. Press.","7. Codd, E.F., (1974) 'Recent investigations in relational database systems', Information Processing 74, North-Holland Pub. Co., Amsterdam, 1017-1021.","8. Gallin, D., (1975) 'Intensional and Higher-order Modal logic', North-Holland Publishing Company, Amsterdam.","9. Curry, H.B., and Feys, R.,(1968) 'Combinatory Logic', Vol.l, North-Holland, Amsterdam.","i0. Yanssen, T.M.V., (1977) 'The expressive power of intensional logic in the semantics of programming language', Lecture Notes in Comp. Sci. 53. Springer-Verlag, Berlin.","II. Henkin, L., (1963) 'A theory of propositonal types', Fund. Math., 52.","12. Floyd, R. W., (1967) 'Assingning meanings to programs', Proc. Amer. Math. Soc. Symposia in Applied Mathematics, Vol. 19.","13. ANSI/X3/SPARC Study Group on Data Base Management Systems, (1975) 'Interim Report', ANSI.","14. Yannis Vassiliou, (1979) 'Null Values in Data Base Management: A Denotational Semantics Approach', Internal Conference on Management of Data, ACM-SIGMOD, 162-169. --227--"]}]}