{"sections":[{"title":"LR Pa rse rs For Natural Languages, Masaru","paragraphs":["Tomita","Computer Science Department Carnegie-Mellon University Pittsburgh, PA 15213"]},{"title":"Abstract","paragraphs":["MLR, an extended LR parser, is introduced, and its application to natural language parsing is discussed. An LR parser is a ~;hift-reduce parser which is doterministically guided by a parsing table. A parsing table can be obtained automatically from a context-free phrase structure grammar. LR parsers cannot manage antl)iguous grammars such as natural language grammars, because their I)arsing tables would have multiply-defined entries, which precludes deterministic parsing. MLR, however, can handle mulliply-defined entries, using a dynamic programnting method. When an input sentence is ambiguous, the MI.R parser produces all possible parse trees witftoul parsing any part of the input sentenc:e more than once in the same way, despite the fact that the parser does not maintain a chart as in chart par~ing. Our method also prnvkles an elegant solution to the problem of multi-part-of-speech words such as \"that\". The MLR parser and its parsing table generator have been implemented at Carnegie-Mellon University."]},{"title":"1 Introduction","paragraphs":["LR parsers[I, 2] have been developed originally for programming language of compilers. An LR parser is a shift-reduce parser which is detenninistically guided by a par.~it~g table indicating what action should be taken next. The parsing table can be obtained automatically from a context-free phrase structure grammar, using an algorithm first developed by DeRemer [5, 6]. We do not describe the algorithm here, reffering the render to Chapter 6 in Aho and UIIman [4]. The LR parsers have seldom been used for Natural Language Processing probably because: 1. It has been thought that natural languages are not context-free, whereas LR parsers can deal only with context-free languages.","2. Natural languages are ambiguous, while standard LR parsers can not handle ambi~juous languages. The recent literature[8] shows that the belief \"natural languages are not context-free\" is not necessarily true, and there is no reason for us to give up the context-freedom of natural languages. We (to not discuss on this matter further, considering the fact that even if natural languages are not context-free, a fairly comprehensive grammar for a subset of natural language suflicient for practical systems can be written in context.free phrase structure. lhtJ.% our main concern is how to cope with the ambiguity of natural languages, and this concern is addressed in the fallowing section."]},{"title":"2 LR parsers and Ambiguous Grammars","paragraphs":["If a given grammar is ambiguous? we cannot have a parsing table in which ~ve~y entry is uniquely defined; at lea~t one entry of it~ parsing table is inulliply defined. It has been thought that, for LR pa~sers, nndtiple entries are fatal because they make deterministic parsing no longer po~$ible. Aho et. al. [3] and Shieber[121 coped with this ambiguity problem by statically 3 selecting one desired action out of multiple actions, and thus converting n=ulliply-defined entries into uniquely-defined ones.With this approach, every input sentence has no more than one parse tree. This fact is desirable for progralnming languages. For natural languages, however, it is sometimes necessary for a parser to produce more than one parse tree. For example, consider the following short story.","I saw the man with a telescope.","He should have bought it at the department store. When the first sentence is read, there is absolutely no way to resolve the ambiguity 4 at that time. The only action the system can take is to produce two parse trees and store them somewhere for later disambiguation. In contrast with Aho et. al. and Shieber, our approach is to extend LR parsers so that they can handle multiple entries and produce more than one parse tree if needed. We call the extended LR parsers MLR parsers. ll'his rP.~i:i'¢l'Ctl was -~pon~oled by the Df.'ieose Advanced Research Projects Agency (DOD), ARPA Older No. 3597, munitoled hy lhe Air Foi'r:e Avionics Lot)oratory Under C, uolracl F3:)(~15 81 K-t539. The views and con,.;lusion$ conl,lii~cd i=1 lhi.~; (lo=;unlq;nt a~i.~ tho'.;e ()| tt1~.! ;iu|hor.~; alld should not be illlerpreted as n:pre.-',enling the official p(':licie:;, c, ilher expressed or implied, of the Defense Advanced Re,ql..';.trch Projects Ag4.tncy or the US Gow.~.rnnlent. 2A grammar is ambiQuous, if some input sentence can be parsed in more than on~. W,gy, 3By t'~tatically\", we mean the ~..:election is done at par.~ing table construction time, 4\"1\" have the telescope, or \"the man\" has the telescope."]},{"title":"354 3 MLR Parsers","paragraphs":["of different parses have in the chart parsing method [10, 11]. The idea should be made clear by the following example. An example grammar and its MLR parsing table produced by the construction algorithm are shown in fig. 1 and 2, respectively. The MLR parsing table construction algorithm is exactly the same as the algorithm for LR parsers. Only the difference is that an MLR parsing table may have multiple entries. Grammar symbols starting with ..... represent pre-terminals. \"sh n\" in the action table (the left part of the table) indicates the action \"shift one word from input buffer onto the stack, and go to state n\". \"re n\" indicates the action \"reduce constituents on the stack using rule n\". \"acc\" stands for tile action \"accept\", and blank spaces represent \"error\". Goto table (the right part of the table) decides to what state the parser should go aftera reduce action. The exact definition and operation of LR parsers can be found in Aho and Ulhnan [4]. We can see that there are two multiple entries ir~ the table; on the rows of state tt and 12 at the column of \"'prep\". As mentioned above, once a parsing table has multiple entries, deterministic parsing is no longer possible; some kind of nondeterminism is necessary. We .~hali see that our dynamic programming approach, which is described below, is much more efficient than conventional breath-first or depth-first search, and makes MLR parsing feasible."]},{"title":"4 An Example","paragraphs":["In this section, we demonstrate, step by step, how our MLR parser processes the sentence:","I SAW A MAN WITH A TELESCOPE using the grammar and the parsing table shown in fig t and 2. This sentence is ambiguous, and the parser should accept the sentence in two ways. Until the system finds a multiple entry, it behaves in tile exact same manner as a conventional LR parser, as shown in fig 3-a below. The number on the top (ri.qhtmost) of the stack indicates the current state. Initially, the current state is 0. Since the parser is looking at the word \"1\", whose category is \"*n\", the next action \"shift and goto state 4\" is determined from the parsing table. \"]he. parser takes the word \"1\" away from the input buffer, and pushes the preterminal \"*n\" onto tile stack. The next word the parser is looking at is \"SAW\", whose category is \"'v\", and \"reduce using rule 3\" is determined as the next action. After reducing, the parser determines the current state, 2, by looking at the intersection of the row of state 0 and the column of \"NP °', and so on. Our approach is basically pseudo-parallelism (breath-first search). When a process encounters a multiple entry with n different actions, the process is split into n processes, and they are executed individually and parallelly. Each process is continued until either an \"error\" or an \"accept\" action is found. The processes are, however, synchronized in the following way: When a process \"shifts\" a word, it waits until all other processes \"shift\" the word. Intuitively, all processes always look at the same word. After all processes shift a word, the system may find that two or more processes are in the ~lnle state; that is, some processes have a common state number on the top of their stacks. These processes would do the exactly same thing until that common state number is popped from their stacks by some \"reduce\" action. In our parser, this common part is processed only once. As soon as two or more processes in a common state are found, they are combined into one process. This combining mechanism guarantees that any part of an input sentence is parsed no more than once in the same manner.\" This makes the parsing much more efficient than simple breath-first or depth-first search. Our method has the same effect in terms of parsing efficiency that posting and recognizing common subconstituents STACK","MrXT-ACI ION NEXT-WORD ............................................................. 0 sh 4 [ 0 =n 4 re 3 SAW 0 NP Z sh 7 SAW 0 NP 2 \"v 7 sh 3 A 0 NP 2 ev 7 =det. 3 sh IO MAN 0 NP 2 Ov 7 O¢let, 3 en tO re 4 WITH 0 NP 2 =v 7 NP tZ re 7, sh 6 WI[II ..................................... .: ....................... Fig 3oa At this point, tile system finds a multiple entry with two different actions, \"reduce 7\" and \".3hilt g\". Both actions are processed in parallel, as shown in fig 3-b. State *det *n *v \"prep $ NP PP VP S .................................................................... sh3 sh4 2 t sh6 acc 5 sh7 sh6 9 8 sht0 re3 re3 re3 re2 re2 sh3 sh4 11 sh3 sh4 12 0 1 .......................... 2 (I) S --> NP VP 3 (2) S --> S PP 4 (3) NP --> =n 5 (4) NP --> *det *n 6 (5) NP --> NP PP 7 (6) PP --> =prep NP 8 (7) VP --> \"v NP 9 .......................... 10 11 12 Fig 1 ret tel re5 re5 re5 re4 re4 re4 re6 re6,sh6 re6 9 re7,sh6 re7 9 Fig 2"]},{"title":"355","paragraphs":["0 NP 2 VP 8 re t W[FII 0 NP 2 *v 1 HI ) 12 *prep 6 wait A 0 S [ sh 6 WI[II 0 NP 2 \"v l NP 12 \"prep 6 wait A This process is also finished by the action \"accept\". The system has accepted the input sentence in both ways. It is important to note that any part of the input sentence, including the prepositional phrase \"WITH A TELESCOPE\", is parsed only once in the same way, without maintaining a chart. 0 S I *l)rep 6 sh 3 A 0 NP Z *v 7 NP t2 \"prep 6 sh 3 A ............................................................... Fig 3-b Here, the system finds that both processes have the common state number, 6, on the top of their slacks. It combines two proces:;os into one, and operates as if there is only one process, as shown in fig 3-c."]},{"title":"5 Another Example","paragraphs":["Some English words belong to more than one gramillatical category. When such a word is encountered, tile MLR parsing table can immediately tell which of its cutegories are legal and which are not. When more than one of its categories are legal, tile parser behaves as if a multiple entry were encountered. The idea should be'made clear by the following example. .................................... e ........................ O S | III \"prep 6 sh 3 A 0 HI' 2 \"v 1 i'lP 12 4v 0 S t \"prep 13 \"det 3 sh 10 TELESCOPE 0 MP 2 \"v 7 NP t2 d#\" 0 S I I \"prep 6 \"dot 3 \"n )0 re 4 $ 0 NP 2 \"v 7 NP t2 alP\" Consider the word \"that\" in the sentence:","That information is important is doubtful. A ~3ample grammar and its parsing table are shown in Fig. 4 and 5, respectively. Initially, the parser is at state O. The first word \"that\" can be either \"\"det\" or \"*that\", and the parsing table tells us that both categories are legal. Thus, the parser processes \"sh 5\" and \"sh 3\" in parallel, as shown below. 0 S ! j \"prop G ~IP tt re 6 $ 0 NP 2 \"v 7 NP 12 ~ ............................................................... STACK","NEXI ACIION N[XI WORD ...................................................... 0 sh 5, sh 3 I'hat Fig 3-c The action \"reduce 6\" pops the common state number 6, and the system can no longer operate the two processes as one. The two processes are, again, operated in parallel, as shown in fig 3-d. 0 S I PP 5 re 2 $ 0 NP 2 =v 7 NP 12 PP 9 re 5 $ 0 S [ accept 0 NP 2 *v 7 NP 12 re 7 $ ............................................................. Fig 3-d NOW, one of the two processes is finished by the action \"accept\". The other process is still continued, as shown in fig 3-e. ............................................................. 0 NP 2 VP 8 re t $ 0 S t accept 0 sh 5 Fhat 0 sh 3 That 0 *det 5 sh 9 information 0 \"that 3 sh 4 information 0 *det 5 *n 9 re 2 is 0 *that 3 *n 4 re 3 is 0 NP 2 sh 6 Is 0 =that 3 NP 2 sh 6 is Fig. 6-a At this point, the parser founds that both processes are in the same state, namely state 2, and they are combined as one process. Fig 3-e 0 (1) S --> NP VP 2 (2) NP --> \"det *n 3 (3) NP --> \"n 4 (4) NP --) *that S 5 (5) VP --> \"be \"adj 6 ......................... 7 8 9 Fig. 4 10 State *adj \"be \"det *n *that $ NP S VP ..................................................................... sh5 sh4 sh3 2 1 acc sh6 7 sh5 sh4 sh3 2 8 re3 sh9 shlO re1 re1 re4 re2 re5 re5 ..................................................................... Fig. 5"]},{"title":"356","paragraphs":["00 *t at 3 NP GMPh q~ml~a'~P 2 sh 6 iS 0 NP ~Z *he 6 sh 10 important 0 \"that 3 NP 0 NPh=mmmm~2 \"be 6 \".d j.t at 3 NP f tO re 5 1, o 0 NP~2 VP 7 re t |s 0 \"that 3 NP- ........................................................ Fig. 6- b The process is split into two processes again. 0 ~IP 2 VP 7 re I i$ 0 *that 3 NP 2 VP 7 re 1 1=1 0 5 1 #ERRORI tl 0 \"thor 3 $ 8 re 4 is ........................................................ Fig. 6-¢ • One of two processes detects \"error\" and halts; only the other process goes on. 0 NP 2 sh 6 t= 0 NP 2 *he 6 sh tO doubtful 0 ~JP Z \"be 6 \"adJ tO re 5 $ 0 .P 2 vP 7 re 1 $ 0 s I ace $ ........................................................ Fig. 6-d Finally, the sentence has been parsed in only one way. We emphasize again that, \"in spite of pseudo-parallelism, each part of the sentence was parsed only once in the same way."]},{"title":"6 Concluding Remarks","paragraphs":["The MLR parser and its parsing table generator have been implemented at Computer Science Department, Carnegie.Mellon University. The system is written in MACLISP and running on Tops-20. One good feature of an MLR parser (and of an LR parser) is that, even if the parser is to run on a small computer, the construction of the parsing table can be done on more powerful, larger computers. Once a parsing table is constructed, the execution time for parsing depends weakly on the number of productions or symbols in a grammar. Also, in spite of pseudo. parallelism, our MLR parsing is theoretically still deterministic. This is because the number of processes in our pseudo. parallelism never exceeds the number of states in the parsing table. One concern of our parser is whether the size of a parsing table remains tractable as the size of a grammar grows. Fig. 6 shows the relationship between the complexity of a grammar and its LR parsing table (excerpt from Inoue [9]). XPL EULER FORTRAN ALGOL60 Terminals 47 74 63 66 Non-terminal s 51 45 77 99 Product ions 108 121 172 205 States 180 t93 322 337 TableSize(byte) 2041 2587 3662 4264 Fig. 6 Although the example grammars above are for programming langauges, it seems that the size of a parsing table grows only in proportion to the size of its grammar and does not grow rapidly. Therefore, there is a hope that our MLR parsers can manage grammars with thousands of phrase structure rules, which would be generated by rule-schema and meta-rules for natural language in systems such as GPSG [7]."]},{"title":"Acknowledgements","paragraphs":["I would like to thank Takehiro Tokuda, Osamu Watanabe, Jaime Carbonell and Herb Simon for thoughtful comments on an earlier version of this paper."]},{"title":"References","paragraphs":["[1] Aho, A. V. and Ullman, J. D. The Theory of Parsing, Translation and Compiling. Prentice-Hall, Englewood Cliffs, N. J., 1972. [2] AhO, A. V. and Johnson, S. C. LR parsing. ComPuting Surveys 6:2:99-124, 1974. [3] Aho, A. V., Johnson, S. C. and UIIman, J. D. Deterministic parsing of ambiguous grammars. Comm. ACM 18:8:441-452, 1975. [4] Aho, A. V. and UIIman, J. D. Principles of Compiler Design. Addison Wesley, 1977. [5] Oeremer, F. L Practical Translators for LR(k) Languages. PhD thesis, MIT, 1969. [6] DeRemer, F. L. Simple LR(k) grammars. Comm. ACM 14:7:453-460, 1971."]},{"title":"FI Gazdar, G.","paragraphs":["Phrase Structure Grammar. D. Reid,l, 1982, pages 131.186. [8] G=zder, G. Phrase Structure Grammars and Natural Language. Proceedings of the Eighth International Joint Conference","on Artificial Intelligence v.1, August, 1983. [9] Inoue, K. and Fujiwara, F, On LLC(k) Parsing Method of LR(k) Grammars. Journal of Inlormation Processing vol.6(no.4):pp.206-217,","1983.","[10] Kapisn, R. M. A general syntactic processor. Algorithmics Press, New York, 1973, pages 193.241."]},{"title":"[1~] Kay, M.","paragraphs":["The MIND system. Algorithmics Press, New York, 1973, pages 155-188.","[12] Shieber, S. M. Sentence Disambiguation by a ShiR-Reduce Parsing","Technique. Proceedings of the Eighth International Joint Conference","on Artificial Intelligence v.2, August, 1983."]},{"title":"357","paragraphs":[]}]}
