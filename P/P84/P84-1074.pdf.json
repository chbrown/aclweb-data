{"sections":[{"title":"","paragraphs":["LFG ~ystsm in Prolog","Hide~ Ya~u'~awa The Second Laboratory","Institute for New Generation Computer Technology (ICOT) To~/o, 108, Japan ABSTRACT","In order to design and maintain a latE? scale grammar, the formal system for representing syntactic knowledEe should be provided. Lexlcal Functional Grammar (LFG) [Kaplan, Bresnan 82] is a powerful formalism for that purpose, In this paper, the Prolog implementation of LFG system is described. Prolog provides a Eood tools for the implementation of LFG. LFG can be translated into DCG [Perelra,IIarren 80] and functional structures (f-structures) are generated durlnK the parsing process. I INTRODUCTIOr~ The fundamental purposes of syntactic analysis are to check the Eramnatlcallty and to clariDI the mapping between semantic structures and syntactic constituents. DCG provides tools for fulfillln 6 these purposes. But, due to the fact that the arbitrary 9rolog programs can be embedded into DCG rules, the grammar becomes too complicated to understand, debug and maintain. So, the develo~ent of the formal system to represent syntactic knowled~es is needed. The main concern is to define the appropriate set of the descriptive primitives used to represent the syntactic knowledges. LFG seems to be promising formalism from current llngulstlc theories which satisfies these requirements. LFG is adopted for our prelimlna~y version of the formal system and the Prolog implementation of LFG is described in this paper. ii SII:~.Z OVERVI~ OF LFG in this section, the simple overview of LF~ is described (See [Eaplan, Bresnan 82] for details ). LFG is an e::tention of context free grammar (C~'G) and has two-levels of representation, i.e. c-structures (constituent structures) and f-~tructures (functional structures). A c-structure is generated by CFG and represents the surface uord and phrase configurations in a ~entence, and the f-structure is generated by the functional equations a=sociated with the o~rammar rules and represents the conflo~uratlon of the surface ~ra=matical functions. Fi~. I shows the c-structure and f-structure for the sentence \"a e~f.rl handed the baby a toy\" ([Kaplan,Bresnan 82]). np"]},{"title":"I","paragraphs":["det---n"]},{"title":"I I f","paragraphs":["a s"]},{"title":"I","paragraphs":[".... Vp"]},{"title":"I","paragraphs":["v ...... np- ...... np det---n det--n glrl hands the baby a toy (a) c-structure subJ spec a hum ng pred \"glrl\" tense past pred \"hand<(T subJ)(T obJ2)(T obJ)>\" obJ spec the num sg pred \"baby\" obJ2 spec a num sg pred \"toy\" (b) f-structure Fig. 1 The eY~mgle c-structure and f-structure As shown in Fig. I, f-structure is a hierarchical structure constructed by the pairs of at~rlbute and its value. An attribute represents ~ra=matlcal function or syntactic feature. Lexlcal entries specify a direct mappinE betueen semantic arguments and confizuratlons of surface grammatlcal functions, and ~rammar rules specify a direct mapping between these surface Cr~umatlcal functions and particular constituent structure conflguratlons. To represent these Cra=matlcal relations, several devices and schemata are provided in LFG as shown below.","(a) meta variables (1) T & $ (immediate dominance) (il) ~ & ~ (bounded dominance)","(b) functional notations a designator (T subj) indicates the aSubja attribute of the f- structure.","(c) Equational schema l l) ( functional equation) ii) ~ (set inclusion) the va!ue of","mother node's"]},{"title":"358","paragraphs":["(d) Constrainln~ schema {i) =c (equational constraint) (ii) d (existential constraint)","where d is a desIcnator (ill) negation of (1) and (il)","Fi~. 2 sh~#s the e~anple ~ra~uar rules and le\"~ical entries in LF~, wl~ch senerate the c-structure and the f-structure in Fig. 1. 1. s-> np"]},{"title":"vp (T","paragraphs":["subJ)=+"]},{"title":"T=+ 2. np -> det n 1=~ T=~","paragraphs":["3. vp-> v"]},{"title":"np","paragraphs":["np"]},{"title":"T=+ (T obJ)=~ CT obJ2)=+","paragraphs":["~."]},{"title":"det->","paragraphs":["[a]"]},{"title":"(T spec):a (T num):s~","paragraphs":["5. det-> [the]"]},{"title":"(T spec) =the 6. n-> [girl] (T","paragraphs":["nu~):sg ('~ pred):'glrl\""]},{"title":"7. n-> [baby] (T","paragraphs":["nun):sg"]},{"title":"(T pred)='baby\"","paragraphs":["8. n-> [toy]"]},{"title":"(r num)=sg (T pred)='toy\" 9. v-> [handed] (T tense) =past (T pred)='hand<(~ subJ)(T obJ2)(T obJ)>\" FiE. 2 Example ~rammar rules and lex~oal entries of LFG. (from [Kaplan,Bresnan 82])","paragraphs":["As sh~n in Fi~. ~, the prlnltlves to re~resent ~r3~.atlcal relations are encoded in ~ra~:aar rules and le~cal entries. Each syntaotle node h~s i~s own f-structure and the partial value of the f-structure is defined by the Equational ~ch~m. For exauple, the functional equation \"(~ sub~)=$\" associated with the dau~hter \"np\" node of ~r~-u~r rule I. of Fi~. 2 specifies that the value of the \"sub~\" attribute of the f-structure of th~ ~other \"s\" node is the f-structure o/ its d~u~ter \"np\" node. ~ne value constraints on the f-~tructure are specified by the Constraln~r~ schema, i:oreover, the o~rauatlcallty of the sentence is defined by the three conditions shown bel~. (I) ~nlqueness: a particular attribute may have at :cost one value in a ~iven f-structure. (2) Completeness: a f-structure must contain all the ~overnable ~r~uatical functions ~overned by It~ predicate. (~) Coherence: all the ~overr~ble ~ran~uatlcal functions that a f-structure contain must be ~overned by its predicates. ZZZ Z;~L~L:TATIO:~ OF L,.'G P~--~rTZVE~","As indicated in section iI, two distinct ~chenata ~re enploycd in the constructions of f-~trucbures. In the current lupleuentatlon, f-3tructures are ~enerated durln~\" the ~arslr~ process by executin~ the functional equations and ~et inclusions associated with each syntactic node. After ~e .,~urslr~ is done, the f-structures ~.~ checked whether their value assicr~ents are consistent ~ith the value conutralnts on them. The Completeness condition on ~r~atlc~l!~y is also checked after the parsln~. ~e L~'~J primitives are realized by the Prolo~ procra~s and embedded into the DCG rules. The Equational schema is executed durln~ the parsln~ process by the execution of DCG rules. The functional equation can be seen as the extension of ~e unification Of Prolog by introduclr~ equality on f-structures. A. Representations of Data Types The prlnltlve data types constructi.~ f-structures are symbols, semantic predicates, subsidiary f-structures, and sets of sy=bols, semantic predicates, or f-structures. In current implementation, these data types are represented as follows:","I) symbols ==> atem or Inte~r","2) semantic predicates ==> sea(X) where X is a predicate","3) f-structure ==> Id:Obt where the \"Id\" is an identifier variable (ID-varlable). Each syntactic node has unique ID-variable which is used to Identify its f-structure. The \"Obt\" is a ordered blrmry tree each leaf contains the pair of an attribute and its value.","q) set ==> {elementl, element2, ..., element;!}","A f-structure can be seen as a partially defined data structure, because its value is partially Emnarated by the Equational schema during the paralng process. An ordered binary tree, obt for short, is suitable for representln~ partially defined data. An obt is a binary tree whose labels are ordered. A binary tree \"Obt\" is represented by an term of the following foru. Obt = obt(v(Attr,Value),Less,Greater)","The \"v(Attr,Value)\" is a leaf node of the tree. The \"Attr\" is an attribute name and used as the label of the leaf node, and the \"Value\" is its value. The \"Less\" and \"Greater\" are also binary trees. The \"Obt\" is ordered when the \"Less\" (\"Greater\") is also ordered and each label of its leaf nodes is less (greater) than the label of \"ObtW,i.e. \"Attr\". If none of the leaf of a tree is defined, it is represented by a logical variable, l~en its label is defined later, the logical variable is In~antlated. The insertion of a label and its value into an obt is done by only oneunlflcatlon, without rewrltln~ the tree. This is the merit in uslnE an ordered blna~j tree.","For m Y-mple, the f-structure for the noun phrase \"a glrl\", the value of the \"subJ\" in Fi~.1 (b), can be ~-a~leally represented in Fig. 3.","The \"Vi\"'s in Fig. 3 are the variables representing the unlnstantlated subtrees. B. Functional !~otatlon"]},{"title":"359","paragraphs":["iD-variable --> v(spec,a) v( nun, aS) .......... +"]},{"title":"I","paragraphs":["~-- ..... v(per3,3)"]},{"title":"~i~. 3","paragraphs":["+....+ Vl v2 v3 v~ the ~raphical representalon of an obt","The functional notations are represented by !D-variables instead of l~ta variables ~ and $, i.e. ~Mta variables must be replaced by the object level variable. For example, the designator (7 subj) associated with the category 3, is described as [subJ, IdS], where Ida is the ZD-variable for S. ~e meta variables for bounded dominance are represented by the terms controllee(Cat) and controller(Cat), where the \"Cat\" is the name of the syntactic category of the controller or ccntrollee. C. Predicates for LFG Primitives","The predicates for each LFG primitives are as follows : (d,dl,d2 are designators, s is a set, and \" is a negation symbol) I) dl = d2 -> equate(dl,d2,01d,New) 2) d & s -> include(d,s,Old,New) 3) dl =c d2 -> eonstrain(dl,d2,01dC,NewC) 4) d -> exlst(d,OldC,~lewC) 5) \"(dl =c d2) -> ne&_constraln(dl,d2,01dC,~ewC) 6) \"d -> not_exist(d,OldC,~ewC) The \"Old\" and \"New, are global value assIcnnenta. ~%ey are used to propagate the chan~es of ~iobal value assignments made by the execution of each predicate. The \"OldC\" and \"~;ewC\" are constraint lists and used to gather all the constraints in the analysis.","Desides these predicates, the additional predicates are provided for checking a constraints durln~ the parsing process. They are used to k~ll the parsing process zeneratlng inconsistent result as soon as the inconsistency is found.","~e predicate \"equate\" gets the temporary values of the desi~nators dl and d2, consulting the global value assignments. Then \"equate\" performs the unification of their values. The unification is similar to set-theoretlc union except that it is only defined for sets of nondistlnct attributes. Fig. 4 shows the example trace output of the \"equate\" in the course of analyzing the sentence \"a girl hands the baby a ~oy\".","in order to keep grammar rules highly understandable, it would be better to hide unnecessary data, such as c!obal value assicr~ents or constraint lists. The macro notations similar to the original notation of LFG are provided to users for that purpose. The macro expander translates the macro notations into Prolog programs corresponding to the LFG primitives. The value of the designator Det is spec the The value of the designator ~! is hum sg per 3 pred aeu(glrl) Result of unification is spec the hum sg per 3 pred sem(glrl) Fig. 4 Tracing results of equate. This macro expansion results in considerable improvement of the wrltability and the understandability of the grammar.","The syntax of macro notations are : (a) dl = d2 -> eqCdl,d2) (b) d e s -> InclCd,s) Co) dl =c d2 -> o(dl,d2) (d) d -> ex(d) (e) \"(dl =c d2) -> not_c(dl,d2) (f) \"d -> not~ex(d)","These macro notations for LFG primitives are placed at the third arsument of the each predicate in DCG rules correspondln~ to syntactic categories as shown in Fig. 5 (a), which corresponds to the grammar rule I. in Fig. 2."]},{"title":"s(s(Np, Vp),Id_$,[])","paragraphs":["--> np(Np, I~_Np,[eq([subJ,Id..S],Id..:Ip]), vp(Vp, Id_Vp,[eq(I~_S, Id..Vp)]). (a) The DCG rule with macro for LF~"]},{"title":"s( s( Np, Vp), I~_$, Old, :;ew, 01dO, I~ewC) -->","paragraphs":["np( Np, IdJ1p, Old, Oldl,"]},{"title":"OldC, OldC1 ),","paragraphs":["{equate( [subj, Id_S], Id_~Ip, Oldl, 01d2) }, vp( Vp, Id__Vp, Old2,01d3, OldC1, ~ewC), {equate(Id_S, Id_Vp, Old3 ,New) }. (b) The result of macro expansion Fig. 5 Example DCG rule for LFG analysis","The variables \"~d_S\", ,IdjIp,, and \"Id_Vp\" are the ID-variables for each syntactic category. For example, the ~rs=mar rule in Fi~. 5 (a) is translated into the one shown in Fig. 5 (b). ~cro descriptions are translated Into the corresponding predicate in the case of a ~r~ar rule. In the case of a le:cical entry, macro descriptions are translated into the corresponding predicate, which is executed further more and the f-structure of the lexical entry is generated. D. Issues on the Implementation","Though f-structures are constructed durin~ the parsing process, the execution of the Equational schema is independent of the parsing"]},{"title":"360","paragraphs":["strate~'. This is necessary to keep the crayuaar rules highly declarative. There are some advantages of using Prolog in implementin~ LFG. First, the Uniqueness condition on a f-structure is fulfilled by the ori~inal unification of Prolog. Second, an ordered binary tree is a good data structure for representing a f-structure. The use of an ordered binary tree reduces the processin~ time by 30 percents compared with the case using a llst for representing a f-structure. And third, the use of ID-varlable also effective, because the sharing of a f-structure can be done oaly by one unification of the corresponding !D-variables.","Though the computational complexity of the ~quational schema is very expensive, the LF~ provides expressive and natural account for lin~ulstic evidence. In order to overcome the inefficiency, the introduction of parallel or concurrent execution mechanism seems to be a promising approach. The computation model of LFG is similar to the constraint model of computation [Steele 80].","~qe Prolos implementation of LF~ by Reyle and Fray [Reyle, Frey 83] aimed at more direct translation of functional equations into DCG. Although their implementation is more efficient, it does not treat the Constraining schema, set inclusions, the compound functional equation such as (\" vco:~p subj), and the bounded dominance. And their zr~ar rules seem to be too complex by direct encoding of f-structures into them. In order to provide an formal system havlr~ powerful description capabilities for representing syntactic knowled~es, the more LFG primitives are realized than their implementation and the ~rammar rules are more understandable and can be more easily modified in my implementation.","Time used in analysis is 972 ms. (parsing) 19 ms.(checkin~ constraints) ~I ms. (for checFin~ completeness) subJ spec the nun sg per 3 pred sem(glrl) pred sam(persuade ([subj, A], [obJ, A], [ vcomp, A]) ) obj spec the num sg per 3 pred sam(baby) tense past vcomp subj spee the hUm sg per 3 pred sam(baby) Inf รท pred sam(so ( [ subJ, B] ) ) to รท","Fig. 6 The result of analyzi.~ the sentence, โข the glrl persuaded the baby to So\" VII. AC~I~!LEDGE~NTS The author is thankful to Dr. K. Furuka~a, the chief of the second research laboratory of ICOT Research Center, and the me, bars of the natural language processing ~roup in ICOT Research Center, both for their discussion. The author is grateful to Dr. E. Fuchl, Director of the ICOT Research Center, for providing the opportunity to conduct this research. !'~. ~i'-\" RESULT OF A~' EXPER~NT","Fig. 6 shows the result of analyzing the sentence \"the ~irl persuaded the baby to go\". LFG system is written in Dec-10 Prolog [Pereira,et.al. 73] and executed on Dec 2060.","As shorn in Fi~. 6, the functional control [::aplan, Eresnan 82] is realized in the f-structure of vp. ~e value of the \"subj\" attribute of the \"vcoup\" is functionally controlled by the \"obJ\" of i;he f-structure of the \"s\" node. The time used for syntactic analysis includes the time consumed by parsinj process and the time consumed ~j ~quational schema. V. CO:ICLUSTON The Prolog implementation of LFG is described. It is the first step of the formal nysteu for represent!nz syntactic kno~;ledzes. As \"- result, it beco.&es quite obvious that Prolos is suitable for i:iD!e:~entln.- LFG.","Further research on the for::al syster~ will be carried by analyzing the wider variety of actual utt-rznce~ to e':tract the more pri:~i tlves ~-eces~.r.\" for the analyses, and to ~ive the ;:ccesaary sc:-e:~aca for tho~e pri_~itives. VIII. REFEREIICE$ [Kaplan, Bresnan 82] \"Lexical-Functlonal Gr~ar: A Formal System for Grammatical Representation\" in ~lental Representation of Grammatical Relations\", Bresnan ads., I ET Press, 1982 [Reyle,Frey 83] \"A Prolog T_mplementation of Lexlcal Functional Grammar\", Pros. of L/CAI-83, PP. 693-695, 1983 [ Perelra, at. al. 78] \"User' s Guide to D~C System- I0 Prolog\", Department of Artificial Intelligence, Univ. of Edlnbur-:h, 1978 [Pereira,'.;arren 30] \"Definite Clause Gr-~--_r for Language Analysis -- A Survey of the For~...allsm and a Comparison with Au~ented Transition -'.'etworks\", Artificial Intelligence, 13, PP. 231-278, I%80 [Steele 80] \"The Definition and !mpl-~uentation of a Computer Pr ogr -~.unin~. Lanzuase base~ on Constraints\", .~ET AI-TR-595, 19~0 361"]}]}
