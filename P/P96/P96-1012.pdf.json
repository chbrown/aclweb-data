{"sections":[{"title":"Another Facet of LIG Parsing Pierre Boullier INRIA-Rocquencourt BP 105 78153 Le Chesnay Cedex, France","paragraphs":["Pierre. Boullier@inria. fr"]},{"title":"Abstract","paragraphs":["In this paper 1 we present a new parsing algorithm for linear indexed grammars (LIGs) in the same spirit as the one described in (Vijay-Shanker and Weir, 1993) for tree adjoining grammars. For a LIG L and an input string x of length n, we build a non ambiguous context-free grammar whose sentences are all (and exclusively) valid derivation sequences in L which lead to x. We show that this grammar can be built in"]},{"title":"(9(n 6)","paragraphs":["time and that individual parses can be extracted in linear time with the size of the extracted parse tree. Though this"]},{"title":"O(n 6)","paragraphs":["upper bound does not improve over previous results, the average case behaves much better. Moreover, practical parsing times can be decreased by some statically performed computations."]},{"title":"1 Introduction","paragraphs":["The class of mildly context-sensitive languages can be described by several equivalent grammar types. Among these types we can notably cite tree adjoining grammars (TAGs) and linear indexed grammars (LIGs). In (Vijay-Shanker and Weir, 1994) TAGs are transformed into equivalent LIGs. Though context-sensitive linguistic phenomena seem to be more naturally expressed in TAG formalism, from a computational point of view, many authors think that LIGs play a central role and therefore the understanding of LIGs and LIG parsing is of importance. For example, quoted from (Schabes and Shieber, 1994) \"The LIG version of TAG can be used for recognition and parsing. Because the LIG for-malism is based on augmented rewriting, the parsing algorithms can be much simpler to understand 1See (Boullier, 1996) for an extended version."]},{"title":"87","paragraphs":["and easier to modify, and no loss of generality is in-curred\". In (Vijay-Shanker and Weir, 1993) LIGs are used to express the derivations of a sentence in TAGs. In (Vijay-Shanker, Weir and Rainbow, 1995) the approach used for parsing a new formalism, the D-Tree Grammars (DTG), is to translate a DTG into a Linear Prioritized Multiset Grammar which is similar to a LIG but uses multisets in place of stacks.","LIGs can be seen as usual context-free grammars (CFGs) upon which constraints are imposed. These constraints are expressed by stacks of symbols associated with non-terminals. We study parsing of LIGs, our goal being to define a structure that verifies the LIG constraints and codes all (and exclusively) parse trees deriving sentences.","Since derivations in LIGs are constrained CF derivations, we can think of a scheme where the CF derivations for a given input are expressed by a shared forest from which individual parse trees which do not satisfied the LIG constraints are erased. Unhappily this view is too simplistic, since the erasing of individual trees whose parts can be shared with other valid trees can only be performed after some unfolding (unsharing) that can produced a forest whose size is exponential or even unbounded.","In (Vijay-Shanker and Weir, 1993), the contextfreeness of adjunction in TAGs is captured by giving a CFG to represent the set of all possible derivation sequences. In this paper we study a new parsing scheme for LIGs based upon similar principles and which, on the other side, emphasizes as (Lang, 1991) and (Lang, 1994), the use of grammars (shared forest) to represent parse trees and is an extension of our previous work (Boullier, 1995).","This previous paper describes a recognition algorithm for LIGs, but not a parser. For a LIG and an input string, all valid parse trees are actually coded into the CF shared parse forest used by this recognizer, but, on some parse trees of this forest, the checking of the LIG constraints can possibly failed. At first sight, there are two conceivable ways to extend this recognizer into a parser: 1. only \"good\" trees are kept;","2. the LIG constraints are Ire-]checked while the extraction of valid trees is performed.","As explained above, the first solution can produce an unbounded number of trees. The second solution is also uncomfortable since it necessitates the reevaluation on each tree of the LIG conditions and, doing so, we move away from the usual idea that individual parse trees can be extracted by a simple walk through a structure.","In this paper, we advocate a third way which will use (see section 4), the same basic material as the one used in (Boullier, 1995). For a given LIG L and an input string x, we exhibit a non ambiguous CFG whose sentences are all possible valid derivation sequences in L which lead to x. We show that this CFG can be constructed in (.9(n 6) time and that individual parses can be extracted in time linear with the size of the extracted tree."]},{"title":"2 Derivation Grammar and CF Parse Forest","paragraphs":["In a CFG G = (VN, VT, P, S), the derives relation","is the set {(aBa',aj3a') I B --~ j3 e P A V = G VN U VT A a, a ~ E V*}. A derivation is a sequence of strings in V* s.t. the relation derives holds between any two consecutive strings. In a rightmost derivation, at each step, the rightmost non-terminal say B is replaced by the right-hand side (RHS) of a B-production. Equivalently if a0 ~ ... ~ an is","G G a rightmost derivation where the relation symbol is overlined by the production used at each step, we say that rl ... rn is a rightmost ao/a~-derivation.","For a CFG G, the set of its rightmost S/x-derivations, where x E E(G), can itself be defined by a grammar. Definition 1 Let G = (VN,VT,P,S) be a CFG, its rightmost derivation grammar is the CFG D ="]},{"title":"(VN,","paragraphs":["P, pD, S) where pD _~ {A0 --~ A1... Aqr I r --- Ao --+ woAlwl.., wq_lAqwq E P Awi E V~ A Aj E","LFrom the natural bijection between P and pD, we can easily prove that L:(D) = {r~...rl"]},{"title":"I","paragraphs":["rl ... rn is a rightmost S/x-derivation in G~","This shows that the rightmost derivation language of a CFG is also CF. We will show in section 4 that a similar result holds for LIGs.","Following (Lang, 1994), CF parsing is the intersection of a CFG and a finite-state automaton (FSA) which models the input string x 2. The result of this intersection is a CFG G x -- (V~, V~, px, ISIS) called a shared parse forest which is a specialization of the initial CFG G = (V~, VT, P, S) to x. Each produc-","J E px, is the production ri E P up to some tion r i non-terminal renaming. The non-terminal symbols in V~ are triples denoted [A]~ where A E VN, and p and q are states. When such a non-terminal is productive, [A] q :~ w, we have q E 5(p, w).","G ~","If we build the rightmost derivation grammar associated with a shared parse forest, and we remove all its useless symbols, we get a reduced CFG say D ~ . The CF recognition problem for (G, x) is equivalent to the existence of an [S]~-production in D x. More-over, each rightmost S/x-derivation in G is (the reverse of) a sentence in E(D*). However, this result is not very interesting since individual parse trees can be as easily extracted directly from the parse forest. This is due to the fact that in the CF case, a tree that is derived (a parse tree) contains all the information about its derivation (the sequence of rewritings used) and therefore there is no need to distinguish between these two notions. Though this is not always the case with non CF formalisms, we will see in the next sections that a similar approach, when applied to LIGs, leads to a shared parse forest which is a LIG while it is possible to define a derivation grammar which is CF."]},{"title":"3 Linear Indexed Grammars","paragraphs":["An indexed grammar is a CFG in which stack of symbols are associated with non-terminals. LIGs are a restricted form of indexed grammars in which the dependence between stacks is such that at most one stack in the RHS of a production is related with the stack in its LHS. Other non-terminals are associated with independant stacks of bounded size.","Following (Vijay-Shanker and Weir, 1994) Definition 2 L = (VN,VT,VI,PL,S) denotes a LIG where VN, VT, VI and PL are respectively finite sets of non-terminals, terminals, stack symbols and productions, and S is the start symbol. In the sequel we will only consider a restricted","2if x = al... as, the states can be the integers 0... n, 0 is the initial state, n the unique final state, and the transition function 5 is s.t. i E 5(i-- 1, a~) and i E 5(i, ~)."]},{"title":"88","paragraphs":["form of LIGs with productions of the form"]},{"title":"PL","paragraphs":["= {A0 --+ w} U {A(..a) --+ PlB(..a')r2} where A,B •"]},{"title":"VN, W •","paragraphs":["V~A0 < [w[ < 2,"]},{"title":"aa' • V;A 0 < [aa'[","paragraphs":["< 1 and r,r2 • v u( }u(c01 c • An element like"]},{"title":"A(..a)","paragraphs":["is a"]},{"title":"primary constituent","paragraphs":["while C0 is a"]},{"title":"secondary constituent.","paragraphs":["The stack schema (..a) of a primary constituent matches all the stacks whose prefix (bottom) part is left unspecified and whose suffix (top) part is a; the stack of a secondary constituent is always empty.","Such a form has been chosen both for complexity reasons and to decrease the number of cases we have to deal with. However, it is easy to see that this form of LIG constitutes a normal form.","We use r 0 to denote a production in"]},{"title":"PL,","paragraphs":["where","the parentheses remind us that we are in a LIG! The"]},{"title":"CF-backbone","paragraphs":["of a LIG is the underlying CFG in which each production is a LIG production where the stack part of each constituent has been deleted, leaving only the non-terminal part. We will only consider LIGs such there is a bijection between its production set and the production set of its CF-backbone 3.","We call"]},{"title":"object","paragraphs":["the pair denoted"]},{"title":"A(a)","paragraphs":["where A is a non-terminal and (a) a stack of symbols. Let"]},{"title":"Vo","paragraphs":["= {A(a)"]},{"title":"[ A • VN Aa • V;}","paragraphs":["be the set of objects. We define on"]},{"title":"(Vo LJ VT)*","paragraphs":["the binary relation"]},{"title":"derives","paragraphs":["denoted =~ (the relation symbol is sometimes","L","overlined by a production):"]},{"title":"r A(a\"a)r","paragraphs":["L I i A()=~w rlA()r2 ' ' FlWF2 L In the first above element we say that the object"]},{"title":"B(a\"a ~)","paragraphs":["is the"]},{"title":"distinguished child","paragraphs":["of"]},{"title":"A(a\"a),","paragraphs":["and if F1F2 = C0, C0 is the"]},{"title":"secondary object. A deriva- tion","paragraphs":["F~,..., Fi, Fi+x,..., Ft is a sequence of strings where the relation derives holds between any two consecutive strings The language defined by a LIG L is the set: £(L) = {x [ S 0 :=~ x A x • V~ } L","As in the CF case we can talk of rightmost derivations when the rightmost object is derived at each step. Of course, many other derivation strategies may be thought of. For our parsing algorithm, we need such a particular derives relation. Assume that at one step an object derives both a distinguished","3rp and rp0 with the same index p designate associated productions. child and a secondary object. Our particular derivation strategy is such that this distinguished child will always be derived after the secondary object (and its descendants), whether this secondary object lays to its left or to its right. This derives relation is denoted =~ and is called"]},{"title":"linear 4.","paragraphs":["l,L"]},{"title":"A spine","paragraphs":["is the sequence of objects"]},{"title":"Al(al) • .. Ai(ai) Ai+l (~i+1)... Ap(ap)","paragraphs":["if, there is a derivation in which each object Ai+l (ai+l) is the distinguished child of"]},{"title":"Ai(ai)","paragraphs":["(and therefore the"]},{"title":"distin- guished descendant","paragraphs":["of"]},{"title":"Aj(aj), 1 <_ j <_ i).","paragraphs":["4 Linear Derivation Grammar For a given LIG L, consider a linear"]},{"title":"SO~x-derivation so","paragraphs":[". . . . . . = t,L t,L l,L","The sequence of productions rl0...riO...rnO (considered in reverse order) is a string in P~. The purpose of this section is to define the set of such strings as the language defined by some CFG.","Associated with a LIG"]},{"title":"L = (VN, VT, VI, PL,","paragraphs":["S), we first define a bunch of binary relations which are borrowed from (Boullier , 1995) -4,- = {(A,B) [A(..) ~ r,B(..)r~ e PL} 1 \"r"]},{"title":"-~ = {(A,B) I A(.. ) -~","paragraphs":["rlB(..~)r2 e"]},{"title":"PL}","paragraphs":["1 7 >-"]},{"title":"= {(A,B) I 4 rxB(..)r2 e PL}","paragraphs":["I -~ = {(A1,Ap) [A10 =~ rlA,()r~ and A,0 q-L is a distinguished descendant of A1 O} The"]},{"title":"l-level","paragraphs":["relations simply indicate, for each production, which operation can be apply to the stack associated with the LHS non-terminal to get the stack associated with its distinguished child; ~ in-","1 dicates equality, -~ the pushing of 3\", and ~- the pop-","1 1 ping of 3'-","If we look at the evolution of a stack along a spine A1 (ax)... Ai (ai)Ai+x (ai+x)..."]},{"title":"Ap (ap),","paragraphs":["between any two objects one of the following holds: OL i ~ O~i+1, Oli3 , ~ OLi+I, or ai = ai+l~. The -O- relation select pairs of non-terminals","+ (A1, Ap) s.t. al = ap = e along non trivial spines.","4linear reminds us that we are in a LIG and relies upon a linear (total) order over object occurrences in a derivation. See (Boullier, 1996) for a more formal definition. 89 7 7 7","If the relations >- and ~ are defined as >-=>-","+ + 1 7 \"/7"]},{"title":"U ~-~-","paragraphs":["and ~----"]},{"title":"UTev~","paragraphs":["\"<>', we can see that the +1 1+","following identity holds Property 1 --¢,- = -¢.-U~U-K>--~,-Uw.,--~- + 1 1 + + In (Boullier, 1995) we can found an algorithm s","which computes the -~, >- and ~ relations as the + +","composition of -,¢,-, -~ and ~- in O(IVNI 3) time. 1 1 1 Definition 3 For a LIG L = (VN, VT, Vz, PL, S), we call linear derivation grammar (LDG) the CFG DL (or D when L is understood) D = (VND, V D, pD, S D) where • V D={[A]IA•VN}U{[ApB]IA,B•VNA","p • 7~}, and ~ is the set of relations {~,-¢,-,'Y 1 1 • VTD = pL • S ° ="]},{"title":"[S]","paragraphs":["• Below, [F1F2] symbol [X] when FIF2 = string e when F1F2 • V~. being denotes either the non-terminal","X 0 or the empty","po is defined as {[A] -+ r 0"]},{"title":"I rO","paragraphs":["= AO -~ w • PL} (1) U{[A] -+ r0[A +-~ B]I r 0 = B 0 -+ w • PL} (2)"]},{"title":"UI[A +~- C] ~ [rlr~]r0 I","paragraphs":["r 0 = A(..) ~ r,c(..)r: • PL} (3) u{[A +-~ C] --+ [A ~ C]} (4)"]},{"title":"u{[A c] [B c][rlr:lr0 I r0 = AC) rls(..)r2 • PL} (5) (6)","paragraphs":["U{[A +-~ C] -> [B ~ C][A ~ B]} U{[A ~ C] ~ [B ~- c][rlr2]r0"]},{"title":"I","paragraphs":["+ r 0 = A(..) ~ rlB(..~)r2 • PL} (7)","5Though in the referred paper, these relations are defined on constituents, the algorithm also applies to non-terminals.","6In fact we will only use valid non-terminals [ApB] for which the relation p holds between A and B. U{[A ~ C] ~ [rlr~]r0"]},{"title":"I","paragraphs":["-I-r0 = A(..7) ~ rlc(..)r~ • PL} (8) U{[A ~-+ C] --~ [F1F2]r0[A ~ S]l"]},{"title":"r0 = B(..-y) rlc(..)r, • (9)","paragraphs":["The productions in pD define all the ways linear derivations can be composed from linear sub-derivations. This compositions rely on one side upon property 1 (recall that the productions in PL, must be produced in reverse order) and, on the other side, upon the order in which secondary spines (the rlF2-spines) are processed to get the linear derivation order.","In (Boullier, 1996), we prove that LDGs are not ambiguous (in fact they are SLR(1)) and define £(D) = {nO.-.r-OISOr~)... r_~)x l,L f.,L Ax 6 £(L)}","If, by some classical algorithm, we remove from D all its useless symbols, we get a reduced CFG say D' = (VN D' , VT D' , pD', SO' ). In this grammar, all its terminal symbols, which are productions in L, are useful. By the way, the construction of D' solve the emptiness problem for LIGs: L specify the empty set iff the set VT D' is empty 7. 5 LIG parsing Given a LIG L : (VN, VT, Vz, PL, S) we want to find all the syntactic structures associated with an input string x 6 V~. In section 2 we used a CFG (the shared parse forest) for representing all parses in a CFG. In this section we will see how to build a CFG which represents all parses in a LIG.","In (Boullier, 1995) we give a recognizer for LIGs with the following scheme: in a first phase a general CF parsing algorithm, working on the CF-backbone builds a shared parse forest for a given input string x. In a second phase, the LIG conditions are checked on this forest. This checking can result in some subtree (production) deletions, namely the ones for which there is no valid symbol stack evaluation. If the resulting grammar is not empty, then x is a sentence. However, in the general case, this resulting grammar is not a shared parse forest for the initial LIG in the sense that the computation of stack of symbols along spines are not guaranteed to be consistent. Such invalid spines are not deleted during the check of the LIG conditions because they could be","7In (Vijay-Shanker and Weir, 1993) the emptiness problem for LIGs is solved by constructing an FSA. 90 composed of sub-spines which are themselves parts of other valid spines. One way to solve this problem is to unfold the shared parse forest and to extract individual parse trees. A parse tree is then kept iff the LIG conditions are valid on that tree. But such a method is not practical since the number of parse trees can be unbounded when the CF-backbone is cyclic. Even for non cyclic grammars, the number of parse trees can be exponential in the size of the input. Moreover, it is problematic that a worst case polynomial size structure could be reached by some sharing compatible both with the syntactic and the %emantic\" features.","However, we know that derivations in TAGs are context-free (see (Vijay-Shanker, 1987)) and (Vijay-Shanker and Weir, 1993) exhibits a CFG which represents all possible derivation sequences in a TAG. We will show that the analogous holds for LIGs and leads to an O(n 6) time parsing algorithm. Definition 4 Let L = (VN, VT, VI, PL, S) be a LIG, G = (VN,VT,PG, S) its CF-backbone, x a string in E(G), and G ~ = (V~,V~,P~,S ~) its shared parse ]orest for x. We define the LIGed forest for x as being the LIG L ~ = (V~r, V~, VI, P~, S ~) s.t. G z is its CF-backbone and its productions are the productions o] P~ in which the corresponding stack-schemas o] L have been added. For example rg 0 = [AI~(..~) -4 [BI{(..~')[C]~0 e P~ iff","J k r q = [A] k -4 [B]i[C]j e P~Arp = A -4 BC e G A rpO = A(..~) -4 B(..~')C 0 e n.","Between a LIG L and its LIGed forest L ~ for x, we have: x~£(L) ¢==~ xCf~(L ~)","If we follow(Lang, 1994), the previous definition which produces a LIGed forest from any L and x is a (LIG) parserS: given a LIG L and a string x, we have constructed a new LIG L ~ for the intersection Z;(L) C) {x}, which is the shared forest for all parses of the sentences in the intersection. However, we wish to go one step further since the parsing (or even recognition) problem for LIGs cannot be trivially extracted from the LIGed forests.","Our vision for the parsing of a string x with a LIG L can be summarized in few lines. Let G be the CF-backbone of L, we first build G ~ the CFG shared parse forest by any classical general CF parsing algorithm and then L x its LIGed forest. Afterwards, we build the reduced LDG DL~ associated with L ~ as shown in section 4. Sof course, instead of x, we can consider any FSA. 91","The recognition problem for (L, x) (i.e. is x an element of £(L)) is equivalent to the non-emptiness of the production set of OLd.","Moreover, each linear SO~x-derivation in L is (the reverse of) a string in ff.(DL*)9. So the extraction of individual parses in a LIG is merely reduced to the derivation of strings in a CFG.","An important issue is about the complexity, in time and space, of DL~. Let n be the length of the input string x. Since G is in binary form we know that the shared parse forest G x can be build in O(n 3) time and the number of its productions is also in O(n3). Moreover, the cardinality of V~ is O(n 2) and, for any given non-terminal, say [A] q, there are at most O(n) [A]g-productions. Of course, these complexities extend to the LIGed forest L z.","We now look at the LDG complexity when the input LIG is a LIGed forest. In fact, we mainly have to check two forms of productions (see definition 3). The first form is production (6) ([A +-~ C] -+ [B","+ C][A ~-0 B]), where three different non-terminals in VN are implied (i.e. A, B and C), so the number of productions of that form is cubic in the number of non-terminals and therefore is O(n6).","In the second form (productions (5), (7) and (9)), exemplified by [A ~ C] -4 [B ~"]},{"title":"c][rlr2]r(),","paragraphs":["there","÷ are four non-terminals in VN (i.e. A, B, C, and X if FIF2 = X0) and a production r 0 (the number of relation symbols ~ is a constant), therefore, the","÷ number of such productions seems to be of fourth degree in the number of non-terminals and linear in the number of productions. However, these variables are not independant. For a given A, the number of triples (B,X, r0) is the number of A-productions hence O(n). So, at the end, the number of productions of that form is O(nh).","We can easily check that the other form of productions have a lesser degree.","Therefore, the number of productions is dominated by the first form and the size (and in fact the construction time) of this grammar is 59(n6).","This (once again) shows that the recognition and parsing problem for a LIG can be solved in 59(n 6) time.","For a LDG D = (V D, V D, pD SD), we note that for any given non-terminal A E VN D and string a E £:(A) with [a[ >_ 2, a single production A -4 X1X2 or A -4 X1X2X3 in pD is needed to \"cut\" a into two or three non-empty pieces al, 0\"2, and 0-3, such that","°In fact, the terminal symbols in DL~ axe productions in L ~ (say Rq()), which trivially can be mapped to productions in L (here rp()). Xi ~ a{, except when the production form num-","D bet (4) is used. In such a case, this cutting needs two productions (namely (4) and (7)). This shows that the cutting out of any string of length l, into elementary pieces of length 1, is performed in using O(l) productions. Therefore, the extraction of a linear so~x-derivation in L is performed in time linear with the length of that derivation. If we assume that the CF-backbone G is non cyclic, the extraction of a parse is linear in n. Moreover, during an extraction, since DL= is not ambiguous, at some place, the choice of another A-production will result in a different linear derivation.","Of course, practical generations of LDGs must improve over a blind application of definition 3. One way is to consider a top-down strategy: the X-productions in a LDG are generated iff X is the start symbol or occurs in the RHS of an already generated production. The examples in section 6 are produced this way.","If the number of ambiguities in the initial LIG is bounded, the size of DL=, for a given input string x of length n, is linear in n.","The size and the time needed to compute DL. are closely related to the actual sizes of the -<~-, >- and","+ +","relations. As pointed out in (Boullier, 1995), their O(n 4) maximum sizes seem to be seldom reached in practice. This means that the average parsing time is much better than this"]},{"title":"(..9(n 6) worst","paragraphs":["case.","Moreover, our parsing schema allow to avoid some useless computations. Assume that the symbol [A ~ B] is useless in the LDG DL associated with the initial LIG L, we know that any non-terminal s.t. [[A]{ +-~ [B]~] is also useless in DL=. Therefore, the static computation of a reduced LDG for the initial LIG L (and the corresponding -¢-, >- and .~","+ + relations) can be used to direct the parsing process and decrease the parsing time (see section 6). 6 Two Examples 6.1 First Example In this section, we illustrate our algorithm with a LIG L -- ({S, T], {a, b, c}, {7~, 75, O'c}, PL, S) where PL contains the following productions: ~ 0 : s(..) -+ s(..eo)~ r30 : s(..) --+"]},{"title":"S(..%)c","paragraphs":["rhO : T(..7~) --+ aT(..)","rT0 = T(..%) -+ cT(..) r20 = S(..) --+ S(..Tb)b r40 = S(..) --+ T(..) r60 = T(..%) -+ bT(..) rs0 = T0 --+ c It is easy to see that its CF-backbone G, whose 92 production set Pc is: S-+ Sa S-~ Sb S-+ S c S-~ T T-}aT T -+ bT T -~ cT T -+ c defines the language £(G) = {wcw' I w,w' 6 {a, b, c]*}. We remark that the stacks of symbols in L constrain the string w' to be equal to w and therefore the language £(L) is {wcw I w 6 {a, b, c]*}.","We note that in L the key part is played by the middle c, introduced by production rs0, and that this grammar is non ambiguous, while in G the symbol c, introduced by the last production T ~ c, is only a separator between w and w' and that this grammar is ambiguous (any occurrence of c may be this separator).","The computation of the relations gives: + = {(S,T)} 1 9% \"{b 9\"¢ = ~ = ~ = {(s,s)} 1 1 1 9% \"Tb ~c >- = >- = >- = ~(T,T]] 1 1 1 + = {(S,T)} + = {(S,T)} 9'a 9'5 '7c >.- = >- = >- = {(T,T),(S,T)} + + +","The production set pD of the LDG D associated with L is: [S] --+ rs0[S -~+ T] (2) IS T T] -+ ~0 (3) [S +-~T] --+ [S~T] (4) IS ~ T] --+ [S ~ T]rl 0 (7) [S ~ T] --+ [S ,~ T]r20 (7) [S ~ T] =-+ IS ~- T]ra 0 (7) + [S ~ T] -=+ rh()[S +-~ T] (9) IS ~:+ T] + ~()[S ~ T] (9) [S ~ T] --+ rT0[S -~+ T] (9)","The numbers (i) refer to definition 3. We can easily checked that this grammar is reduced.","Let x = ccc be an input string. Since x is an element of £(G), its shared parse forest G x is not empty. Its production set P~ is: rl = [s]~ -+ [s]~c r~ = [S]o ~ -+ [S]~c r4 ~ = [s]~ --+ IT] 1 r~ = [T]I 3 --+ c[T] 3 r 9 = [T]~ =+ c[T] 2 ~1 = [T]~ -+ c r~ = [S]~ -+ [T]o ~","r44 = [S]~ --~ [T]o 2","r~ = [T]3o =-+ c[T]31","rs s = [T] 3 --+ c","rs 1° = [T]~ --+ c We can observe that this shared parse forest denotes in fact three different parse trees. Each one corresponding to a different cutting out of x = wcw' (i.e. w = ~ and w' = ce, or w : c and w' = c, or w = ec and w' ="]},{"title":"g).","paragraphs":["The corresponding LIGed forest whose start symbol is S * = [S]~ and production set P~ is: r~0 = [S]o%.) -~ [s]~(..%)¢ ~0 = IS]0%.) -, IT]o%.) ~0 = [S]o%.) ~ [S]o~(..%)c ~40 = [s]~(..) -~ IT]o%.)"]},{"title":"~0 = ISIS(..) ~ [T]~(..) r60 T 3 = []0(..%) -~ ~[T]~(..) r~0 : [T]3(..%) ~ c[T]23(..) rsS0 = [T]~ 0 --+ c r~0 = [T]o%.%) -~ c[T]~(..) r~°0 : [T]~ 0 -+ e ~0 = [T]~0 -~ c","paragraphs":["For this LIGed forest the relations are: 1 1 \")'c 1 + >- __=_ + (([S]o a, [T]oa), ([S]o 2, [T]o2), ([S]o 1, [T]ol) }"]},{"title":"{(IsiS, [s]o~), ([S]o ~, IsiS)}","paragraphs":["{ ([T]o 3, [T]~), ([T] 3 , [T]23), ([T]o 2 , [T]2) }"]},{"title":"{([s]~0, [T]~)}","paragraphs":["-¢.- (3 ~ 1 U{ ([S]o 3, [T]13), ([S]o 2, [T]~) }","The start symbol of the LDG associated with the LIGed forest L * is [[S]o3]. If we assume that an A-production is generated iff it is an [[S]o3]-production or A occurs in an already generated production, we get:"]},{"title":"[[S]o ~] ~ ~°()[[s]~ +~ [T]~] (2) [[S]~ +~ [T]~] -+ [[S]o ~ ~ [Th'] (4)","paragraphs":["[[S] a ~-. [TIll -+ [[S]o 2 ~2 [T]~]r~ () (7) +"]},{"title":"[[S]o ~ ~:+ [T]~] -~ ~()[[S]o ~ ~+ [T]o ~1 (9) [[S]~ ~ [T]~] ~ ~0 (3)","paragraphs":["This CFG is reduced. Since its production set is non empty, we have ccc E ~(L). Its language is {r~ ° 0 r9 0 r4 ()r~ 0 } which shows that the only linear derivation in L is S() ~) S(%)c r~) T(Tc)C r=~)","t,L t,L l,L"]},{"title":"eT()c ~)","paragraphs":["ccc. g,L 93","In computing the relations for the initial LIG L, we remark that though T ~2 T, T ~ T, and T ~ T, + + + the non-terminals IT ~ T], [T ~ T], and IT ~: T] are + + not used in pp. This means that for any LIGed forest L ~, the elements of the form ([Tip q, [T]~:) do not","\")'a need to be computed in the ~+, ~+ , and ~:+ relations since they will never produce a useful non-terminal. In this example, the subset ~: of ~: is useless.","1 -b","The next example shows the handling of a cyclic grammar. 6.2 Second Example The following LIG L, where A is the start symbol: rl() = A(..) ~ A(..%) r2() = A(..) ~ B(..) r30 = B(..%) -~ B(..) r40 = B0 ~ a is cyclic (we have A =~ A and B =~ B in its CF-backbone), and the stack schemas in production rl 0 indicate that an unbounded number of push % ac-tions can take place, while production r3 0 indicates an unbounded number of pops. Its CF-backbone is unbounded ambiguous though its language contains the single string a.","The computation of the relations gives: -~- = {(A,B)} 1 -< = {(A,A)} 1 >- = {(B,B)} 1 + = {(A,B)} + = {(d, B)} 7a ~- = {(A, B), (B, B)} +","The start symbol of the LDG associated with L is [A] and its productions set pO is: [A] -+ r40[A +-~ B] (2) [A +~B] -+ r20 (3) [A +~-B] ~ [A~B] (4) [A ~ B] -~ [A ~ B]rl 0 (7) + [A ~2 B] -~ r3 0[A +~- B] (9) + We can easily checked that this grammar is reduced. We want to parse the input string x -- a (i.e. find all the linear SO/a-derivations ). Its LIGed forest, whose start = = [Aft(..) = = [B]o 0 For this LIGed 1 7a ..< 1 1 .<,- + \"t,* + symbol is [A]~ is:"]},{"title":"-, [Aft(..%)","paragraphs":["[B]~(..)","--+ [B]~(..) a forest L x, the relations are:"]},{"title":"{(JAIL","paragraphs":["= {([Aft, [Aft)} = = {([Aft, -= {([Aft, [B]ol)} = {([A]~, [B]~), (IBIS, [B]~)}","The start symbol of the LDG associated with L x is [[A]~]. If we assume that an A-production is generated iff it is an [[A]~]-production or A occurs in an already generated production, its production set is:"]},{"title":"[[AI~]","paragraphs":["-+ r~()[[A]~ +-~ [S] 11 (2) [[A]~ -~+ [B]~] -+ r220 (3) [[A]~ +-~ [B]01] ~ [[A]o 1 ~ [B]o 1] (4) [[A]~ ~. [B]01] -+ [[A]~ ~: [B]~]r I 0 (7) + [[A]~ ~+ [B]~] --4 r3()[[A]l o ~ [S]10] (9)","This CFG is reduced. Since its production set is non empty, we have a 6 £(L). Its language is"]},{"title":"{r4(){r]())kr~O{r~O} k","paragraphs":["]0 < k) which shows that the only valid linear derivations w.r.t. L must contain an identical number k of productions which push 7a (i.e. the production rl0) and productions which pop 7a (i.e. the production r3()).","As in the previous example, we can see that the element [S]~ ~ [B]~ is useless. + 7 Conclusion We have shown that the parses of a LIG can be represented by a non ambiguous CFG. This representation captures the fact that the values of a stack of symbols is well parenthesized. When a symbol 3' is pushed on a stack at a given index at some place, this very symbol must be popped some place else, and we know that such (recursive) pairing is the essence of context-freeness.","In this approach, the number of productions and the construction time of this CFG is at worst O(n6), 94 though much better results occur in practical situa-tions. Moreover, static computations on the initial LIG may decrease this practical complexity in avoid-ing useless computations. Each sentence in this CFG is a derivation of the given input string by the LIG, and is extracted in linear time."]},{"title":"References","paragraphs":["Pierre Boullier. 1995. Yet another (_O(n 6) recognition algorithm for mildly context-sensitive languages. In"]},{"title":"Proceedings of the fourth international workshop on parsing technologies (IWPT'95),","paragraphs":["Prague and Karlovy Vary, Czech Republic, pages 34-47. See also"]},{"title":"Research Report No 2730","paragraphs":["at http: I/www. inria, fr/R2~T/R~-2730.html, INRIA-Rocquencourt, France, Nov. 1995, 22 pages.","Pierre Boullier. 1996. Another Facet of LIG Parsing (extended version). In"]},{"title":"Research Report No P858","paragraphs":["at http://www, inria, fr/RRKT/KK-2858.html, INRIA-Rocquencourt, France, Apr. 1996, 22 pages.","Bernard Lang. 1991. Towards a uniform formal framework for parsing. In"]},{"title":"Current Issues in Pars- ing Technology,","paragraphs":["edited by M. Tomita, Kluwer Academic Publishers, pages 153-171.","Bernard Lang. 1994. Recognition can be harder than parsing. In"]},{"title":"Computational Intelligence,","paragraphs":["Vol. 10, No. 4, pages 486-494.","Yves Schabes, Stuart M. Shieber. 1994. An Alternative Conception of Tree-Adjoining Derivation. In"]},{"title":"ACL Computational Linguistics,","paragraphs":["Vol. 20, No. 1, pages 91-124.","K. Vijay-Shanker. 1987. A study of tree adjoining grammars."]},{"title":"PhD thesis,","paragraphs":["University of Pennsylvania.","K. Vijay-Shanker, David J. Weir. 1993. The Used of Shared Forests in Tree Adjoining Grammar Parsing. In"]},{"title":"Proceedings of the 6th Conference of the European Chapter of the Association for Com- putational Linguistics (EACL'93),","paragraphs":["Utrecht, The Netherlands, pages 384-393.","K. Vijay-Shanker, David J. Weir. 1994. Parsing some constrained grammar formalisms. In"]},{"title":"A CL Computational Linguistics,","paragraphs":["Vol. 19, No. 4, pages 591-636.","K. Vijay-Shanker, David J. Weir, Owen Rambow. 1995. Parsing D-Tree Grammars. In"]},{"title":"Proceed- ings of the fourth international workshop on pars- ing technologies (IWPT'95),","paragraphs":["Prague and Karlovy Vary, Czech Republic, pages 252-259."]}]}
