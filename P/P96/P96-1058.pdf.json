{"sections":[{"title":"Maximizing Top-down Constraints for Unification-based Systems","paragraphs":["Noriko"]},{"title":"Tomuro","paragraphs":["School of Computer Science, Telecommunications and Information Systems","DePaul University","Chicago, IL 60604","cphdnt@ted.cs.depaul.edu Abstract A left-corner parsing algorithm with top-down filtering has been reported to show very efficient performance for unification-based systems. However, due to the nontermination of parsing with left-recursive grammars, top-down constraints must be weakened. In this paper, a general method of maximizing top-down constraints is proposed. The method provides a procedure to dynamically compute *restrictor., a minimum set of features involved in an infinite loop for every propagation path; thus top-down constraints are maximally propagated. 1 Introduction A left-corner parsing algorithm with top-down filtering has been reported to show very efficient performance for unification-based systems (Carroll, 1994). In particular, top-down filtering seems to be very effective in increasing parse efficiency (Shann, 1991). Ideally all top-down expectation should be propagated down to the input word so that unsuccessful rule applications are pruned at the earliest time. However, in the context of unification-based parsing, left-recursive grammars have the formal power of a Turing machine, therefore detection of all infinite loops due to left-recursion is impossible (Shieber, 1992). So, top-down constraints must be weakened in order for parsing to be guaranteed to terminate.","In order to solve the nontermination problem, Shieber (1985) proposes restrictor, a statically pre-defined set of features to consider in propagation, and restriction, a filtering function which removes the features not in restrictor from top-down expectation. However, not only does this approach fail to provide a method to automatically generate the restrictor set, it may weaken the predicative power of top-down expectation more than necessary: a globally defined restrictor can only specify the least common features for all propagation paths.","In this paper, a general method of maximizing top-down constraints is proposed. The method provides a procedure to dynamically compute *restrictor*, a minimum set of features involved in an infinite loop, for every propagation path. Features in this set are selected by the detection function, and will be ignored in top-down propagation. Using .vestrictor., only the relevant features particular to the propagation path are ignored, thus top-down constraints are maximally propagated. 2 Notation We use notation from the PATR-II formalism (Shieber, 1986) and (Shieber, 1992). Directed aeyclie graphs (dags) are adopted as the representa-tion model. The symbol -\" is used to represent the equality relation in the unification equations, and the symbol • used in the form of pl • p2 represents the path concatenation of pl and p2.","The subsumption relation is defined as \"Dag D subsumes dag D ~ if D is more general than D'.\" The unification of D and D ~ is notated by D tJ D ~.","The extraction function D/pl extracts the subdag under path pl for a given D, and the embedding function D \\ pl injects D into the enclosing dag D' such that D'/pl = D. The filtering function p is similar to (Shieber, 1992): p(D) returns a copy of D in which some features may be removed. Note that in this paper .restrictor. specifies the features to be removed by p, whereas in (Shieber, 1985, 1992) restrictor specifies the features to be retained by restriction which is equivalent to p. 3 Top-down Propagation Top-down propagation can be precomputed to form a teachability table. Each entry in the table is a compiled dag which represents the relation between a non-terminal category and a rule used to rewrite the constituents in the teachability relation (i.e., reflexive, transitive closure of the left-corner path).","For example, consider the following fragment of a grammar used in the syntax/semantics integrated system called LINK (Lytinen, 1992):"]},{"title":"381","paragraphs":["s~m ~ own~ D(1) em D(2) Ic (~._.~ead owner D(3) Figure 1: DAGs used in the example"]},{"title":"he° rZ=","paragraphs":["sere ~ owfler D(4)","rl : NPo -+ NP1 POS NP2 (NPo head) = (NP2 head) (YPo head sem owner) - (NP1 head sem)","(This rule is used to parse phrases such as \"Kris's desk\" .)","The dag D(1) in Figure 11 represents the initial application of rl to the category NP. Note that the subdag under the lc arc is the rule used to rewrite the constituent on the left-corner path, and the paths from the top node represent which top-down constraints are propagated to the lower level.","Top-down propagation works as follows: given a dad D that represents a teachability relation and a rule dad R whose left-hand side category (i.e., root) is the same as D's left-corner category (i.e., under its (lc 1) path), the resulting dag is D1 = p(D') U (R \\ lc), where D' is a copy of D in which all the numbered arcs and lc arc are deleted and the subdag which used to be under the (lc 1) path is promoted to lie under the lc arc. Dags after the next two recursive applications of rl (D(2) and D(3) respectively 2) are shown in Figure 1.","Notice the filtering function p is applied only to D'. In the case when p(D') = nil, the top node in D1 will have no connections to the rule dag under the lc arc. This means no top-down constraints are propagated to the lower level, therefore the parsing becomes pure bottom-up.","In many unification-based systems, subsumption is used to avoid redundancy: a dag is recorded in the table if it is not subsumed by any other one. Therefore, if a newly created dag is incompatible or more general than existing dags, rule application continues. In the above example, D(2) is incompatible with D(1) and therefore gets entered into the table. The owner arc keeps extending in the subsequent recursive applications (as in D(3)), thus the propagation goes into an infinite loop. 1 Category symbols are directly indicated in the dad","nodes for simplicity. 2In this case, p is assumed to be an identity function. 3.1 Proposed Method Let A be a dag created by the first application of the rule R and B be a dad created by the second application during the top-down propagation. 3 In the proposed method, A and B are first checked for subsumption. If B is subsumed by A, the propagation for this path terminates. Otherwise a possible loop is detected. The detection function (described in the next subsection) is called on A and B and selected features are added to the .restrictor. set. 4 Then, using the updated *restrictor*, propagation is re-done from A.","When R is applied again yielding B', while B' is not subsumed by A, the following process is repeated: if B' is incompatible with A, the detection function is called on A and B' and propagation is re-done from A. If B' is more general than A, then A is replaced by B' (thereby keeping the most general dag for the path) and propagation is re-done from B'. Otherwise the process stops for this propagation path. Thus, the propagation will terminate when enough features are detected, or when *restrictor* includes all the (finite number of) features in the grammar. 5","In the example, when the detection function is called on D(1) and D(2) after the first recursive application, the feature owner is selected and added to *restrictor*. After the propagation is re-done from D(1), the resulting dad D(4) becomes more general than O(1). 6 Then D(1) is replaced by 0(4), and the propagation is re-done once again. This time it results the same D(4), therefore the propagation","3 In the case of indirect recursion, there are some in-tervening rule applications between A and B.","4A separate *restrictor* must be kept for each propagation path.","51n reality, category feature will never be in *restrictor* because the same rule R is applied to derive both A and B'.","6Remember 0(4) = p(D(1)') U (rl \\ le) where p filters out owner arc."]},{"title":"382","paragraphs":["terminates.","3.2 Detection Function","The detection function compares two dags X and Y","by checking every constraint (unification equation)","x in X with any inconsistent or more general con-","straint y in Y. If such a constraint is found, the","function selects a path in x or y and detects its last","arc/feature as being involved in the possible loop. 7 If x is the path constraint pl - p2 where pl and","p2 are paths of length > I, features may be detected","in the following cases: 8 • (case 1) If both pl and p2 exist in Y, and there","exists a more general constraint y in Y in the","form pl • p3 - p2 - p3 (length of p3 is also > 1),","the path p3 is selected; • (case 2) If both pl and p2 exist in Y, but the","subdag under pl and the subdag under p2 do","not unify, or if neither pl nor p2 exists in Y,","whichever of pl or p2 does not contain the lc","arc, or either if they both contain the lc arc, is","selected; and • (case 3) If either pl or p2 does not exist in Y,","the one which does not exist in Y is selected.","If x is the constant constraint pl - c (where c is","some constant), features may be detected in the fol-","lowing cases: • (case 4) If there exists an incompatible con-","straint y of the form pl - d where d 7~ c in","Y, or if there is no path pl in Y, pl is selected;","and • (case 5) If there exists an incompatible con-","straint y of the form pl • p2 - c, then p2 is","selected. 4 Related Work A similar solution to the nontermination problem with unification grammars in Prolog is proposed in (Samuelsson, 1993). In this method, an operation called anti-unification (often referred to as general-ization as the counterpart of unification) is applied to the root and leaf terms of a cyclic propagation, and the resulting term is stored in the reachablity table as the result of applying restriction on both terms. Another approach taken in (Haas, 1989) eliminates the cyclic propagation by replacing the features in the root and leaf terms with new variables.","The method proposed in this paper is more general than the above approaches: if the Selection ordering is imposed in the detection function, features in .restrictor. can be collected incrementally as the cyclic propagations are repeated. Thus, this method 7This scheme may be rather conservative. 8Note the cases in this section do not represent all","possible situations. is able to create a less restrictive *restrictor. than these other approaches. 5 Discussion and Future Work The proposed method has an obvious difficulty: the complexity caused by the repeated propagations could become overwhelming for some grammars. However, in the experiment on LINK system using a fairly broad grammar (over 130 rules), precompilation terminated with only a marginally longer processing time.","In the experiment, all features (around 40 syntactic/semantic features) except for one in the example in this paper were able to be used in propagation. In the preliminary analysis, the number of edges entered into the chart has decreased by 30% compared to when only the category feature (i.e., context-free backbone) was used in propagation.","For future work, we intend to apply the proposed method to other grammars. By doing the empirical analysis of precompilation and parse efficiency for different grammars, we will be able to conclude the practical applicability of the proposed method. We also indend to do more exhaustive case analysis and investigate the selection ordering of the detection function. Although the current definition covers most cases, it is by no means complete."]},{"title":"References","paragraphs":["Carroll, J. (1994). Relating complexity to practical performance in parsing with wide-coverage unification grammars. In Proceedings of the 32nd Annual Meeting of the Association for Computational Linguistics, pp. 287-293.","Haas, A. (1989). A parsing algorithm for unification grammar, Computational Linguistics, 15(4), pp. 219-232.","Lytinen, S. (1992). A unification-based, integrated natural language processing system. Computers and Mathematics with Applications, 23(6-9), pp. 403-418.","Samuelsson, C. (1993). Avoiding non-termination in unification grammars. In Proceedings of Natural Language Understanding and Logic Programming IV, Nara, Japan.","Shann, P. (1991). Experiments with GLR and chart parsing. In Tomita, M. Generalized LR Parsing. Boston: Kluwer Academic Publishers, p. 17-34.","Shieber, S. (1985). Using restriction to extend parsing algorithms for complex-feature-based for-malisms. In Proceedings of the 23rd Annual Meeting of the Association for Computational Linguistics, Chicago, IL, pp. 145-152.","Shieber, S. (1986). An Introduction to Unification-Based Approaches to Grammar. Stanford, CA: Center for the Study of Language and Information.","Shieber, S. (1992). Constraint-based Grammar Formalisms. Cambridge, MA: MIT Press."]},{"title":"383","paragraphs":[]}]}
