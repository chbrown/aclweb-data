{"sections":[{"title":"Parsing Non-Recursive Context-Free Grammars Mark-Jan Nederhof  Faculty of Arts University of Groningen P.O. Box 716 NL-9700 AS Groningen, The Netherlands markjan@let.rug.nl Giorgio Satta Dip. di Elettronica e Informatica Università di Padova via Gradenigo, 6/A I-35131 Padova, Italy satta@dei.unipd.it Abstract","paragraphs":["We consider the problem of parsing non-recursive context-free grammars, i.e., context-free grammars that generate finite languages. In natural language processing, this problem arises in several areas of application, including natural language generation, speech recognition and machine translation. We present two tabular algorithms for parsing of non-recursive context-free grammars, and show that they perform well in practical settings, despite the fact that this problem is PSPACEcomplete."]},{"title":"1 Introduction","paragraphs":["Several applications in natural language processing require “parsing” of a large but finiteset of candidate strings. Here parsing means some computation that selects those strings out of the finiteset that are well-formed according to some grammar, or that are most likely according to some language model. In these applications, the finite set is typically encoded in a compact way as a context-free grammar (CFG) that is non-recursive. This is motivated by the fact that non-recursive CFGs allow very compact representations for finite languages, since the strings derivable from single nonterminals may be substrings of many different strings in the language. Unfolding such a grammar and parsing the generated strings","","Secondary affiliationis the German Research Center for ArtificialIntelligence (DFKI). one by one then leads to an unnecessary duplica-tion of subcomputations, since each occurrence of a repeated substring has to be independently parsed. As this approach may be prohibitively expensive, it is preferable to find a parsing algorithm that shares subcomputations among different strings by working directly on the nonterminals and the rules of the non-recursive CFG. In this way, “parsing” a nonterminal of the grammar amounts to shared parsing of all the substrings encoded by that nonterminal.","To give a few examples, in some natural language generation systems (Langkilde, 2000) non-recursive CFGs are used to encode very large sets of candidate sentences realizing some input conceptual representation (Langkilde calls such grammars forests). Each CFG is later “parsed” using a language model, in order to rank the sentences in the set according to their likelyhood. Similarly, in some approaches to automatic speech understand-ing (Corazza and Lavelli, 1994) the ","-best sentences obtained from the speech recognition module are “compressed” into a non-recursive CFG grammar, which is later provided as input to a parser. Finally, in some machine translation applications related techniques are exploited to obtain sentences that simultaneously realize two different conceptual representations (Knight and Langkilde, 2000). This is done in order to produce translations that preserve syntactic or semantic ambiguity in cases where the ambiguity could not be resolved when processing the source sentence.","To be able to describe the above applications in an abstract way, let us first fix some terminology. The term “recognition” refers to the process of deciding Computational Linguistics (ACL), Philadelphia, July 2002, pp. 112-119. Proceedings of the 40th Annual Meeting of the Association for whether an input string is in the language described by a grammar, the parsing grammar",". We will generalize this notion in a natural way to input representing a set of strings, and here the goal of recognition is to decide whether at least one of the strings in the set is in the language described by",". If the input is itself given in the form of a grammar, the input grammar",", then recognition amounts to determining whether the intersection of the languages described by","and","is non-empty. In this paper we use the term parsing as synonymous to recognition, since the recognition algorithms we present can be easily extended to yield parse trees (with associated probabilities if either","or","or both are probabilistic).","In what follows we consider the case where both ","and","are CFGs. General CFGs have unfavourable computational properties with respect to intersection. In particular, the problem of deciding whether the intersection of two CFGs is non-empty is undecidable (Harrison, 1978). Following the ter-minology adopted above, this means that parsing a context-free input grammar","on the basis of a context-free parsing grammar","is not possible in general.","One way to make the parsing problem decidable is to place some additional restrictions on","or ",". This direction is taken by Langkilde (2000), where","","is a non-recursive CFG and","","represents a regular language, more precisely an ","-gram model. In this way the problem can be solved using a stochastic variant of an algorithm presented by Bar-Hillel et al. (1964), where it is shown that the intersection of a general context-free language and a regular language is still context-free.","In the present paper we leave the theoretical framework of Bar-Hillel et al. (1964), and consider parsing grammars","that are unrestricted CFGs, and input grammars","that are non-recursive context-free grammars. In this case the parsing (intersection) problem becomes PSPACE-complete.1 Despite of this unfavourable theoretical result, algorithms for the problem at hand have been proposed in the literature and are currently used in practical applications. In (Knight and Langkilde, 2000)","is 1","The PSPACE-hardness result has been shown by Harry B. Hunt III and Dan Rosenkrantz (Harry B. Hunt III, p.c.). Membership in PSPACE is shown by Nederhof and Satta (2002). unfolded into a lattice (acyclic finiteautomaton) and later parsed with","using an algorithm close to the one by Bar-Hillel et al. (1964). The algorithm proposed by Corazza and Lavelli (1994) involves copying of charts, and this makes it very similar in be-haviour to the former approach. Thus in both algorithms parts of the input grammar","are copied where a nonterminal occurs more than once, which destroys the compactness of the representation. In this paper we propose two alternative tabular algorithms that exploit the compactness of","as much as possible. Although a limited amount of copying is also done by our algorithms, this never happens in cases where the resulting structure is ungrammatical with respect to the parsing grammar","",".","The structure of this paper is as follows. In Section 2 we introduce some preliminary definitions, followed in Section 3 by a first algorithm based on CKY parsing. A more sophisticated algorithm, satisfying the equivalent of the correct-prefixproperty and based on Earley’s algorithm, is presented in Section 4. Section 5 presents our experimental results and Section 6 closes with some discussion."]},{"title":"2 Preliminaries","paragraphs":["In this section we briefly recall some standard no-tions from formal language theory. For more details we refer the reader to textbooks such as (Harrison, 1978).","A context-free grammar is a 4-tuple ",", where","is a finite set of terminals, called the","alphabet,","is a finiteset of nonterminals, including","the start symbol",", and ","is a finiteset of rules hav-","ing the form","with","and  ",".","Throughout the paper we assume the following con-","ventions:",", denote nonterminals,",",","de-","note terminals,",", ,","are strings in   and  ","are strings in",". We also assume that each CFG is reduced, i.e., no CFG contains nonterminals that do not occur in any derivation of a string in the language. Furthermore, we assume that the input grammars do not contain epsilon rules and that there is only one rule","definingthe start symbol",".2 Finally, in Section 3 we will consider parsing gram-","2","Strictly speaking, the assumption about the absence of epsilon rules is not without loss of generality, since without epsilon rules the language cannot contain the empty string. However, this has no practical consequence. mars in Chomsky normal form (CNF), i.e., grammars with rules of the form","or",".","Instead of working with non-recursive CFGs, it will be more convenient in the specification of our algorithms to encode","as a push-down automaton (PDA) with stack size bounded by some constant. Unlike many text-books, we assume PDAs do not have states; this is without loss of generality, since states can be encoded in the symbols that occur top-most on the stack. Thus, a PDA is a 5-tuple  ","   ",", where","is the alphabet as above,"," is a finiteset of stack symbols including the initial","stack symbol","  and the finalstack symbol"," ",",","and","is the set of transitions, having one of the fol-","lowing three forms:    (a push transition), "," ","(a pop transition), or","    ","(a scan","transition, scanning symbol","). Throughout this pa-","per we use the following conventions:    ","denote stack symbols and are strings in  representing stacks. We remark that in our notation stacks grow from left to right, i.e., the top-most stack symbol will be found at the right end.","Configurationsof the PDA have the form  , where  is a stack and ","is the remain-","ing input. We let the binary relation","be definedby:","    ","if and only if there is a transi-","tion in of the form","","",", where",", or of the form   ","",", where","",". The relation","denotes the refle xive and transitive closure of",". An","input string is recognized by the PDA if and only","if      ","     ."]},{"title":"3 The CKY algorithm","paragraphs":["In this section we present our firstparsing algorithm, based on the so-called CKY algorithm (Harrison, 1978) and exploiting a decomposition of computations of PDAs cast in a specificform. We start with a construction that translates the non-recursive input CFG","into a PDA accepting the same language.","Let",""," . The PDA associated","with is specifiedas   ","where","consists of symbols of the form",""," for   ",", and contains the following transitions:"," For each pair of rules","and",", ","contains:   ","   and   "," ",".","","For each rule","","",",","contains:","","  "," ",".","Observe that for all PDAs constructed as above, no push transition can be immediately followed by a pop transition, i.e., there are no stack symbols  , ","and such that    and ","  . As a consequence of this, a computation      ","    ","of the PDA can always and uniquely be decomposed into consecutive subcomputations, which we call segments, each starting with zero or more push transitions, followed by a single scan transition and by zero or more pop transitions. In what follows, we will formalize this basic idea and exploit it within our parsing algorithm.","We write  "," to indicate that there is a computation   ","  ","of the PDA such that all of the following three conditions hold:","(i) either",""," or","","",";","(ii) the computation starts with zero or more push transitions, followed by one scan transition reading","and by zero or more pop transitions;","(iii) if ","","then the top-most symbol of","must","be in the right-hand side of a pop or scan tran-","sition (i.e., top-most in the stack at the end of a","previous segment) and if","","",", then the top-","most symbol of","must be the left-hand side of","a push or scan transition (i.e., top-most in the","stack at the beginning of a following segment).","Let ","","              ","      ",", and"," ","","           ","     ","      ",". A formal definitionof relation","above is provided in Figure 1 by means of a deduction system. We assign a procedural interpretation to such a system following Shieber et al. (1995), resulting in an algorithm for the computation of the relation.","We now turn to an important property of segments. Any computation","      ","    ",",  , can be computed by combining","  ","","     (1)","  ","             (2) ","  "," ","          (3)","                 (4) Figure 1: Inference rules for the computation of relation",". ","      ","         (5)","  ",""," ",""," ",""," (6)","","","",""," ","  (7) Figure 2: Inference rules for combining segments       ."," segments represented by  ","",",","",",","with  ","",","," ","","",", and for","",",","","is a suffixof","","","or","","","is a suffixof",". This","is done by the deduction system given in Figure 2,","which defines the relation","",". The second side-","condition of inference rule (5) checks whether a seg-","ment","    ","may border on other segments, or may be the firstor last segment in a computation. Figure 3 illustrates a computation of a PDA recognizing a string","","",". A horizontal line segment in the curve represents a scan transition, an upward line segment represents a push transition, and a downward line segment a pop transition. The shaded areas represent segments","     . As an example, the area labelled I represents","  ","    , for certain stack symbols   and   , where the left","edge of the shaded area represents  and the right edge represents"," ","    . Note that segments  ","","abstract away from the stack symbols that are pushed and then popped again. Furthermore, in the context of the whole computation, segments abstract away from stack symbols that are not accessed during a subcomputation. As an example, the shaded area labelled III represents segment        , for certain stack symbols   , ","","and  , and this abstracts away from the stack symbols","that may occur below   and",".","Figure 4 illustrates how two adjacent segments are combined. The dashed box in the left-hand side of the picture represents stack symbols from the right edge of segment II that need not be explicitly represented by segment III, as discussed above. We may assume that these symbols exist, so that II and III can be combined into the larger computation in the right-hand side of the picture. Note that if a computation","","","","is obtained as the combination of two segments as in Figure 4, then some internal details of these segments are abstracted away, i.e., stack elements that were pushed and again popped in the combined computation are no longer recorded. This abstraction is a key feature of the parsing algorithm to be presented next, in that it considerably reduces the time complexity as compared with that of an algorithm that investigates all computations of the PDA in isolation.","We are now ready to present our parsing algorithm, which is the main result of this section. The algorithm combines the deduction system in Figure 2, as applied to the PDA encoding the input grammar","",", with the CKY algorithm as applied to the parsing grammar",". (We assume that","is in CNF.) The parsing algorithm may rule out many combinations of segments from Figure 2 that are inconsistent with the language generated by",". Also ruled out are structural compositions of segments that are inconsistent with the structure that","","as-signs to the corresponding substrings.","The parsing algorithm is again specified as a de-","duction system, presented in Figure 5. The algo-","rithm manipulates items of the form","",", where","","is a nonterminal of","","and",",","are stacks of the","PDA encoding . Such an item indicates that there stack hight time I II III IV Figure 3: A computation of a PDA divided into segments. II III combined into: II + III Figure 4: Combining two segments using rule (6) from Figure 2.     ","     ","          (8) ","  ","","  ","","(9)  ","  ","","  ","","(10)","Figure 5: Inference rules that simultaneously derive","strings generated by","and accepted by the PDA","encoding","",".","is some terminal string","that is derivable from","in  , and such that   ","   . If the item   "," ","","can be derived by the algorithm,","then the intersection of the language generated by"," and the language accepted by the PDA (gener-","ated by",") is non-empty."]},{"title":"4 Earley’s algorithm","paragraphs":["The CKY algorithm from Figure 5 can be seen to filterout a selection of the computations that may be derived by the deduction system from Figure 2. One may however be even more selective in determining which computations of the PDA to consider. The basis for the algorithm in this section is Earley’s algorithm (Earley, 1970). This algorithm differs from the CKY algorithm in that it satisfiesthe correct-prefix property (Harrison, 1978).","The new algorithm is presented by Figure 6.","There are now two types of item involved. The first","item has the form","","",",","where","","has the same role as the dot-","ted rules in Earley’s original algorithm. The sec-","ond and third components are stacks of the PDA","as before, but these stacks now contain a distin-","guished position, indicated by",". The existence of","an item","","","implies that","    ","  ",", where","is now a string deriv-","able from . This is quite similar to the meaning we","assigned to the items of the CKY algorithm, but here","not all stack symbols in","and","are involved in","this computation: only the symbols in","and","are","now accessed, while all symbols in","remain unaf-","fected. The portion of the stack represented by","is","needed to ensure the correct-prefixproperty in sub-","sequent computations following from this item, in","case all of the symbols in","are popped. The correct-prefixproperty is ensured in the following sense. The existence of an item"," ","implies that (i) there is a string"," that is both a prefixof a string accepted by the PDA and of a string generated by the CFG such that after     "," ","(11)  ","","  "," "," "," (12)  ","","  "," "," "," (13)    ","   "," (14)          "," ","(15)  ","  ","","","","(16)  ","  ","","","","(17)           (18)               (19)                (20)","","",""," ","      ","  ","","",""," ","   (21) Figure 6: Inference rules based on Earley’s algorithm.","processing",",","is expanded in a left-most deriva-","tion and some stack can be obtained of which","represent the top-most elements, and (ii)","is rewrit-","ten to and while processing","the PDA replaces the stack elements","by",".3","The second type of item has the form"," ",". The first three components are the same as before, and","indicates that we wish to know whether a stack with top-most symbols ","may arise after reading a prefixof a string that may also lead to expansion of nonterminal","in a left-most derivation. Such an item results if it is detected that the existence of","below","needs to be ensured in order to continue the computation under the constraint of the correct-prefixproperty.","Our algorithm also makes use of segments, as computed by the algorithm from Figure 1. Consistently with rule (5) from Figure 2, we write ","     to represent a segment","     such that   ","",". The use of segments that were computed bottom-up is a departure from pure left-to-right processing in the spirit of Earley’s original algorithm. The motivation is that we have found empirically that the use of rule (2) was essential for avoiding a large part of the exponential behaviour; note that that rule considers at most a number of stacks that is quadratic in the size of the PDA.","The firstinference rule (11) can be easily justified: we want to investigate strings that are both generated by the grammar and recognized by the PDA, so we begin by combining the start symbol and a matching right-hand side from the grammar with the initial stack for the PDA.","Segments are incorporated into the left-to-right computation by rules (12) and (13). These two rules are the equivalents of (9) and (10) from Figure 5. Note that in the case of (13) we require the presence of","below the marker in the antecedent. This indicates that a stack with top-most symbols","and a dotted rule","can be obtained by simultaneously processing a string from left to right by the grammar and the PDA. Thereby, we may continue the derivation with the item in the consequent without violating the correct-prefixproperty.","Rule (14) states that if a segment presupposes the existence of stack elements that are not yet available, we produce an item that starts a backward computation. We do this one symbol at a time, starting with","3","We naturally assume that the PDA itself satisfies the correct-prefixproperty, which is guaranteed by the construction from Section 3 and the fact that","","is reduced. the symbol","just beneath the part of the stack that is already available. This will be discussed more carefully below.","The predictor step of Earley’s algorithm is represented by (15), and the completer step by rules (16) and (17). These latter two are very similar to (12) and (13) in that they incorporate a smaller derivation in a larger derivation.","Rules (18) and (19) repeat computations that have been done before, but in a backward manner, in order to propagate the information that deeper stack symbols are needed than those currently available, in particular that we want to know whether a certain stack symbol","may occur below the currently avail-able parts of the stack. In (18) this query is passed on to the beginning of the context-free rule, and in (19) this query is passed on backwards through a predictor step. In the antecedent of rule (18) the position of the marker is irrelevant, and is not indicated explicitly. Similarly, for rule (19) we assume the position of the marker is copied unaltered from the first antecedent to the consequent.","If we findthe required stack symbol",", we propagate the information forward that this symbol may indeed occur at the specified position in the stack. This is implemented by rules (20) and (21). Rule (20) corresponds to the predictor step (15), but (20) passes on a larger portion of the stack than (20). Rule (15) only transfers the top-most symbol ","to the consequent, in order to keep the stacks as shallow as possible and to achieve a high degree of shar-ing of computation."]},{"title":"5 Empirical results","paragraphs":["We have implemented the two algorithms and tested them on non-recursive input CFGs and a parsing CFG. We have had access to six input CFGs of the form described by Langkilde (2000). As parsing CFG we have taken a small hand-written grammar of about 100 rules. While this small size is not at all typical of practical grammars, it sufficesto demonstrate the applicability of our algorithms.","The results of the experiments are reported in Figure 1. We have ordered the input grammars by size, according to the number of nonterminals (or the number of nodes in the forest, following the ter-minology by Langkilde (2000)).","The second column presents the number of strings generated by the input CFG, or more accurately, the number of derivations, as the grammars contain some ambiguity. The high numbers show that without a doubt the naive solution of processing the input grammars by enumerating individual strings (derivations) is not a viable option.","The third column shows the size, expressed as number of states, of a lattice (acyclic finite automaton) that would result by unfolding the grammar (Knight and Langkilde, 2000). Although this approach could be of more practical interest than the naive approach of enumerating all strings, it still leads to large intermediate results. In fact, practical context-free parsing algorithms for finite automata have cubic time complexity in the number of states, and derive a number of items that is quadratic in the number of states.","The next column presents the number of segments     . These apply to both algorithm. We only","compute segments  ","","for terminals","that also occur in the parsing grammar. (Further obvious optimizations in the case of Earley’s algorithm were found to lead to no more than a slight reduction of produced segments.) The last two columns present the number of items specific to the two algorithms in Figures 5 and 6, respectively. Although our two algorithms are exponential in the number of stack symbols in the worst case, just as approaches that enumerate all strings or that unfold","into a lattice, we see that the numbers of items are relatively moderate if we compare them to the number of strings generated by the input grammars.","Earley’s algorithm generally produces more items than the CKY algorithm. An exception is the last input CFG; it seems that the number of items that Earley’s algorithm needs to consider in order to maintain the correct-prefix property is very sensitive to qualities of the particular input CFG.","The present implementations use a trie to store stacks; the arcs in the trie closest to the root represent stack symbols closest to the top of the stacks. For example, for storing  ","",", the algorithm rep-","resents","and","by their corresponding nodes in the","trie, and it indexes  ","","twice, once through each associated node. Since the trie is doubly linked (i.e. we may traverse the trie upwards as well as downwards), we can always reconstruct the stacks Table 1: Empirical results.","# nonts # strings # states # segments # items CKY # items Earley","168 ","2643 1437 1252 6969","248 ","21984 3542 4430 40568","259","  ","6528 957 1314 29925","361"," "," 77198 7824 14627 14907","586  "," 45713 8832 5608 8611","869  "," 63851 15679 5709 3781 from the corresponding nodes. This structure is also convenient for findingpairs of matching stacks, one of which may be deeper than the other, as required by the inference rules from e.g. Figure 5, since given the firststack in such a pair, the second can be found by traversing the trie either upwards or downwards."]},{"title":"6 Discussion","paragraphs":["It is straightforward to give an algorithm for parsing a finitelanguage: we may trivially parse each string in the language in isolation. However, this is not a practical solution when the number of strings in the language exceeds all reasonable bounds.","Some algorithms have been described in the exist-ing literature that parse sets of strings of exponential size in the length of the input description. These so-lutions have not considered context-free parsing of finitelanguages encoded by non-recursive CFGs, in a way that takes full advantage of the compactness of the representation. Our algorithms make this possible, relying on the compactness of the input grammars for efficiency in practical cases, and on the absence of recursion for guaranteeing termination. Our experiments also show that these algorithms are of practical interest."]},{"title":"Acknowledgements","paragraphs":["We are indebted to Irene Langkilde for putting to our disposal the non-recursive CFGs on which we have based our empirical evaluation."]},{"title":"References","paragraphs":["Y. Bar-Hillel, M. Perles, and E. Shamir. 1964. On formal properties of simple phrase structure grammars. In Y. Bar-Hillel, editor, Language and Information: Selected Essays on their Theory and Application, chapter 9, pages 116–150. Addison-Wesley.","A. Corazza and A. Lavelli. 1994. An","-best representation for bidirectional parsing strategies. In Working Notes of the AAAI’94 Workshop on Integration of Natural Language and Speech Processing, pages 7–14, Seattle, WA.","J. Earley. 1970. An efficient context-free parsing algorithm. Communications of the ACM, 13(2):94–102, February.","M.A. Harrison. 1978. Introduction to Formal Language Theory. Addison-Wesley.","K. Knight and I. Langkilde. 2000. Preserving ambiguities in generation via automata intersection. In Proceedings of the Seventeenth National Conference on Artificial Intelligence and Twelfth Conference on In-novative Applications of ArtificialIntelligence, pages 697–702, Austin, Texas, USA, July–August.","I. Langkilde. 2000. Forest-based statistical sentence generation. In 6th Applied Natural Language Processing Conference and 1st Meeting of the North American Chapter of the Association for Computational Linguistics, pages Section 2, 170–177, Seattle, Washington, USA, April–May.","M.-J. Nederhof and G. Satta. 2002. The emptiness problem for intersection of a CFG and a nonrecursive CFG is PSPACE-complete. In preparation.","S.M. Shieber, Y. Schabes, and F.C.N. Pereira. 1995. Principles and implementation of deductive parsing. Journal of Logic Programming, 24:3–36."]}]}