{"sections":[{"title":"Comprehension and Compilation in Optimality Theory Jason Eisner Department of Computer Science Johns Hopkins University Baltimore, MD, USA 21218-2691 jason@cs.jhu.edu Abstract","paragraphs":["This paper ties up some loose ends in finite-state Optimality Theory. First, it discusses how to perform comprehension under Optimality Theory grammars consisting of finite-state constraints. Comprehension has not been much studied in OT; we show that unlike production, it does not always yield a regular set, making finite-state methods inapplicable. However, after giving a suitably flexible presentation of OT, we show carefully how to treat comprehension under recent variants of OT in which grammars can be compiled into finite-state transducers. We then unify these variants, showing that compilation is possible if all components of the grammar are regular relations, including the harmony ordering on scored candidates. A side benefit of our construction is a far simpler implementation of directional OT (Eisner, 2000)."]},{"title":"1 Introduction","paragraphs":["To produce language is to convert utterances from their underlying (“deep”) form to a surface form. Optimality Theory or OT (Prince and Smolensky, 1993) proposes to describe phonological production as an optimization process. For an underlying x, a speaker purportedly chooses the surface form z so as to maximize the harmony of the pair (x; z). Broadly speaking, (x; z) is harmonic if z is “easy” to pronounce and “similar” to x. But the precise harmony measure depends on the language; according to OT, it can be specified by a grammar of ranked desiderata known as constraints.","According to OT, then, production maps each underlying form to its best possible surface pronunciation. It is akin to the function that maps each child x to his or her most flattering outfit z. Different children look best in different clothes, and for an oddly shaped child x, even the best conceivable outfit z may be an awkward compromise between style and fit—that is, between ease of pronunciation and similarity to x.","Language comprehension is production in reverse. In OT, it maps each outfit z to the set of chil-","","Thanks to Kie Zuraw for asking about comprehension; to Ron Kaplan for demanding an algebraic construction before he believed directional OT was finite-state; and to others whose questions convinced me that this paper deserved to be written.","dren x for whom that outfit is optimal, i.e., is at least","as flattering as any other outfit z0",":","PRODUCE(x) = fz : (@z0",") (x; z0",") > (x; z)g COMPREHEND(z) = fx : z 2 PRODUCE(x)g","= fx : (@z0",") (x; z0",") > (x; z)g In general z and z0","may range over infinitely many possible pronunciations. While the formulas above are almost identical, comprehension is in a sense more complex because it varies both the underlying and surface forms. While PRODUCE(x) considers all pairs (x; z0","), COMPREHEND(z) must for each x consider all pairs (x; z0","). Of course, this nested def-inition does not preclude computational shortcuts.","This paper has three modest goals: 1. To show that OT comprehension does in fact present a computational problem that production does not. Even when the OT grammar is required to be finite-state, so that production can be performed with finite-state techniques, comprehension cannot in general be performed with finite-state techniques. 2. To consider recent constructions that cut through this problem (Frank and Satta, 1998; Karttunen, 1998; Eisner, 2000; Gerdemann and van Noord, 2000). By altering or approximating the OT formalism—that is, by hook or by crook—these constructions manage to compile OT grammars into finite-state transducers. Transducers may readily be inverted to do comprehension as easily as production. We carefully lay out how to use them for comprehension in realistic circumstances (in the presence of correspondence theory, lexical constraints, hearer uncertainty, and phonetic postprocessing). 3. To give a unified treatment in the extended finite-state calculus of the constructions referenced above. This clarifies their meaning and makes them easy to implement. For example, we obtain a transparent algebraic version of Eisner’s (2000) unbearably technical automaton construction for his proposed for-malism of “directional OT.” Computational Linguistics (ACL), Philadelphia, July 2002, pp. 56-63. Proceedings of the 40th Annual Meeting of the Association for The treatment shows that all the constructions emerge directly from a generalized presentation of OT, in which the crucial fact is that the harmony ordering on scored candidates is a regular relation."]},{"title":"2 Previous Work on Comprehension","paragraphs":["Work focusing on OT comprehension—or even mentioning it—has been surprisingly sparse. While the recent constructions mentioned in x1 can easily be applied to the comprehension problem, as we will explain, they were motivated primarily by a desire to pare back OT’s generative power to that of previous rewrite-rule formalisms (Johnson, 1972).","Fosler (1996) noted the existence of the OT comprehension task and speculated that it might succumb to heuristic search. Smolensky (1996) proposed to solve it by optimizing the underlying form, COMPREHEND(z)","?","= fx : (@x0",") (x0","; z) > (x; z)g Hale and Reiss (1998) pointed out in response that any comprehension-by-optimization strategy would have to arrange for multiple optima: after all, phonological comprehension is a one-to-many mapping (since phonological production is many-to-one).1","The correctness of Smolensky’s proposal (i.e., whether it really computes COMPREHEND) depends on the particular harmony measure. It can be made to work, multiple optima and all, if the harmony measure is constructed with both production and comprehension in mind. Indeed, for any phonology, it is trivial to design a harmony measure that both production and comprehension optimize. (Just define the harmony of (x; z) to be 1 or 0 according to whether the mapping x 7! z is in the language!) But we are really only interested in harmony measures that are defined by OT-style grammars (rankings of “simple” constraints). In this case Smolensky’s proposal can be unworkable. In particular, x4 will show that a finite-state production grammar in classical OT need not be invertible by any finite-state comprehension grammar.","1","Hale & Reiss’s criticism may be specific to phonology and syntax. For some phenomena in semantics, pragmatics, and even morphology, Blutner (1999) argues for a one-to-one form-meaning mapping in which marked forms express marked meanings. He deliberately uses bidirectional optimization to rule out many-to-one cases: roughly speaking, an (x; z) pair is grammatical for him only if z is optimal given x and vice-versa."]},{"title":"3 A General Presentation of OT","paragraphs":["This section (graphically summarized in Fig. 1) lays out a generalized version of OT’s theory of production, introducing some notational and representational conventions that may be useful to others and will be important below. In particular, all objects are represented as strings, or as functions that map strings to strings. This will enable us to use finite-state techniques later.","The underlying form x and surface form z are represented as strings. We often refer to these strings as input and output. Following Eisner (1997), each candidate (x; z) is also represented as a string y.","The notation (x; z) that we have been using so far for candidates is actually misleading, since in fact the candidates y that are compared encode more than just x and z. They also encode a particular alignment or correspondence between x and z. For example, if x = abdip and z = a[di][bu], then a typical candidate would be encoded","y = aab0[ddii][pb0u] which specifies that a corresponds to a, b was deleted (has no surface correspondent), voiceless p surfaces as voiced b, etc. The harmony of y might depend on this alignment as well as on x and z (just as an outfit might fit worse when worn backwards).","Because we are distinguishing underlying and surface material by using disjoint alphabets = fa; b; : : :g and = f[; ]; a; b; : : :g,2","it is easy to extract the underlying and surface forms (x and z) from y.","Although the above example assumes that x and z are simple strings of phonemes and brackets, nothing herein depends on that assumption. Autosegmental representations too can be encoded as strings (Eisner, 1997).","In general, an OT grammar consists of 4 components: a constraint ranking, a harmony ordering, and generating and pronouncing functions. The constraint ranking is the language-specific part of the grammar; the other components are often supposed to be universal across languages.","The generating function GEN maps any x 2 to the (nonempty) set of candidates y whose underlying form is x. In other words, GEN just inserts","2","An alternative would be to distinguish them by odd and even positions in the string.","x|{z} underlying form x2 GEN ! Y0(x) C1 ! Y1(x) C2 ! Y2(x) Cn","! Yn(x)","| {z }","sets of candidates y2( [) PRON ! Z(x)","| {z } set of surface forms z2 where Yi1(x)","Ci","! Yi(x) really means Yi1(x)","| {z }","y2( [)","Ci","! Yi(x) prune","! optimal subset of Yi(x) | {z }","y2( [ [f?g)","delete ? ! Yi(x)","| {z } y2( [) Figure 1: This paper’s view of OT production. In the second line, Ci inserts ?’s into candidates; then the candidates with suboptimal starrings are pruned away, and finally the ?’s are removed from the survivors. arbitrary substrings from","amongst the characters of x, subject to any restrictions on what constitutes a legitimate candidate y.3","(Legitimacy might for instance demand that y’s surface material z have matched, non-nested left and right brackets, or even that z be similar to x in terms of edit distance.)","A constraint ranking is simply a sequence C1; C2; : : : Cn of constraints. Let us take each Ci to be a function that scores candidates y by annotating them with violation marks ?. For example, a NODELETE constraint would map y = aab0c0[ddii][pb0u] to y =NODELETE(y) = aab?0c?0[ddii][pb0u], inserting a ? after each underlying phoneme that does not correspond to any surface phoneme. This unconventional formulation is needed for new approaches that care about the exact location of the ?’s. In traditional OT only the number of ?’s is important, although the locations are sometimes shown for readability.","Finally, OT requires a harmony ordering on scored candidates y 2 ( [ [ f?g)",". In traditional OT, y is most harmonic when it contains the fewest ?’s. For example, among candidates scored by NODELETE, the most harmonic ones are the ones with the fewest deletions; many candidates may tie for this honor. x6 considers other harmony orderings, a possibility recognized by Prince and Smolensky (1993) ( corresponds to their H-EVAL). In general may be a partial order: two competing candidates may be equally harmonic or incomparable (in which case both can survive), and candidates with different underlying forms never compete at all.","Production under such a grammar is a matter of successive filtering by the constraints C1; : : : Cn. Given an underlying form x, let Y0(x) = GEN(x) (1) 3","It is never really necessary for GEN to enforce such restric-","tions, since they can equally well be enforced by the top-ranked","constraint C1 (see below).","Yi(x) = fy 2 Yi1(x) : (2)","(@y0","2 Yi1(x)) Ci(y0",") Ci(y)g The set of optimal candidates is now Yn(x). Extracting z from each y 2 Yn(x) gives the set Z(x) or PRODUCE(x) of acceptable surface forms:","Z(x) = fPRON(y) : y 2 Yn(x)g (3) PRON denotes the simple pronunciation function that extracts z from y. It is the counterpart to GEN: just as GEN fleshes out x 2","into y by inserting symbols of , PRON slims y down to z 2","by removing symbols of .","Notice that Yn Yn1 : : : Y0. The only candidates y 2 Yi1 that survive filtering by Ci are the ones that Ci considers most harmonic.","The above notation is general enough to handle some of the important variations of OT, such as Paradigm Uniformity and Sympathy Theory. In particular, one can define GEN so that each candidate y encodes not just an alignment between x and z, but an alignment among x; z; and some other strings that are neither underlying nor surface. These other strings may represent the surface forms for other members of the same morphological paradigm, or intermediate throwaway candidates to which z is sympathetic. Production still optimizes y, which means that it simultaneously optimizes z and the other strings."]},{"title":"4 Comprehension in Finite-State OT","paragraphs":["This section assumes OT’s traditional harmony ordering, in which the candidates that survive filtering by Ci are the ones into which Ci inserts fewest ?’s.","Much computational work on OT has been conducted within a finite-state framework (Ellison, 1994), in keeping with a tradition of finite-state phonology (Johnson, 1972; Kaplan and Kay, 1994).4","4","The tradition already included (inviolable) phonological","Finite-state OT is a restriction of the formalism discussed above. It specifically assumes that GEN; C1; : : : Cn; and PRON are all regular relations, meaning that they can be described by finite-state transducers. GEN is a nondeterministic transducer that maps each x to multiple candidates y. The other transducers map each y to a single y or z.","These finite-state assumptions were proposed (in a different and slightly weaker form) by Ellison (1994). Their empirical adequacy has been defended by Eisner (1997).","In addition to having the right kind of power linguistically, regular relations are closed under various relevant operations and allow (efficient) parallel processing of regular sets of strings. Ellison (1994) exploited such properties to give a production algorithm for finite-state OT. Given x and a finite-state OT grammar, he used finite-state operations to construct the set Yn(x) of optimal candidates, represented as a finite-state automaton.","Ellison’s construction demonstrates that Yn is always a regular set. Since PRON is regular, it follows that PRODUCE(x) = Z(x) is also a regular set.","We now show that COMPREHEND(z), in constrast, need not be a regular set. Let = fa; bg, = f[; ]; a; b; : : :g and suppose that GEN allows candidates like the ones in x3, in which parts of the string may be bracketed between [ and ]. The crucial grammar consists of two finite-state constraints. C2 penalizes a’s that fall between brackets (by inserting ? next to each one) and also penalizes b’s that fall outside of brackets. It is dominated by C1, which penalizes brackets that do not fall at either edge of the string. Note that this grammar is completely permissive as to the number and location of surface characters other than brackets.","If x contains more a’s than b’s, then PRODUCE(x) is the set ̂","of all unbracketed surface forms, where ̂is minus the bracket symbols. If x contains fewer a’s than b’s, then PRODUCE(x) = [ ̂","]. And if a’s and b’s appear equally often in x, then PRODUCE(x) is the union of the two sets.","Thus, while the x-to-z mapping is not a regular relation under this grammar, at least PRODUCE(x) is a regular set for each x—just as finite-state OT constraints, notably Koskenniemi’s (1983) two-level model, which like OT used finite-state constraints on candidates y that encoded an alignment between underlying x and surface z. guarantees. But for any unbracketed z 2 ̂",", such as z = abc, COMPREHEND(z) is not regular: it is the set of underlying strings with # of a’s # of b’s.","This result seems to eliminate any hope of handling OT comprehension in a finite-state framework. It is interesting to note that both OT and current speech recognition systems construct finite-state models of production and define comprehension as the inverse of production. Speech recognizers do correctly implement comprehension via finite-state optimization (Pereira and Riley, 1997). But this is impossible in OT because OT has a more complicated production model. (In speech recognizers, the most probable phonetic or phonological surface form is not presumed to have suppressed its competitors.)","One might try to salvage the situation by barring constraints like C1 or C2 from the theory as linguistically implausible. Unfortunately this is unlikely to succeed. Primitive OT (Eisner, 1997) already restricts OT to something like a bare minimum of constraints, allowing just two simple constraint families that are widely used by practitioners of OT. Yet even these primitive constraints retain enough power to simulate any finite-state constraint. In any case, C1 and C2 themselves are fairly similar to “domain” constraints used to describe tone systems (Cole and Kisseberth, 1994). While C2 is somewhat odd in that it penalizes two distinct configurations at once, one would obtain the same effect by combining three separately plausible constraints: C2 requires a’s between brackets (i.e., in a tone domain) to receive surface high tones, C3 requires b’s outside brackets to receive surface high tones, and C4 penalizes all surface high tones.5","Another obvious if unsatisfying hack would impose heuristic limits on the length of x, for example by allowing the comprehension system to return the approximation COMPREHEND(z) \\ fx : jxj 2 jzjg. This set is finite and hence regular, so per-","5","Since the surface tones indicate the total number of a’s and b’s in the underlying form, COMPREHEND(z) is actually a finite set in this version, hence regular. But the non-regularity argument does go through if the tonal information in z is not available to the comprehension system (as when reading text without diacritics); we cover this case in x5. (One can assume that some lower-ranked constraints require a special suffix before ], so that the bracket information need not be directly available to the comprehension system either.) haps it can be produced by some finite-state method, although the automaton to describe the set might be large in some cases.","Recent efforts to force OT into a fully finite-state mold are more promising. As we will see, they identify the problem as the harmony ordering , rather than the space of constraints or the potential infinitude of the answer set."]},{"title":"5 Regular-Relation Comprehension","paragraphs":["Since COMPREHEND(z) need not be a regular set in traditional OT, a corollary is that COMPREHEND and its inverse PRODUCE are not regular relations. That much was previously shown by Markus Hiller and Paul Smolensky (Frank and Satta, 1998), using similar examples.","However, at least some OT grammars ought to describe regular relations. It has long been hypothesized that all human phonologies are regular relations, at least if one omits reduplication, and this is necessarily true of phonologies that were success-fully described with pre-OT formalisms (Johnson, 1972; Koskenniemi, 1983).","Regular relations are important for us because they are computationally tractable. Any regular relation can be implemented as a finite-state transducer T , which can be inverted and used for comprehension as well as production. PRODUCE(x) = T (x) = range(x T ), and COMPREHEND(z) = T 1","(z) = domain(T z).","We are therefore interested in compiling OT grammars into finite-state transducers—by hook or by crook. x6 discusses how; but first let us see how such compilation is useful in realistic situations.","Any practical comprehension strategy must recognize that the hearer does not really perceive the entire surface form. After all, the surface form contains phonetically invisible material (e.g., syllable and foot boundaries) and makes phonetically imperceptible distinctions (e.g., two copies of a tone versus one doubly linked copy). How to comprehend in this case?","The solution is to modify PRON to “go all the way”—to delete not only underlying material but also phonetically invisible material. Indeed, PRON can also be made to perform any purely phonetic processing. Each output z of PRODUCE is now not a phonological surface form but a string of phonemes or spectrogram segments. So long as PRON is a regular relation (perhaps a nondeterministic or probabilistic one that takes phonetic variation into ac-count), we will still be able to construct T and use it for production and comprehension as above.6","How about the lexicon? When the phonology can be represented as a transducer, COMPREHEND(z) is a regular set. It contains all inputs x that could have produced output z. In practice, many of these inputs are not in the lexicon, nor are they possible novel words. One should restrict to inputs that appear in the lexicon (also a regular set) by intersecting COMPREHEND(z) with the lexicon. For novel words this intersection will be empty; but one can find the possible underlying forms of the novel word, for learning’s sake, by intersecting COMPREHEND(z) with a larger (infinite) regular set representing all forms satisfying the language’s lexical constraints.","There is an alternative treatment of the lexicon. GEN can be extended “backwards” to incorporate morphology just as PRON was extended “forwards” to incorporate phonetics. On this view, the input x is a sequence of abstract morphemes, and GEN performs morphological preprocessing to turn x into possible candidates y. GEN looks up each abstract morpheme’s phonological string 2","from the lexicon,7","then combines these phonological strings by concatenation or template merger, then nondeterministically inserts surface material from",". Such a GEN can plausibly be built up (by composition) as a regular relation from abstract morpheme sequences to phonological candidates. This regularity, as for PRON, is all that is required.","Representing a phonology as a transducer T has additional virtues. T can be applied efficiently to any input string x, whereas Ellison (1994) or Eisner (1997) requires a fresh automaton construction for each x. A nice trick is to build T without","6","Pereira and Riley (1997) build a speech recognizer by composing a probabilistic finite-state language model, a finite-state pronouncing dictionary, and a probabilistic finite-state acoustic model. These three components correspond precisely to the input to GEN, the traditional OT grammar, and PRON, so we are simply suggesting the same thing in different terminology.","7","Nondeterministically in the case of phonologically conditioned allomorphs: INDEFINITE APPLE 7! fæpl, ænæplg ",". This yields competing candidates that differ even in their underlying phonological material. PRON and apply it to all conceivable x’s in parallel, yielding the complete set of all optimal candidates Yn(",") = S","x2 Yn(x). If Y and Y 0","denote the sets of optimal candidates under two grammars, then (Y \\ :Y 0",") [ (Y 0","\\ :Y ) yields the candidates that are optimal under only one grammar. Applying GEN1","or PRON to this set finds the regular set of underlying or surface forms that the two grammars would treat differently; one can then look for empirical cases in this set, in order to distinguish between the two grammars."]},{"title":"6 Theorem on Compiling OT","paragraphs":["Why are OT phonologies not always regular relations? The trouble is that inputs may be arbitrarily long, and so may accrue arbitrarily large numbers of violations. Traditional OT (x4) is supposed to distinguish all such numbers. Consider syllabification in English, which prefers to syllabify the long input bi bambam : : : bam","| {z }","k copies as [bi][bam][bam] : : : [bam] (with k codas) rather than [bib][am][bam] : : : [bam] (with k + 1 codas). NOCODA must therefore distinguish annotated candidates y with k ?’s (which are optimal) from those with k + 1 ?’s (which are not). It requires a ( k + 2)-state automaton to make this distinction by looking only at the ?’s in y. And if k can be arbitrarily large, then no finite-state automaton will handle all cases.","Thus, constraints like NOCODA do not allow an upper bound on k for all x 2",". Of course, the minimal number of violations k of a constraint is fixed given the underlying form x, which is useful in production.8","But comprehension is less fortunate: we cannot bound k given only the surface form z. In the grammar of x4, COMPREHEND(abc) included underlying forms whose optimal candidates had arbitrarily large numbers of violations k.","Now, in most cases, the effect of an OT grammar can be achieved without actually counting any-thing. (This is to be expected since rewrite-rule","8","Ellison (1994) was able to construct PRODUCE(x) from x. One can even build a transducer for PRODUCE that is correct on all inputs that can achieve K violations and returns ; on other inputs (signalling that the transducer needs to be recompiled with increased K). Simply use the construction of (Frank and Satta, 1998; Karttunen, 1998), composed with a hard constraint that the answer must have K violations. grammars were previously written for the same phonologies, and they did not use counting!) This is possible despite the above arguments because for some grammars, the distinction between optimal and suboptimal y can be made by looking at the non-? symbols in y rather than trying to count the ?’s. In our NOCODA example, a surface sub-string such as . . . ib?][a. . . might signal that y is suboptimal because it contains an “unnecessary” coda. Of course, the validity of this conclusion depends on the grammar and specifically the constraints C1; : : : Ci1 ranked above NOCODA, since whether that coda is really unnecessary depends on whether Yi1 also contains the competing candidate : : : i][ba : : : with fewer codas.","But as we have seen, some OT grammars do have effects that overstep the finite-state boundary (x4). Recent efforts to treat OT with transducers have therefore tried to remove counting from the formalism. We now unify such efforts by showing that they all modify the harmony ordering .","x4 described finite-state OT grammars as ones where GEN, PRON, and the constraints are regular relations. We claim that if the harmony ordering is also a regular relation on strings of ( [ [f?g)",", then the entire grammar (PRODUCE) is also regular.","We require harmony orderings to be compatible with GEN: an ordering must treat y0","; y as incomparable (neither is the other) if they were produced from different underlying forms.9","To make the notation readable let us denote the relation by the letter H. Thus, a transducer for H accepts the pair (y0","; y) if y0","y.","The construction is inductive. Y0 = GEN is regular by assumption. If Yi1 is regular, then so is Yi since (as we will show) Yi = ( Yi :range( Yi H)) D (4) where Yi def","= Yi1 Ci and maps x to the set of starred candidates that Ci will prune; : denotes the complement of a regular language; and D is a transducer that removes all ?’s. Therefore PRODUCE = Yn PRON is regular as claimed.","9","For example, the harmony ordering of traditional OT is f(y0","; y) : y0","has the same underlying form as, but contains fewer ?’s than, yg. If we were allowed to drop the same-underlying-form condition then the ordering would become regular, and then our claim would falsely imply that all traditional finite-state OT grammars were regular relations.","It remains to derive (4). Equation (2) implies","Ci(Yi(x)) = fy 2 Yi(x) : (@y0","2 Yi(x)) y0","yg (5)","= Yi(x) fy : (9y0","2 Yi(x)) y0","yg (6)","= Yi(x) H( Yi(x)) (7)","One can read H( Yi(x)) as “starred candidates that","are worse than other starred candidates,” i.e., subop-","timal. The set difference (7) leaves only the optimal","candidates. We now see","(x; y) 2 Yi Ci , y 2 Ci(Yi(x)) (8) , y 2 Yi(x); y 62 H( Yi(x)) [by (7)] (9) , y 2 Yi(x); (@z)y 2 H( Yi(z)) [see below](10) , (x; y) 2 Yi; y 62 range( Yi H) (11) , (x; y) 2 Yi :range( Yi H) (12)","therefore Yi Ci = Yi :range( Yi H) (13) and composing both sides with D yields (4). To justify (9) , (10) we must show when y 2 Yi(x) that y 2 H( Yi(x)) , (9z)y 2 H( Yi(z)). For the ) direction, just take z = x. For (, y 2 H( Yi(z)) means that (9y0","2 Yi(z))y0","y; but then x = z (giving y 2 H( Yi(x))), since if not, our compatibility requirement on H would have made y0","2 Yi(z) incomparable with y 2 Yi(x).","Extending the pretty notation of (Karttunen, 1998), we may use (4) to define a left-associative generalized optimality operator ooH : Y ooH C def = (Y C :range(Y C H))D (14) Then for any regular OT grammar, PRODUCE = GEN ooH C1 ooH C2 ooH Cn PRON and can be inverted to get COMPREHEND. More generally, different constraints can usefully be applied with different H’s (Eisner, 2000).","The algebraic construction above is inspired by a version that Gerdemann and van Noord (2000) give for a particular variant of OT. Their regular expressions can be used to implement it, simply replacing their add_violation by our H.","Typically, H ignores surface characters when comparing starred candidates. So H can be written as elim() G elim() 1","where elim() is a transducer that removes all characters of . To satisfy the compatibility requirement on H, G should be a subset of the relation ( j ? j( : ?)j(? : ))",".10","10","This transducer regexp says to map any symbol in [ f?g to itself, or insert or delete ?—and then repeat.","We now summarize the main proposals from the literature (see x1), propose operator names, and cast them in the general framework. Y o C: Inviolable constraint (Koskenniemi, 1983; Bird, 1995), implemented by composition. Y o+ C: Counting constraint (Prince and Smolensky, 1993): more violations is more disharmonic. No finite-state implementation possible. Y oo C: Binary approximation (Karttunen, 1998; Frank and Satta, 1998). All candidates with any violations are equally disharmonic. Implemented by G = (","( : ?)",")+",", which relates underlying forms without violations to the same forms with violations. Y oo3 C: 3-bounded approximation (Karttunen, 1998; Frank and Satta, 1998). Like o+ , but all candidates with 3 violations are equally disharmonic. G is most easily described with a transducer that keeps count of the input and output ?’s so far, on a scale of 0, 1, 2, 3. Final states are those whose output count exceeds their input count on this scale. Y o C: Matching or subset approximation (Gerdemann and van Noord, 2000). A candidate is more disharmonic than another if it has stars in all the same locations and some more besides.11","Here G = (( j?)","( : ?)( j?)",")+",". Y o> C: Left-to-right directional evaluation (Eisner, 2000). A candidate is more disharmonic than another if in the leftmost position where they differ (ignoring surface characters), it has a ?. This revises OT’s “do only when necessary” mantra to “do only when necessary and then as late as possible” (even if delaying ?’s means suffering more of them later). Here G = ( j?)","(( : ?)j(( : ?)( j?)",")). Unlike the other proposals, here two forms can both be optimal only if they have exactly the same pattern of violations with respect to their underlying material. Y <o C: Right-to-left directional evaluation. “Do only when necessary and then as early as possible.” Here G is the reverse of the G used in o> .","The novelty of the matching and directional proposals is their attention to where the violations fall. Eisner’s directional proposal (o>, <o) is the only","11","Many candidates are incomparable under this ordering, so Gerdemann and van Noord also showed how to weaken the notation of “same location” in order to approximate o+ better.","(a) x =bantodibo [ban][to][di][bo] [ban][ton][di][bo] [ban][to][dim][bon] [ban][ton][dim][bon]","(b) NOCODA ban?todibo ban?to?dibo ban?todi?bo? ban?to?di?bo?","(c) C1 NOCODA *! *","+ ** ***! ***!*","(d) C1 1 2 3 4 *! * * *!","+ * * * * *! * * Figure 2: Counting vs. directionality. [Adapted from (Eisner, 2000).] C1 is some high-ranked constraint that kills the most faithful candidate; NOCODA dislikes syllable codas. (a) Surface material of the candidates. (b) Scored candidates for G to compare. Surface characters but not ?’s have been removed by elim( ). (c) In traditional evaluation o+ , G counts the ?’s. (d) Directional evaluation o> gets a different result, as if NOCODA were split into 4 constraints evaluating the syllables separately. More accurately, it is as if NOCODA were split into one constraint per underlying letter, counting the number of ?’s right after that letter. one defended on linguistic as well as computational grounds. He argues that violation counting (o+) is a bug in OT rather than a feature worth approximating, since it predicts unattested phenomena such as “majority assimilation” (Baković, 1999; Lombardi, 1999). Conversely, he argues that comparing violations directionally is not a hack but a desirable feature, since it naturally predicts “iterative phenomena” whose description in traditional OT (via Generalized Alignment) is awkward from both a linguistic and a computational point of view. Fig. 2 contrasts the traditional and directional harmony orderings.","Eisner (2000) proved that o> was a regular operator for directional H, by making use of a rather different insight, but that machine-level construction was highly technical. The new algebraic construction is simple and can be implemented with a few regular expressions, as for any other H."]},{"title":"7 Conclusion","paragraphs":["See the itemized points in x1 for a detailed summary. In general, this paper has laid out a clear, general framework for finite-state OT systems, and used it to obtain positive and negative results about the under-studied problem of comprehension. Perhaps these results will have some bearing on the development of realistic learning algorithms.","The paper has also established sufficient conditions for a finite-state OT grammar to compile into a finite-state transducer. It should be easy to imagine new variants of OT that meet these conditions."]},{"title":"References","paragraphs":["Eric Baković. 1999. Assimilation to the unmarked. Rutgers Optimality Archive ROA-340., August. Steven Bird. 1995. Computational Phonology: A Constraint-Based Approach. Cambridge.","Reinhard Blutner. 1999. Some aspects of optimality in natural language interpretation. In Papers on Optimality Theoretic Semantics. Utrecht.","J. Cole and C. Kisseberth. 1994. An optimal domains theory of harmony. Studies in the Linguistic Sciences, 24(2).","Jason Eisner. 1997. Efficient generation in primitive Optimality Theory. In Proc. of ACL/EACL.","Jason Eisner. 2000. Directional constraint evaluation in Optimality Theory. In Proc. of COLING.","T. Mark Ellison. 1994. Phonological derivation in Optimality Theory. In Proc. of COLING","J. Eric Fosler. 1996. On reversing the generation process in Optimality Theory. Proc. of ACL Student Session.","R. Frank and G. Satta. 1998. Optimality Theory and the generative complexity of constraint violability. Computational Linguistics, 24(2):307–315.","D. Gerdemann and G. van Noord. 2000. Approxima-tion and exactness in finite-state Optimality Theory. In Proc. of ACL SIGPHON Workshop.","Mark Hale and Charles Reiss. 1998. Formal and empirical arguments concerning phonological acquisition. Linguistic Inquiry, 29:656–683.","C. Douglas Johnson. 1972. Formal Aspects of Phonological Description. Mouton.","R. Kaplan and M. Kay. 1994. Regular models of phonological rule systems. Comp. Ling., 20(3).","L. Karttunen. 1998. The proper treatment of optimality in computational phonology. In Proc. of FSMNLP.","Kimmo Koskenniemi. 1983. Two-level morphology: A general computational model for word-form recognition and production. Publication 11, Dept. of General Linguistics, University of Helsinki.","Linda Lombardi. 1999. Positional faithfulness and voicing assimilation in Optimality Theory. Natural Language and Linguistic Theory, 17:267–302.","Fernando C. N. Pereira and Michael Riley. 1997. Speech recognition by composition of weighted finite automata. In E. Roche and Y. Schabes, eds., Finite-State Language Processing. MIT Press.","A. Prince and P. Smolensky. 1993. Optimality Theory: Constraint interaction in generative grammar. Ms., Rutgers and U. of Colorado (Boulder).","Paul Smolensky. 1996. On the comprehension/production dilemma in child language. Linguistic Inquiry, 27:720–731."]}],"references":[{"authors":[{"first":"Eric","last":"Baković"}],"year":"1999","title":"Assimilation to the unmarked"},{"authors":[{"first":"Reinhard","last":"Blutner"}],"year":"1999","title":"Some aspects of optimality in natural language interpretation"},{"authors":[{"first":"J.","last":"Cole"},{"first":"C.","last":"Kisseberth"}],"year":"1994","title":"An optimal domains theory of harmony"},{"authors":[{"first":"Jason","last":"Eisner"}],"year":"1997","title":"Efficient generation in primitive Optimality Theory"},{"authors":[{"first":"Jason","last":"Eisner"}],"year":"2000","title":"Directional constraint evaluation in Optimality Theory"},{"authors":[{"first":"T.","middle":"Mark","last":"Ellison"}],"year":"1994","title":"Phonological derivation in Optimality Theory"},{"authors":[{"first":"J.","middle":"Eric","last":"Fosler"}],"year":"1996","title":"On reversing the generation process in Optimality Theory"},{"authors":[{"first":"R.","last":"Frank"},{"first":"G.","last":"Satta"}],"year":"1998","title":"Optimality Theory and the generative complexity of constraint violability"},{"authors":[{"first":"D.","last":"Gerdemann"},{"first":"G.","last":"van Noord"}],"year":"2000","title":"Approxima-tion and exactness in finite-state Optimality Theory"},{"authors":[{"first":"Mark","last":"Hale"},{"first":"Charles","last":"Reiss"}],"year":"1998","title":"Formal and empirical arguments concerning phonological acquisition"},{"authors":[{"first":"C.","middle":"Douglas","last":"Johnson"}],"year":"1972","title":"Formal Aspects of Phonological Description"},{"authors":[{"first":"R.","last":"Kaplan"},{"first":"M.","last":"Kay"}],"year":"1994","title":"Regular models of phonological rule systems"},{"authors":[{"first":"L.","last":"Karttunen"}],"year":"1998","title":"The proper treatment of optimality in computational phonology"},{"authors":[{"first":"Kimmo","last":"Koskenniemi"}],"year":"1983","title":"Two-level morphology: A general computational model for word-form recognition and production"},{"authors":[{"first":"Linda","last":"Lombardi"}],"year":"1999","title":"Positional faithfulness and voicing assimilation in Optimality Theory"},{"authors":[{"first":"Fernando","middle":"C. N.","last":"Pereira"},{"first":"Michael","last":"Riley"}],"year":"1997","title":"Speech recognition by composition of weighted finite automata"},{"authors":[{"first":"A.","last":"Prince"},{"first":"P.","last":"Smolensky"}],"year":"1993","title":"Optimality Theory: Constraint interaction in generative grammar"},{"authors":[{"first":"Paul","last":"Smolensky"}],"year":"1996","title":"On the comprehension/production dilemma in child language"}],"cites":[{"authors":[{"last":"Eisner"}],"year":"2000","style":0,"reference":{"authors":[{"first":"Jason","last":"Eisner"}],"year":"2000","title":"Directional constraint evaluation in Optimality Theory"}},{"authors":[{"last":"Prince"},{"last":"Smolensky"}],"year":"1993","style":0,"reference":{"authors":[{"first":"A.","last":"Prince"},{"first":"P.","last":"Smolensky"}],"year":"1993","title":"Optimality Theory: Constraint interaction in generative grammar"}},{"authors":[{"last":"Frank"},{"last":"Satta"}],"year":"1998","style":0,"reference":{"authors":[{"first":"R.","last":"Frank"},{"first":"G.","last":"Satta"}],"year":"1998","title":"Optimality Theory and the generative complexity of constraint violability"}},{"authors":[{"last":"Karttunen"}],"year":"1998","style":0,"reference":{"authors":[{"first":"L.","last":"Karttunen"}],"year":"1998","title":"The proper treatment of optimality in computational phonology"}},{"authors":[{"last":"Eisner"}],"year":"2000","style":0,"reference":{"authors":[{"first":"Jason","last":"Eisner"}],"year":"2000","title":"Directional constraint evaluation in Optimality Theory"}},{"authors":[{"last":"Noord"}],"year":"2000","style":0},{"authors":[{"last":"Eisner’s"}],"year":"2000","style":0},{"authors":[{"last":"Johnson"}],"year":"1972","style":0,"reference":{"authors":[{"first":"C.","middle":"Douglas","last":"Johnson"}],"year":"1972","title":"Formal Aspects of Phonological Description"}},{"authors":[{"last":"Fosler"}],"year":"1996","style":0,"reference":{"authors":[{"first":"J.","middle":"Eric","last":"Fosler"}],"year":"1996","title":"On reversing the generation process in Optimality Theory"}},{"authors":[{"last":"Smolensky"}],"year":"1996","style":0,"reference":{"authors":[{"first":"Paul","last":"Smolensky"}],"year":"1996","title":"On the comprehension/production dilemma in child language"}},{"authors":[{"last":"Hale"},{"last":"Reiss"}],"year":"1998","style":0,"reference":{"authors":[{"first":"Mark","last":"Hale"},{"first":"Charles","last":"Reiss"}],"year":"1998","title":"Formal and empirical arguments concerning phonological acquisition"}},{"authors":[{"last":"Blutner"}],"year":"1999","style":0,"reference":{"authors":[{"first":"Reinhard","last":"Blutner"}],"year":"1999","title":"Some aspects of optimality in natural language interpretation"}},{"authors":[{"last":"Eisner"}],"year":"1997","style":0,"reference":{"authors":[{"first":"Jason","last":"Eisner"}],"year":"1997","title":"Efficient generation in primitive Optimality Theory"}},{"authors":[{"last":"Eisner"}],"year":"1997","style":0,"reference":{"authors":[{"first":"Jason","last":"Eisner"}],"year":"1997","title":"Efficient generation in primitive Optimality Theory"}},{"authors":[{"last":"Prince"},{"last":"Smolensky"}],"year":"1993","style":0,"reference":{"authors":[{"first":"A.","last":"Prince"},{"first":"P.","last":"Smolensky"}],"year":"1993","title":"Optimality Theory: Constraint interaction in generative grammar"}},{"authors":[{"last":"Ellison"}],"year":"1994","style":0,"reference":{"authors":[{"first":"T.","middle":"Mark","last":"Ellison"}],"year":"1994","title":"Phonological derivation in Optimality Theory"}},{"authors":[{"last":"Johnson"}],"year":"1972","style":0,"reference":{"authors":[{"first":"C.","middle":"Douglas","last":"Johnson"}],"year":"1972","title":"Formal Aspects of Phonological Description"}},{"authors":[{"last":"Kaplan"},{"last":"Kay"}],"year":"1994","style":0,"reference":{"authors":[{"first":"R.","last":"Kaplan"},{"first":"M.","last":"Kay"}],"year":"1994","title":"Regular models of phonological rule systems"}},{"authors":[{"last":"Ellison"}],"year":"1994","style":0,"reference":{"authors":[{"first":"T.","middle":"Mark","last":"Ellison"}],"year":"1994","title":"Phonological derivation in Optimality Theory"}},{"authors":[{"last":"Eisner"}],"year":"1997","style":0,"reference":{"authors":[{"first":"Jason","last":"Eisner"}],"year":"1997","title":"Efficient generation in primitive Optimality Theory"}},{"authors":[{"last":"Ellison"}],"year":"1994","style":0,"reference":{"authors":[{"first":"T.","middle":"Mark","last":"Ellison"}],"year":"1994","title":"Phonological derivation in Optimality Theory"}},{"authors":[{"last":"Koskenniemi’s"}],"year":"1983","style":0},{"authors":[{"last":"Pereira"},{"last":"Riley"}],"year":"1997","style":0,"reference":{"authors":[{"first":"Fernando","middle":"C. N.","last":"Pereira"},{"first":"Michael","last":"Riley"}],"year":"1997","title":"Speech recognition by composition of weighted finite automata"}},{"authors":[{"last":"Eisner"}],"year":"1997","style":0,"reference":{"authors":[{"first":"Jason","last":"Eisner"}],"year":"1997","title":"Efficient generation in primitive Optimality Theory"}},{"authors":[{"last":"Cole"},{"last":"Kisseberth"}],"year":"1994","style":0,"reference":{"authors":[{"first":"J.","last":"Cole"},{"first":"C.","last":"Kisseberth"}],"year":"1994","title":"An optimal domains theory of harmony"}},{"authors":[{"last":"Frank"},{"last":"Satta"}],"year":"1998","style":0,"reference":{"authors":[{"first":"R.","last":"Frank"},{"first":"G.","last":"Satta"}],"year":"1998","title":"Optimality Theory and the generative complexity of constraint violability"}},{"authors":[{"last":"Johnson"}],"year":"1972","style":0,"reference":{"authors":[{"first":"C.","middle":"Douglas","last":"Johnson"}],"year":"1972","title":"Formal Aspects of Phonological Description"}},{"authors":[{"last":"Koskenniemi"}],"year":"1983","style":0,"reference":{"authors":[{"first":"Kimmo","last":"Koskenniemi"}],"year":"1983","title":"Two-level morphology: A general computational model for word-form recognition and production"}},{"authors":[{"last":"Ellison"}],"year":"1994","style":0,"reference":{"authors":[{"first":"T.","middle":"Mark","last":"Ellison"}],"year":"1994","title":"Phonological derivation in Optimality Theory"}},{"authors":[{"last":"Eisner"}],"year":"1997","style":0,"reference":{"authors":[{"first":"Jason","last":"Eisner"}],"year":"1997","title":"Efficient generation in primitive Optimality Theory"}},{"authors":[{"last":"Pereira"},{"last":"Riley"}],"year":"1997","style":0,"reference":{"authors":[{"first":"Fernando","middle":"C. N.","last":"Pereira"},{"first":"Michael","last":"Riley"}],"year":"1997","title":"Speech recognition by composition of weighted finite automata"}},{"authors":[{"last":"Ellison"}],"year":"1994","style":0,"reference":{"authors":[{"first":"T.","middle":"Mark","last":"Ellison"}],"year":"1994","title":"Phonological derivation in Optimality Theory"}},{"authors":[{"last":"Frank"},{"last":"Satta"}],"year":"1998","style":0,"reference":{"authors":[{"first":"R.","last":"Frank"},{"first":"G.","last":"Satta"}],"year":"1998","title":"Optimality Theory and the generative complexity of constraint violability"}},{"authors":[{"last":"Karttunen"}],"year":"1998","style":0,"reference":{"authors":[{"first":"L.","last":"Karttunen"}],"year":"1998","title":"The proper treatment of optimality in computational phonology"}},{"authors":[{"last":"Karttunen"}],"year":"1998","style":0,"reference":{"authors":[{"first":"L.","last":"Karttunen"}],"year":"1998","title":"The proper treatment of optimality in computational phonology"}},{"authors":[{"last":"Eisner"}],"year":"2000","style":0,"reference":{"authors":[{"first":"Jason","last":"Eisner"}],"year":"2000","title":"Directional constraint evaluation in Optimality Theory"}},{"authors":[{"last":"Noord"}],"year":"2000","style":0},{"authors":[{"last":"Koskenniemi"}],"year":"1983","style":0,"reference":{"authors":[{"first":"Kimmo","last":"Koskenniemi"}],"year":"1983","title":"Two-level morphology: A general computational model for word-form recognition and production"}},{"authors":[{"last":"Bird"}],"year":"1995","style":0},{"authors":[{"last":"Prince"},{"last":"Smolensky"}],"year":"1993","style":0,"reference":{"authors":[{"first":"A.","last":"Prince"},{"first":"P.","last":"Smolensky"}],"year":"1993","title":"Optimality Theory: Constraint interaction in generative grammar"}},{"authors":[{"last":"Karttunen"}],"year":"1998","style":0,"reference":{"authors":[{"first":"L.","last":"Karttunen"}],"year":"1998","title":"The proper treatment of optimality in computational phonology"}},{"authors":[{"last":"Frank"},{"last":"Satta"}],"year":"1998","style":0,"reference":{"authors":[{"first":"R.","last":"Frank"},{"first":"G.","last":"Satta"}],"year":"1998","title":"Optimality Theory and the generative complexity of constraint violability"}},{"authors":[{"last":"Karttunen"}],"year":"1998","style":0,"reference":{"authors":[{"first":"L.","last":"Karttunen"}],"year":"1998","title":"The proper treatment of optimality in computational phonology"}},{"authors":[{"last":"Frank"},{"last":"Satta"}],"year":"1998","style":0,"reference":{"authors":[{"first":"R.","last":"Frank"},{"first":"G.","last":"Satta"}],"year":"1998","title":"Optimality Theory and the generative complexity of constraint violability"}},{"authors":[{"last":"Noord"}],"year":"2000","style":0},{"authors":[{"last":"Eisner"}],"year":"2000","style":0,"reference":{"authors":[{"first":"Jason","last":"Eisner"}],"year":"2000","title":"Directional constraint evaluation in Optimality Theory"}},{"authors":[{"last":"Eisner"}],"year":"2000","style":0,"reference":{"authors":[{"first":"Jason","last":"Eisner"}],"year":"2000","title":"Directional constraint evaluation in Optimality Theory"}},{"authors":[{"last":"Baković"}],"year":"1999","style":0,"reference":{"authors":[{"first":"Eric","last":"Baković"}],"year":"1999","title":"Assimilation to the unmarked"}},{"authors":[{"last":"Lombardi"}],"year":"1999","style":0,"reference":{"authors":[{"first":"Linda","last":"Lombardi"}],"year":"1999","title":"Positional faithfulness and voicing assimilation in Optimality Theory"}},{"authors":[{"last":"Eisner"}],"year":"2000","style":0,"reference":{"authors":[{"first":"Jason","last":"Eisner"}],"year":"2000","title":"Directional constraint evaluation in Optimality Theory"}}]}
