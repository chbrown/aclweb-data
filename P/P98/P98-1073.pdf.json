{"sections":[{"title":"Vers l'utilisation des m thodes formelles pour le d veloppement de linguiciels","paragraphs":["Bilel Gargouri, Mohamed Jmaiel, Abdelmajid Ben Hamadou","Laboratoire LARIS FSEG-SFAX, B.P. 1088 3018 SFAX, TUNISIA E-mail: {Abdelmajid.Benhamadou@fsegs.rnu.tn} Abstract Formal methods have'nt been applied enough in the development process of lingware although their advantages have been proved in many other domains. In this framework, we have investigated some applications dealing with different processing levels (lexical analyses, morphology, syntax, semantic and pragmatic). These investigations has mainly led to the following observations. First of all, we have noticed a lack of use of methodologies that cover all the life cycle of a software development. The formal specification has not been used in the first development phases. In addition, we have noticed the lack of formal validation and consequently the insufficient guarantee of the developed software results. Moreover, there has been no appeal to rigorous methods of integration to solve the dichotomy of data and processing problem. However, the use of the formal aspect in the Natural Language Processing (NLP) has generally been limited to describing the natural language knowledge (i.e., grammars) and specifying the treatments using algorithmic languages. Few are those who have used a high level specification language. This paper focuses on the contributions of formal methods in developing natural language software starting from an experimentation carried out on a real application and which consists in specifying and validating the system CORTEXA (Correction ORthographique des TEXtes Arabes) using the VDM formal method. First of all, we review the advantages of formal methods in the general software development process. Then, we present the experimentation and the obtained results. After that, we place the formal methods advantages in the context of NLP. Finally, we give some methodological criteria that allow the choice of an appropriate formal method. 438 Rdsumd : Les mkthodes formelles n'ont pas ktd surfisamment utiliskes dans le processus de ddveloppement des linguiciels, alors qu'elles ont fait leurs preuves dans d'autres domaines. Le prdsent article essaye de mettre en relief les avantages des mkthodes formelles dans le contexte des langues naturelles, partant des rksultats d'une expkrience rkaliske sur une application rkelle. Dans un premier temps, nous rappellons les avantages globaux des mkthodes formelles dans le processus de dkveloppement d'un logiciel. Ensuite, nous pla§ons ces avantages dans le contexte des langues naturelles. Enfin, nous donnons les crithres mkthodologiques pour le choix d'une mkthode formelle approprike. 1 Introduction L'automatisation des langues naturelles a bdnkficik jusqu'k nos jours de nombreuses anndes de recherches et continue encore faire l'objet de plusieurs travaux, notamment dans le domaine du gknie linguistique pour le dkveloppement d'applications spkcifiques. L'ktude des approches de dkveloppement des applications likes au Traitement Automatique des Langues Naturelles (TALN), k tous ses niveaux (i.e., lexical, morphologique, syntaxique, skmantique et pragmatique), (Fuchs, 1993; Sabah, 1989) nous a permis de constater une quasi-absence de l'utilisation de mdthodologies de dkveloppement qui inthgrent toutes les phases du cycle de vie d'un logiciel. En par-ticulier, au niveau des premihres dtapes, nous avons constatk l'absence quasi-totale de la phase de spkcification formelle. D'un autre c5t4, nous avons constatd une difficultk, voire absence de validation formelle des approches utilisdes dans le dkveloppement et par consdquent de garantie sur les performances des rksultats obtenus. De m~me, nous avons remarqu6 le non recours £ des mdthodes rigoureuses d'intkgration pour rksoudre le problhme de la dichotomie donn6es-traitements. L'utilisation des outils formels s'est limitke, dans la plupart des cas, k la description du langage (i.e., les grammaires) et k la spdcification des traitements r~duite, g@nkralement, k l'usage d'un langage algorithmique. Rares sont ceux qui ont utilisk un langage de spkcification formelle de haut niveau (Zajac, 1986; Jensen et al., 1993). Aprhs une prksentation des avantages qu'offrent les mkthodes formelles dans le processus de dkveloppement d'un logiciel, d'une manihre gknkrale, cet article essaye de mettre en relief les avantages specifiques au domaine de TALN partant d'une expkrience mende au sein de notre kquipe en utilisant la mkthode VDM (Dawes, 1991; Jones, 1986). I1 donne, ~ la fin, des crithres permettant le choix d'une mkthode formelle approprike. 2 Rappel des principaux avantages des mdthodes formelles L'int@gration des mkthodes formelles dans le processus de dkveloppement de certaines applications critiques comme les systhmes temps rdel et les systhmes distribu'ks a donnk ses preuves ces dernihres annkes (Barroca and Dermid, 1992; Dick and Woods, 1997; Ledru, 1993). C'est ce qui a motivk leur utilisation dans le ddveloppement de logiciels traitant des problhmes complexes au niveau industriel (Hui et al., 1997). Une mkthode formelle est considkrke comme une ddmarche de dkveloppement de logiciels baske sur des notations mathdmatiques et des preuves de validation formelles (Habrias, 1995). Cette dkmarche utilise un processus de raiTine-ment qui part d'une spkcification abstraite des besoins pour dkboucher sur une spkcification raffinke et exkcutable (ou directement codable en un langage de programmation). Les principaux avantages des mkthodes formelles peuvent ~tre rksumks dans les points suivants : La prdcision et la non ambiguitd : l'utilisation d'un langage bask sur des notations formelles et prkcises permet d'kviter toute ambiguitk et toute redondance dans la spkcification. La ddteetion d'erreurs conceptueUes le plus tSt possible : l'application de preuves de validation de la spkcification tout le long du processus de raffinement de cette dernihre, garanti la ddtection des erreurs de conception le plus tSt possible dans le processus de dkveloppement de l'application. En l'absence d'une telle validation, les erreurs de conception ne seront 439 d~tect4es qu'aprhs la phase d'impl4mentation ce qui engendrera un c6ut suppl~mentaire. La satisfaction de la conception (dventuellement de l'impldmentation ) par rapport aux besoins : elle est garantie gr£ce au processus de raffinement qui part d'une sp4cification des besoins et applique des rhgles coh~rentes de transformation pour aboutir ~ la conception finale. Le contrble de la cohdrence donndes-traitements : qui est directement pris en charge gr£ce aux preuves de validation. La rdutilisation : le raffinement des specifications formelles et leurs d~compositions successives permettent de mettre en ~vidence des niveaux d'abstraction int~ressants pour la r~solution du probl~me et pour promouvoir la r~utilisation (des sp4cifications). 3 Presentation","et r~sultats de l'exp~rimentation 3.1 Choix et d~marche utilis4e Pour mesurer l'impact de l'utilisation des m~thodes formelles dans le contexte du TALN, nous avons effectu~ la specification complhte et valid~e du systhme CORTEXA (Correction ORthographique des TEXtes Arabes) (Ben-Hamadou, 1993) d~velopp~ au sein de notre laboratoire. Outre la disponibilit~ de la documentation, en mati~re de conception et d'impl~mentation, le choix du syst~me CORTEXA est aussi motiv~ par la diversit~ des approches utilis~es pour la representation des connaissances et des traitements. En effet, il se compose :","• d'un module de d~tection des erreurs bas~ sur une analyse affixale qui utilise un systhme ~ 4tats finis (les r~seaux de transitions augment~es : ATN). L'analyse affixale effectue la d~composition d'un mot en ses composants premiers : pr~fixe, infixe, suffixe et racine en se r~f~rant £ un ensemble de lexiques et de structures de donn~es,","• d'un module de correction des erreurs orthographiques qui utilise un systhme ~ base de rhgles et • d'un autre module de correction des erreurs typographiques qui se base sur un systbme mixte. Le choix de VDM pour la specification de CORTEXA est motive, d'une part, par le fait que cette m~thode se base sur les pr~dicats qui donnent un haut pouvoir expressif, et d'autre part, pour sa notation simple et riche. Aussi, VDM a fait ses preuves dans le d~veloppement de plusieurs systhmes d'information. Contraire-ment aux environnements de specification des donn~es linguistiques tels que D-PATR (Karttunen, 1986), EAGLES (Erbach et al., 1996), etc, VDM permet de specifier £ la fois des traitements et des donn~es (dans notre contexte des donn~es linguistiques) et offre une m~thodologie de d~veloppement d'applications se basant sur des raffinements et des transformations valid~es. Partant de la description informelle des besoins, nous avons d6velopp~ la spficification abstraite du systbme CORTEXA (appelfie aussi spgcification implicite) qui englobe, entre autres, la spficification formelle de ses fonctions, de ses actions et de ses rbgles de correction. Cette sp~cification a fit6, ensuite, validfie en utilisant des preuves formelles. Enfin, nous avons g~n~ralis~ la sp~cification de conception (appel~e aussi spficification explicite ou directe)","partir de la sp~cification abstraite moyennant des rbgles relatives £ la m6thode VDM. Cette sp4cification de conception est facilemerit transform6e en code pour rfialiser la phase d'implfimentation. 3.2 R~sultats obtenus L'utilisation de la m~thode formelle VDM pour la sp6cification complbte et valid~e du systbme CORTEXA a conduit, entre autres, aux constats suivants : InsuJfisance en r~gles : l'utilisation des preuves formelles nous a permis de mettre en relief, par rapport ~ [a specification initiale, certaines situations non prises en compte. En particulier, les preuves qui permettent de s'assurer que pour chaque type d'erreur dolt exister au moins une rhgle de correction nous ont permis de constater que l'ensemble des rbgles de correction, initiale-ment propos~, ne permet pas de prendre en charge toute la typologie d'erreurs. Exemple 1: preuve relative £ l'erreur de sup-440 pression Exemple 3: (Vw' ¢~ CH, Vw ~ Lex).(Del(w, w')A w' ¢_ Lex) ~, (3R e Reg).w ~ R(w') oh Lex : le lexique de r4f~rence CH : l'ensemble des s~quences de chaines de caracthres Reg : l'ensemble des rhgles de correction R(w) : l'application de la rhgle R sur la chaine w. On repr~sente une rhgle en VDM par une fonction Del 0 : un pr~dicat qui v~rifie l'erreur de suppression de caract~re. La prdcision et la concision de la spdcification : en comparant la specification informelle du systhme CORTEXA, pr~sent~e dans la documentation, avec la specification formelle d~velopp~e, nous remarquons que eette dernihre est plus precise et plus concise. L'exemple 2, donn~ ci-aprhs, qui pr~sente la specification formelle de la fonction de g~n~ration des d~compositions affixales possibles d'un mot w, illustre ce constat. Exemple 2: lsdecomp(w, p, i, s, root : CH)r : B pre True post 3a, bE CH (w=p.a.i.b.sA","root = a * b) A (Sprefixe(w, p) A","Ssuf fix(w, s)/X Sin fixe(w, i) ) oh B : le type bool~en Sinfixe 0 ( respectivement Sprefixe 0 et Ssu]fixeO) : un pr~dicat qui v~rifie la","propri~t~ d'un infixe (respectivementd'un","pr~fixe et d'un suffixe) pour une chaine. Facilitd du ddveloppement du code : la specification de conception obtenue est suffisam-ment explicite pour les donn~es et algorithmique pour les traitements. Elle est donc facile-ment codable en un langage de programmation. L'exemple 3, illustre l'usage d'une notation algorithmique dans la sp6cification des fonctions. Il pr~sente la fonction S-Radical de v~rification de la propri~t~ d'un radical (form6 par la racine et l'infixe). Sradical : CH x CH > B","Sradieal(sl,s2) -=De] if s, -= [] then False else if Sprefixe(sl, s2)","then True else Sradieal(tl(sl), s2)","oh","riO: une fonction VDM qui retournela","s~quence en entree priv~e de sa t~te. Unicitd de la notation : les m~thodes formelles permettent d'utiliser la m~me notation pour d~crire aussi bien les donn~es que les traitements. En effet, avec le langage VDM-SL, associ~ k VDM, nous avons pu specifier toutes les fonctions et les donn~es de r~f~rence de CORTEXA. Les exemples 4 et 5 illustrent cette unicit~ pour la representation des donn~es composdes et des fonctions. Exemple 4 : l'enregistrement relatif aux donn~es d'une d~composition d'un mot en un pr~fixe, un infixe, un suffixe et une racine.","Decomp :: p: CH i: CH s: CH r: CH Exemple 5: specification de l'action qui g~nhre les propositions de correction des suffixes par suppression de caracthre A3s(p : CH, c : CHAR)SCand : set of CH pre True post 3 a,b, pl E CH p = aec. b Apl = a • b A Pl e Su f f ~ {Pl } C SCand oh CHAR : l'ensemble des caracthres SCand : les suffixes candidats k la","correction","Surf: l'ensemble des suffixes. Cohdrence donndes-traitements : l'unicit~ de la notation, a permis d'appliquer des preuves formelles k la lois sur des donn~es et des traitements et par consequent de contr61er la coherence de ces derniers. L'exemple 1 illustre ce contr61e dans le cas d'un systhme ~ base de rhgles. 441 La validation de chaque composant du syst~me : pour chaque composant ou module du systbme CORTEXA, nous avons appliqu6 les preuves de validation appropri6es, ce qui nous a permis de valider tousles r6sultats partiels du systbme. Le th6orbme de l'exemple 6, donn6 ci-aprbs, permet de prouver qu'£ la suite de l'application de la rbgle de correction d'une erreur de substitution, les propositions de correction obtenues appartiennent au lexique. Exemple 6:","Vw' E CH, Vw ~ Lex.Sub(w, w ~) :. 3R ~ Reg.R(w') C_ Lex o~ Sub : un pr@dicat qui v6rifie l'erreur de substitution de caracthres. 4 Int6r6ts des m6thodes formelles en g6nie linguistique Cette exp6rimentation, bien qu'elle soit assez limit~e dans le temps (elle a dur~ une annie en-viron) et dans son contexte (elle s'est int6ress6","un seul systhme et non k plusieurs), elle nous a permis d'appr@cier £ juste titre l'int@r6t de recourir aux m6thodes formelles dans le processus de d6veloppement des applications li6es au TALN. Elle nous a aussi permis de d6gager certains avantages globaux d6di6s au domaine du TALN qui viennent consolider ceux que nous avons d4j£ cit6s dans un cadre g6n6ral de d6veloppement des Iogiciels. Ces avantages sp6cifiques peuvent ~tre r@sum6s et argument6s dans les points qui suivent. D'abord, au niveau de la specification des besoins, les applications du TALN sont g6n6ralement trhs ambitieuses au d6part. Or on connait aujourd'hui les limites des modbles linguistiques et des outils de repr6sentation des connaissances. L'utilisation d'outils formels dans les premibres 6tapes de d6veloppement (i.e., analyse) permet de mettre trbs vite en 6vidence les limites du systbme k d6velopper, en particulier, sur le plan de la couverture linguistique et par cons6quent de partir pour l'6tape de conception sur une version valid6e du systbme qui sera impl@ment6 et de pr4voir d'embl6 les possibilit6s d'extention et de r6utilisation. Par ailleurs, la complexit6 des traitements li6s au langage naturel et la diversit6 des donn6es linguistiques et des fortes int6ractions qui existent entre donn@es et traitements rendent la t~che de conception trbs difficile et pouvant engendrer des problbmes d'incoh6rence. L'utilisation des m6thodes formelles au niveau de la conception permet d'abord, de g6rer la dichotomie donn6es-traitements soit par l'int6gration (i.e., en utilisation l'approche objet), soit par le contrSle de coh6rence (i.e., par des preuves de validation) et ensuite de mettre en 6vidence, par des regroupements et des raffinements successifs, des abstractions int6ressantes r6utilisables telsque des modules ou des sous-systbmes pouvant ~tre disponibles dans une bibliothbque (Darricau et al., 1997). Ces abstractions correspondent par exemple des modules standards du TALN traitant le niveau phon6tique, morphologique, syntaxique, etc. Notons £ ce propos que, la r6utilisation de sp6cifications (i.e., de conception) peut se faire directement ou moyennant des adaptations. Les m6thodes formelles offrent des environnements qui facilitent ces adaptations (6diteurs,..) et qui permettent la validation des nouvelles sp6cifications. Enfin, l'utilisation d'une notation uniforme donne la possibilit6 d'int6grer dans la m@me application une vari6t@ de connaissances sur la langue sp6cifi@es avec des formalismes diff6rents (i.e., grammaires d'unification, HPSG, Grammaires Formelles, etc). Ce qui permet-tera d'avoir une meilleure coh6rence dans la sp6cification finale k produire. 5 Les critbres de choix d'une m6thode formelle pour le TALN L'utilisation de la m~thode VDM pour la specification complhte et valid~e du systhme CORTEXA a @t@ £ titre d'essai. Toutelois, le choix d'une m~thode formelle pour le d~veloppement d'une application de TALN reste crucial. Ce choix dolt tenir compte des sp~cificit~s du domaine des langues naturelles sur le plan du langage de specification et sur celui de la m~thodologie appliqu~e. Dans ce qui suit, nous donnons quelques crithres que nous jugeons pertinents dans le choix d'une m~thode formelle dans le contexte de TALN : 442 • Le pouvoir expressif de la m~thode : possibilit~ d'int~grer dans la m~me specification des connaissances linguistiques vari~es d~crites avec des formalismes diff4rents. Le langage de sp4cification doit pouvoir unifier la representation des diff4rentes expressions. Le pouvoir expressif concerne aussi la specification conjointe des donn~es linguistiques et les traitements qui leurs sont appliques.","• Simplicit~ de la notation et de la m~thodologie de d~veloppement.","• Couverture maximale du cycle de vie du logiciel ~ d4velopper.","• Existance d'Ateliers de G~nie Logiciel (AGLs) qui supportent la m~thode.","• Possibilit~ de supporter l'architecture du systhme envisag~ (i.e., s~quentielle, distribu~e, parallhle, etc). 6 Conclusion L'utilisation des m~thodes formelles dans le contexte des langues naturelles permet, non seulement de consolider les avantages globaux de ces methodes dans le cadre g~n~ral de d~veloppement de logiciels, mais aussi de rapporter de nouveaux profits sp~cifiques au domaine. Cette utilisation concerne aussi bien le processus de d~veloppement des applications que leur maintenance. Cependant, le choix d'une m~thode appropri~e reste li~ £ la disponibilit~ d'outils logiciels associ4s qui facilitent sa mise en oeuvre et k la construction d'une bibliothhque de specifications r~utilisables. Actuellement, nos travaux se concentrent sur la finalisation d'une approche que nous avons d~velopp~e pour g~n~raliser l'utilisation des m~thodes formelles (VDM ou autres) dans le processus de d~veloppement des linguiciels. Cette approche inthgre les principaux formalismes existants de description des connaissances linguistiques (i.e., Grammaires d'Unification, Grammaires Formelles, HPSG, etc). References L. M. Barroca and J. A. Mc Dermid. 1992. Formal methods : use and relevance for the development of safety-critical systems. The Computer Journal, 35(6). A. BenHamadou. 1993. Vdrification et correction automatiques par analyse affixale des textes dcrits en langage naturel : le cas de l'arabe non voyelld. Ph.D. thesis, Facult~ des Sciences de Tunis. Thhse Es-Sciences en Informatique. M. Darricau, H. Hadj Mabrouk, and J.G. Ganascia. 1997. Une approche pour la r~utilisation des sp6cifications de logiciels. Gdnie Logiciel, (45):21-27, September. J. Dawes. 1991. The VDM-SL reference guide. Pitman Publishing. J. Dick and E. Woods. 1997. Lessons learned from rigorous system software development. In-formation and Software Technology, 39:551-560. G. Erbach, J. Dorre, S. Manandhar, and H. Uszkoreit. 1996. A report on the draft eagles encoding standard for hpsg. In Actes de TALN-96, Marseille, France, May. C. Fuchs. 1993. Linguistique et Traitements Automatiques des Langues. Hachette. H. Habrias. 1995. Les specifications formelles pour les systhmes d'informations quoi ? pourquoi ?comments ? Ingdnierie des syst~mes d'information, 3 (2) :.205-253. J. Hui, L. Dong, and X. Xiren. 1997. Using formal specification language in industrial software development. In Procedings of the IEEE International Conference on Intelligent Processing Systems, pages 1847-1851, Beijing, China, October. K. Jensen, G.E. Heidorn, and S. D. Richardson. 1993. NLP: The PLNLP Approach. Kulwer academic publishers. C. B. Jones. 1986. Systematic software development using VDM. Printice Hall. L. Karttunen. 1986. D-patr : A development environment for unification-based grammars. In In Proceedings of the ~ lth International Conference on Computational Linguistics, pages 74-80, Bonn, Germany. Y. Ledru. 1993. Developing reactive systems in a vdm framework. Science of Computer Programming, 20:51-71. G. Sabah. 1989. L'intelligence artificielle et le langage. Hermes. R. Zajac. 1986. Scsl : a linguistic specification language for rot. In Procedings of COLING'86, pages 25-92, Bonn, Germany, August. 443"]}]}
