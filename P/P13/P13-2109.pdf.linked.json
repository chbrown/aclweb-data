{"sections":[{"title":"","paragraphs":["Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics, pages 617–622, Sofia, Bulgaria, August 4-9 2013. c⃝2013 Association for Computational Linguistics"]},{"title":"Turning on the Turbo: Fast Third-Order Non-Projective Turbo ParsersAndré F. T. Martins","paragraphs":["∗†"]},{"title":"Miguel B. Almeida","paragraphs":["∗†"]},{"title":"Noah A. Smith","paragraphs":["# ∗"]},{"title":"Priberam Labs, Alameda D. Afonso Henriques, 41, 2","paragraphs":["o"]},{"title":", 1000-123 Lisboa, Portugal","paragraphs":["†"]},{"title":"Instituto de Telecomunicações, Instituto Superior Técnico, 1049-001 Lisboa, Portugal","paragraphs":["#"]},{"title":"School of Computer Science, Carnegie Mellon University, Pittsburgh, PA 15213, USA{atm,mba}@priberam.pt, nasmith@cs.cmu.eduAbstract","paragraphs":["We present fast, accurate, direct non-projective dependency parsers with third-order features. Our approach uses AD3",", an accelerated dual decomposition algorithm which we extend to handle specialized head automata and sequential head bigram models. Experiments in fourteen languages yield parsing speeds competi-tive to projective parsers, with state-of-the-art accuracies for the largest datasets (English, Czech, and German)."]},{"title":"1 Introduction","paragraphs":["Dependency parsing has become a prominent approach to syntax in the last few years, with in-creasingly fast and accurate models being devised (Kübler et al., 2009; Huang and Sagae, 2010; Zhang and Nivre, 2011; Rush and Petrov, 2012).","In projective parsing, the arcs in the dependency tree are constrained to be nested, and the problem of finding the best tree can be addressed with dynamic programming. This results in cubic-time decoders for arc-factored and sibling second-order models (Eisner, 1996; McDonald and Pereira, 2006), and quartic-time for grandparent models (Carreras, 2007) and third-order models (Koo and Collins, 2010). Recently, Rush and Petrov (2012) trained third-order parsers with vine pruning cascades, achieving runtimes only a small factor slower than first-order systems. Third-order features have also been included in transition systems (Zhang and Nivre, 2011) and graph-based parsers with cube-pruning (Zhang and McDonald, 2012).","Unfortunately, non-projective dependency parsers (appropriate for languages with a more flexible word order, such as Czech, Dutch, and German) lag behind these recent advances. The main obstacle is that non-projective parsing is NP-hard beyond arc-factored models (McDonald and Satta, 2007). Approximate parsers have there-fore been introduced, based on belief propagation (Smith and Eisner, 2008), dual decomposition (Koo et al., 2010), or multi-commodity flows (Martins et al., 2009, 2011). These are all in-stances of turbo parsers, as shown by Martins et al. (2010): the underlying approximations come from the fact that they run global inference in factor graphs ignoring loop effects. While this line of research has led to accuracy gains, none of these parsers use third-order contexts, and their speeds are well behind those of projective parsers.","This paper bridges the gap above by presenting the following contributions:","• We apply the third-order feature models of Koo and Collins (2010) to non-projective parsing.","• This extension is non-trivial since exact dynamic programming is not applicable. Instead, we adapt AD3",", the dual decomposition algorithm proposed by Martins et al. (2011), to handle third-order features, by introducing specialized head automata.","• We make our parser substantially faster than the many-components approach of Martins et al. (2011). While AD3","requires solving quadratic subproblems as an intermediate step, recent results (Martins et al., 2012) show that they can be addressed with the same oracles used in the subgradient method (Koo et al., 2010). This enables AD3","to exploit combinatorial subproblems like the the head automata above. Along with this paper, we provide a free distribution of our parsers, including training code.1"]},{"title":"2 Dependency Parsing with AD","paragraphs":["3 Dual decomposition is a class of optimization techniques that tackle the dual of combinatorial","1","Released as TurboParser 2.1, and publicly available at http://www.ark.cs.cmu.edu/TurboParser. 617 Figure 1: Parts considered in this paper. First-order models factor over arcs (Eisner, 1996; McDonald et al., 2005), and second-order models include also consecutive siblings and grandparents (Carreras, 2007). Our parsers add also arbitrary siblings (not necessarily consecutive) and head bigrams, as in Martins et al. (2011), in addition to third-order features for grand- and tri-siblings (Koo and Collins, 2010). problems in a modular and extensible manner (Komodakis et al., 2007; Rush et al., 2010). In this paper, we employ alternating directions dual decomposition (AD3","; Martins et al., 2011). Like the subgradient algorithm of Rush et al. (2010), AD3","splits the original problem into local subproblems, and seeks an agreement on the overlapping variables. The difference is that the AD3 subproblems have an additional quadratic term to accelerate consensus. Recent analysis (Martins et al., 2012) has shown that: (i) AD3","converges at a faster rate,2","and (ii) the quadratic subproblems can be solved using the same combinatorial machinery that is used in the subgradient algorithm. This opens the door for larger subproblems (such as the combination of trees and head automata in Koo et al., 2010) instead of a many-components approach (Martins et al., 2011), while still enjoy-ing faster convergence. 2.1 Our Setup Given a sentence with L words, to which we prepend a root symbol $, let A := {⟨h, m⟩ | h ∈ {0, . . . , L}, m ∈ {1, . . . , L}, h ̸= m} be the set of possible dependency arcs. We parameterize a dependency tree via an indicator vector u := ⟨ua⟩a∈A, where ua is 1 if the arc a is in the tree, and 0 otherwise, and we denote by Y ⊆ R|A| the set of such vectors that are indicators of well-2 Concretely, AD3","needs O(1/ε) iterations to converge to","a ε-accurate solution, while subgradient needs O(1/ε2","). formed trees. Let {As}S","s=1 be a cover of A, where each As ⊆ A. We assume that the score of a parse tree u ∈ Y decomposes as f (u) := ∑S","s=1 fs(zs), where each zs := ⟨zs,a⟩a∈As is a “partial view” of u, and each local score function fs comes from a feature-based linear model.","Past work in dependency parsing considered either (i) a few “large” components, such as trees and head automata (Smith and Eisner, 2008; Koo et al., 2010), or (ii) many “small” components, coming from a multi-commodity flow formulation (Martins et al., 2009, 2011). Let Ys ⊆ R|As|","denote the set of feasible realizations of zs, i.e., those that are partial views of an actual parse tree. A tuple of views ⟨z1, . . . , zS⟩ ∈ ∏S","s=1 Ys is said to be globally consistent if zs,a = zs′",",a holds for every a, s and s′","such that a ∈ As∩As′. We assume each parse u ∈ Y corresponds uniquely to a globally consistent tuple of views, and vice-versa. Follow-ing Martins et al. (2011), the problem of obtaining the best-scored tree can be written as follows:","maximize ∑S s=1 fs(zs)","w.r.t. u ∈ R|A| , zs ∈ Ys, ∀s s.t. zs,a = ua, ∀s, ∀a ∈ As, (1) where the equality constraint ensures that the partial views “glue” together to form a coherent parse tree.3 2.2 Dual Decomposition and AD3 Dual decomposition methods dualize out the equality constraint in Eq. 1 by introducing Lagrange multipliers λs,a. In doing so, they solve a relaxation where the combinatorial sets Ys are replaced by their convex hulls Zs := conv(Ys).4","All that is necessary is the following assumption: Assumption 1 (Local-Max Oracle). Every s ∈ {1, . . . , S} has an oracle that solves efficiently any instance of the following subproblem:","maximize fs(zs) + ∑ a∈As λs,azs,a w.r.t. zs ∈ Ys. (2)","Typically, Assumption 1 is met whenever the max-","imization of fs over Ys is tractable, since the ob-","jective in Eq. 2 just adds a linear function to fs. 3 Note that any tuple ⟨z1, . . . , zS⟩ ∈ ∏S","s=1 Ys satisfying","the equality constraints will be globally consistent; this fact,","due the assumptions above, will imply u ∈ Y. 4 Let ∆|Ys|",":= {α ∈ R|Ys|","| α ≥ 0, ∑","y","s∈Ys αy","s = 1}","be the probability simplex. The convex hull of Ys is the set","conv(Ys) := {∑","y","s∈Ys αy","sys | α ∈ ∆|Ys|","}. Its members","represent marginal probabilities over the arcs in As. 618 The AD3","algorithm (Martins et al., 2011) alter-","nates among the following iterative updates:","• z-updates, which decouple over s = 1, . . . , S, and solve a penalized version of Eq. 2:","z(t+1)","s := arg max zs∈Zs fs(zs) + ∑","a∈As λ(t)","s,azs,a","− ρ","2 ∑ a∈As(zs,a − u(t)","a )2",". (3) Above, ρ is a constant and the quadratic term penalizes deviations from the current global solution (stored in u(t)",").5","We will see (Prop. 2) that this problem can be solved iteratively using only the Local-Max Oracle (Eq. 2). • u-updates, a simple averaging operation: u(t+1) a :=","1","|{s : a∈As}| ∑","s : a∈As z(t+1)","s,a . (4)","• λ-updates, where the Lagrange multipliers are adjusted to penalize disagreements:","λ(t+1)","s,a := λ(t) s,a − ρ(z(t+1)","s,a − u(t+1)","a ). (5)","In sum, the only difference between AD3","and the subgradient method is in the z-updates, which in AD3","require solving a quadratic problem. While closed-form solutions have been developed for some specialized components (Martins et al., 2011), this problem is in general more difficult than the one arising in the subgradient algorithm. However, the following result, proved in Martins et al. (2012), allows to expand the scope of AD3 to any problem which satisfies Assumption 1. Proposition 2. The problem in Eq. 3 admits a solution z∗","s which is spanned by a sparse basis W ⊆ Ys with cardinality at most |W| ≤ O(|As|). In other words, there is a distribution α with support in W such that z∗","s = ∑","ys∈W αysys.6","Prop. 2 has motivated an active set algorithm (Martins et al., 2012) that maintains an estimate of W by iteratively adding and removing elements computed through the oracle in Eq. 2.7","Typically, very few iterations are necessary and great speed-ups are achieved by warm-starting W with the active set computed in the previous AD3","iteration. This has a huge impact in practice and is crucial to obtain the fast runtimes in §4 (see Fig. 2).","5","In our experiments (§4), we set ρ = 0.05.","6","Note that |Ys| = O(2|As|",") in general. What Prop. 2 tells us is that the solution of Eq. 3 can be represented as a distribution over Ys with a very sparse support.","7","The algorithm is a specialization of Nocedal and Wright (1999), §16.4, which effectively exploits the sparse representation of z∗","s. For details, see Martins et al. (2012). 0 10 20 30 40 50 sentence length (words) 0.00 0.10 0.20 a v era g e ru n t i m e (s ec . ) AD3Subgrad. Figure 2: Comparison between AD3","and subgradient. We show averaged runtimes in PTB §22 as a function of the sentence length. For subgradient, we chose for each sentence the most favorable stepsize in {0.001, 0.01, 0.1, 1}."]},{"title":"3 Solving the Subproblems","paragraphs":["We next describe the actual components used in our third-order parsers. Tree component. We use an arc-factored score function (McDonald et al., 2005): f TREE","(z) =∑L","m=1 σARC(π(m), m), where π(m) is the parent of the mth word according to the parse tree z, and σARC(h, m) is the score of an individual arc. The parse tree that maximizes this function can be found in time O(L3",") via the Chu-Liu-Edmonds’ algorithm (Chu and Liu, 1965; Edmonds, 1967).8 Grand-sibling head automata. Let Ain","h and Aout","h denote respectively the sets of incoming and outgoing candidate arcs for the hth word, where the latter subdivides into arcs pointing to the right, Aout","h,→, and to the left, Aout","h,←. Define the sets AGSIB","h,→ = Ain","h ∪ Aout","h,→ and AGSIB","h,← = Ain","h ∪ Aout","h,←. We describe right-side grand-sibling head automata; their left-side counterparts are analogous. For each head word h in the parse tree z, define g := π(h), and let ⟨m0, m1, . . . , mp+1⟩ be the sequence of right modifiers ofh, with m0 = START and mp+1 = END. Then, we have the following grand-sibling component:","f GSIB","h,→ (z|AGSIB h,→) = ∑p+1","k=1 (","σSIB(h, mk−1, mk)","σGP(g, h, mk) + σGSIB(g, h, mk−1, mk)) , where we use the shorthand z|B to denote the subvector of z indexed by the arcs in B ⊆ A. Note that this score function absorbs grandparent and consecutive sibling scores, in addition to the grand-sibling scores.9","For each h, f GSIB","h,→ can be 8 In fact, there is an asymptotically faster O(L2",") algorithm","(Tarjan, 1977). Moreover, if the set of possible arcs is reduced","to a subset B ⊆ A (via pruning), then the fastest known al-","gorithm (Gabow et al., 1986) runs in O(|B| + L log L) time. 9 Koo et al. (2010) used an identical automaton for their","second-order model, but leaving out the grand-sibling scores. 619 No pruning","|Ain m| ≤ K","same, + |Aout h | ≤ J TREE","O(L2 ) O(KL + L log L) O(KL + L log L) GSIB","O(L4 )","O(K2 L2",")","O(JK2 L) TSIB","O(L4 )","O(KL3 )","O(J2 KL) SEQ","O(L3 )","O(K2 L)","O(K2 L) ASIB","O(L3 )","O(KL2 ) O(JKL) Table 1: Theoretical runtimes of each subproblem without pruning, limiting the number of candidate heads, and limiting (in addition) the number of modifiers. Note the O(L log L) total runtime per AD3","iteration in the latter case.","maximized in time O(L3",") with dynamic program-","ming, yielding O(L4",") total runtime. Tri-sibling head automata. In addition, we define left and right-side tri-sibling head automata that remember the previous two modifiers of a head word. This corresponds to the following component function (for the right-side case):","f TSIB","h,→ (z|Aout","h,→) = ∑p+1","k=2 σTSIB(h, mk−2, mk−1, mk).","Again, each of these functions can be maximized","in time O(L3","), yielding O(L4",") runtime. Sequential head bigram model. Head bigrams can be captured with a simple sequence model:","f SEQ (z) = ∑L","m=2 σHB(m, π(m), π(m − 1)). Each score σHB(m, h, h′",") is obtained via features that look at the heads of consecutive words (as in Martins et al. (2011)). This function can be maximized in time O(L3",") with the Viterbi algorithm. Arbitrary siblings. We handle arbitrary siblings as in Martins et al. (2011), definingO(L3",") component functions of the form f ASIB","h,m,s(z⟨h,m⟩, z⟨h,s⟩) = σASIB(h, m, s). In this case, the quadratic problem in Eq. 3 can be solved directly in constant time.","Tab. 1 details the time complexities of each subproblem. Without pruning, each iteration of AD3 has O(L4",") runtime. With a simple strategy that limits the number of candidate heads per word to a constant K, this drops to cubic time.10","Further speed-ups are possible with more pruning: by limiting the number of possible modifiers to a constant J , the runtime would reduce to O(L log L).","10","In our experiments, we employed this strategy with K = 10, by pruning with a first-order probabilistic model. Following Koo and Collins (2010), for each word m, we also pruned away incoming arcs ⟨h, m⟩ with posterior probability less than 0.0001 times the probability of the most likely head. UAS Tok/sec PTB-YM §22, 1st ord 91.38 4,063 PTB-YM §22, 2nd ord 93.15 1,338 PTB-YM §22, 2nd ord, +ASIB, +HB 93.28 1,018 PTB-YM §22, 3rd ord 93.29 709 PTB-YM §22, 3rd ord, gold tags 94.01 722 This work (PTB-YM §23, 3rd ord) 93.07 735 Koo et al. (2010) 92.46 112† Huang and Sagae (2010) 92.1– 587† Zhang and Nivre (2011) 92.9– 680† Martins et al. (2011) 92.53 66† Zhang and McDonald (2012) 93.06 220 This work (PTB-S §23, 3rd ord) 92.82 604 Rush and Petrov (2012) 92.7– 4,460 Table 2: Results for the projective English dataset. We report unlabeled attachment scores (UAS) ignoring punctuation, and parsing speeds in tokens per second. Our speeds include the time necessary for pruning, evaluating features, and decoding, as measured on a Intel Core i7 processor @3.4 GHz. The others are speeds reported in the cited papers; those marked with †","were converted from times per sentence."]},{"title":"4 Experiments","paragraphs":["We first evaluated our non-projective parser in a projective English dataset, to see how its speed and accuracy compares with recent projective parsers, which can take advantage of dynamic programming. To this end, we converted the Penn Treebank to dependencies through (i) the head rules of Yamada and Matsumoto (2003) (PTB-YM) and (ii) basic dependencies from the Stanford parser 2.0.5 (PTB-S).11","We trained by running 10 epochs of cost-augmented MIRA (Crammer et al., 2006). To ensure valid parse trees at test time, we rounded fractional solutions as in Martins et al. (2009)— yet, solutions were integral ≈ 95% of the time.","Tab. 2 shows the results in the dev-set (top block) and in the test-set (two bottom blocks). In the dev-set, we see consistent gains when more expressive features are added, the best accuracies being achieved with the full third-order model; this comes at the cost of a 6-fold drop in runtime compared with a first-order model. By looking at the two bottom blocks, we observe that our parser has slightly better accuracies than recent projective parsers, with comparable speed levels (with the exception of the highly optimized vine cascade approach of Rush and Petrov, 2012).","11","We train on sections §02–21, use §22 as validation data, and test on §23. We trained a simple 2nd-order tagger with 10-fold jackknifing to obtain automatic part-of-speech tags for §22–23, with accuracies 97.2% and 96.9%, respectively. 620 First Ord. Sec. Ord. Third Ord. Best published UAS RP12 ZM12 UAS Tok/sec UAS Tok/sec UAS Tok/sec UAS Tok/sec UAS Tok/sec UAS Arabic 77.23 2,481 78.50 388 79.64 197 81.12 - Ma11 - - - Bulgarian 91.76 5,678 92.82 2,049 93.10 1,273 93.50 - Ma11 91.9 3,980 93.08 Chinese 88.49 18,094 90.14 4,284 89.98 2,592 91.89 - Ma10 90.9 7,800 - Czech 87.66 1,840 90.00 751 90.32 501 89.46 - Ma11 - - - Danish 89.42 4,110 91.20 1,053 91.48 650 91.86 - Ma11 - - Dutch 83.61 3,884 86.37 1,294 86.19 599 85.81 121 Ko10 - - - German 90.52 5,331 91.85 1,788 92.41 965 91.89 - Ma11 90.8 2,880 91.35 English 91.21 3,127 93.03 1,317 93.22 785 92.68 - Ma11 - - - Japanese 92.78 23,895 93.14 5,660 93.52 2,996 93.72 - Ma11 92.3 8,600 93.24 Portuguese 91.14 4,273 92.71 1,316 92.69 740 93.03 79 Ko10 91.5 2,900 91.69 Slovene 82.81 4,315 85.21 722 86.01 366 86.95 - Ma11 - - - Spanish 83.61 4,347 84.97 623 85.59 318 87.48 - ZM12 - - 87.48 Swedish 89.36 5,622 90.98 1,387 91.14 684 91.44 - ZM12 90.1 5,320 91.44 Turkish 75.98 6,418 76.50 1,721 76.90 793 77.55 258 Ko10 - - - Table 3: Results for the CoNLL-2006 datasets and the non-projective English dataset of CoNLL-2008. “Best Published UAS” includes the most accurate parsers among Nivre et al. (2006), McDonald et al. (2006), Martins et al. (2010, 2011), Koo et al. (2010), Rush and Petrov (2012), Zhang and McDonald (2012). The last two are shown separately in the rightmost columns.","In our second experiment (Tab. 3), we used 14 datasets, most of which are non-projective, from the CoNLL 2006 and 2008 shared tasks (Buchholz and Marsi, 2006; Surdeanu et al., 2008). Our third-order model achieved the best reported scores for English, Czech, German, and Dutch— which includes the three largest datasets and the ones with the most non-projective dependencies— and is on par with the state of the art for the remaining languages. To our knowledge, the speeds are the highest reported among higher-order non-projective parsers, and only about 3– 4 times slower than the vine parser of Rush and Petrov (2012), which has lower accuracies."]},{"title":"5 Conclusions","paragraphs":["We presented new third-order non-projective parsers which are both fast and accurate. We decoded with AD3",", an accelerated dual decomposition algorithm which we adapted to handle large components, including specialized head automata for the third-order features, and a sequence model for head bigrams. Results are above the state of the art for large datasets and non-projective languages. In the hope that other researchers may find our implementation useful or are willing to contribute with further improvements, we made our parsers publicly available as open source software."]},{"title":"Acknowledgments","paragraphs":["We thank all reviewers for their insightful comments and Lingpeng Kong for help in converting the Penn Treebank to Stanford dependencies. This work was partially supported by the EU/FEDER programme, QREN/POR Lisboa (Portugal), under the Intelligo project (contract 2012/24803), by a FCT grant PTDC/EEI-SII/2312/2012, and by NSF grant IIS-1054319."]},{"title":"References","paragraphs":["S. Buchholz and E. Marsi. 2006. CoNLL-X shared task on multilingual dependency parsing. In International Conference on Natural Language Learning.","X. Carreras. 2007. Experiments with a higher-order projective dependency parser. In International Conference on Natural Language Learning.","Y. J. Chu and T. H. Liu. 1965. On the shortest arborescence of a directed graph. Science Sinica, 14:1396– 1400.","K. Crammer, O. Dekel, J. Keshet, S. Shalev-Shwartz, and Y. Singer. 2006. Online passive-aggressive algorithms. Journal of Machine Learning Research, 7:551–585.","J. Edmonds. 1967. Optimum branchings. Journal of Research of the National Bureau of Standards, 71B:233–240.","J. M. Eisner. 1996. Three new probabilistic models for dependency parsing: An exploration. In Proc. of International Conference on Computational Linguistics, pages 340–345.","H. N. Gabow, Z. Galil, T. Spencer, and R. E. Tarjan. 1986. Efficient algorithms for finding minimum spanning trees in undirected and directed graphs. Combinatorica, 6(2):109–122. 621","L. Huang and K. Sagae. 2010. Dynamic programming for linear-time incremental parsing. In Proc. of Annual Meeting of the Association for Computational Linguistics, pages 1077–1086.","N. Komodakis, N. Paragios, and G. Tziritas. 2007. MRF optimization via dual decomposition: Message-passing revisited. In Proc. of International Conference on Computer Vision.","T. Koo and M. Collins. 2010. Efficient third-order dependency parsers. In Proc. of Annual Meeting of the Association for Computational Linguistics, pages 1– 11.","T. Koo, A. M. Rush, M. Collins, T. Jaakkola, and D. Sontag. 2010. Dual decomposition for parsing with non-projective head automata. In Proc. of Empirical Methods for Natural Language Processing.","S. Kübler, R. McDonald, and J. Nivre. 2009. Dependency parsing. Morgan & Claypool Publishers.","A. F. T. Martins, N. A. Smith, and E. P. Xing. 2009. Concise integer linear programming formulations for dependency parsing. In Proc. of Annual Meeting of the Association for Computational Linguistics.","A. F. T. Martins, N. A. Smith, E. P. Xing, M. A. T. Figueiredo, and P. M. Q. Aguiar. 2010. Turbo parsers: Dependency parsing by approximate variational inference. In Proc. of Empirical Methods for Natural Language Processing.","A. F. T. Martins, N. A. Smith, P. M. Q. Aguiar, and M. A. T. Figueiredo. 2011. Dual decomposition with many overlapping components. In Proc. of Empirical Methods for Natural Language Processing.","A. F. T. Martins, M. A. T. Figueiredo, P. M. Q. Aguiar, N. A. Smith, and E. P. Xing. 2012. Alternat-ing directions dual decomposition. Arxiv preprint arXiv:1212.6550.","R. T. McDonald and F. C. N. Pereira. 2006. Online learning of approximate dependency parsing algorithms. In Proc. of Annual Meeting of the European Chapter of the Association for Computational Linguistics.","R. McDonald and G. Satta. 2007. On the complexity of non-projective data-driven dependency parsing. In Proc. of International Conference on Parsing Technologies.","R. T. McDonald, F. Pereira, K. Ribarov, and J. Hajic. 2005. Non-projective dependency parsing using spanning tree algorithms. In Proc. of Empirical Methods for Natural Language Processing.","R. McDonald, K. Lerman, and F. Pereira. 2006. Multilingual dependency analysis with a two-stage discriminative parser. In Proc. of International Conference on Natural Language Learning.","J. Nivre, J. Hall, J. Nilsson, G. Eryiǧit, and S. Marinov. 2006. Labeled pseudo-projective dependency parsing with support vector machines. In Procs. of International Conference on Natural Language Learning.","J. Nocedal and S. J. Wright. 1999. Numerical optimization. Springer-Verlag.","Alexander M Rush and Slav Petrov. 2012. Vine pruning for efficient multi-pass dependency parsing. In Proc. of Conference of the North American Chapter of the Association for Computational Linguistics.","A. Rush, D. Sontag, M. Collins, and T. Jaakkola. 2010. On dual decomposition and linear programming relaxations for natural language processing. In Proc. of Empirical Methods for Natural Language Processing.","D. Smith and J. Eisner. 2008. Dependency parsing by belief propagation. In Proc. of Empirical Methods for Natural Language Processing.","M. Surdeanu, R. Johansson, A. Meyers, L. Màrquez, and J. Nivre. 2008. The CoNLL-2008 shared task on joint parsing of syntactic and semantic dependencies. Proc. of International Conference on Natural Language Learning.","R.E. Tarjan. 1977. Finding optimum branchings. Networks, 7(1):25–36.","H. Yamada and Y. Matsumoto. 2003. Statistical dependency analysis with support vector machines. In Proc. of International Conference on Parsing Technologies.","H. Zhang and R. McDonald. 2012. Generalized higher-order dependency parsing with cube pruning. In Proc. of Empirical Methods in Natural Language Processing.","Y. Zhang and J. Nivre. 2011. Transition-based dependency parsing with rich non-local features. In Proc. of the Annual Meeting of the Association for Computational Linguistics. 622"]}],"references":[{"authors":[{"first":"S.","last":"Buchholz"},{"first":"E.","last":"Marsi"}],"year":"2006","title":"CoNLL-X shared task on multilingual dependency parsing"},{"authors":[{"first":"X.","last":"Carreras"}],"year":"2007","title":"Experiments with a higher-order projective dependency parser"},{"authors":[{"first":"Y.","middle":"J.","last":"Chu"},{"first":"T.","middle":"H.","last":"Liu"}],"year":"1965","title":"On the shortest arborescence of a directed graph"},{"authors":[{"first":"K.","last":"Crammer"},{"first":"O.","last":"Dekel"},{"first":"J.","last":"Keshet"},{"first":"S.","last":"Shalev-Shwartz"},{"first":"Y.","last":"Singer"}],"year":"2006","title":"Online passive-aggressive algorithms"},{"authors":[{"first":"J.","last":"Edmonds"}],"year":"1967","title":"Optimum branchings"},{"authors":[{"first":"J.","middle":"M.","last":"Eisner"}],"year":"1996","title":"Three new probabilistic models for dependency parsing: An exploration"},{"authors":[{"first":"H.","middle":"N.","last":"Gabow"},{"first":"Z.","last":"Galil"},{"first":"T.","last":"Spencer"},{"first":"R.","middle":"E.","last":"Tarjan"}],"year":"1986","title":"Efficient algorithms for finding minimum spanning trees in undirected and directed graphs"},{"authors":[{"first":"L.","last":"Huang"},{"first":"K.","last":"Sagae"}],"year":"2010","title":"Dynamic programming for linear-time incremental parsing"},{"authors":[{"first":"N.","last":"Komodakis"},{"first":"N.","last":"Paragios"},{"first":"G.","last":"Tziritas"}],"year":"2007","title":"MRF optimization via dual decomposition: Message-passing revisited"},{"authors":[{"first":"T.","last":"Koo"},{"first":"M.","last":"Collins"}],"year":"2010","title":"Efficient third-order dependency parsers"},{"authors":[{"first":"T.","last":"Koo"},{"first":"A.","middle":"M.","last":"Rush"},{"first":"M.","last":"Collins"},{"first":"T.","last":"Jaakkola"},{"first":"D.","last":"Sontag"}],"year":"2010","title":"Dual decomposition for parsing with non-projective head automata"},{"authors":[{"first":"S.","last":"Kübler"},{"first":"R.","last":"McDonald"},{"first":"J.","last":"Nivre"}],"year":"2009","title":"Dependency parsing"},{"authors":[{"first":"A.","middle":"F. T.","last":"Martins"},{"first":"N.","middle":"A.","last":"Smith"},{"first":"E.","middle":"P.","last":"Xing"}],"year":"2009","title":"Concise integer linear programming formulations for dependency parsing"},{"authors":[{"first":"A.","middle":"F. T.","last":"Martins"},{"first":"N.","middle":"A.","last":"Smith"},{"first":"E.","middle":"P.","last":"Xing"},{"first":"M.","middle":"A. T.","last":"Figueiredo"},{"first":"P.","middle":"M. Q.","last":"Aguiar"}],"year":"2010","title":"Turbo parsers: Dependency parsing by approximate variational inference"},{"authors":[{"first":"A.","middle":"F. T.","last":"Martins"},{"first":"N.","middle":"A.","last":"Smith"},{"first":"P.","middle":"M. Q.","last":"Aguiar"},{"first":"M.","middle":"A. T.","last":"Figueiredo"}],"year":"2011","title":"Dual decomposition with many overlapping components"},{"authors":[{"first":"A.","middle":"F. T.","last":"Martins"},{"first":"M.","middle":"A. T.","last":"Figueiredo"},{"first":"P.","middle":"M. Q.","last":"Aguiar"},{"first":"N.","middle":"A.","last":"Smith"},{"first":"E.","middle":"P.","last":"Xing"}],"year":"2012","title":"Alternat-ing directions dual decomposition"},{"authors":[{"first":"R.","middle":"T.","last":"McDonald"},{"first":"F.","middle":"C. N.","last":"Pereira"}],"year":"2006","title":"Online learning of approximate dependency parsing algorithms"},{"authors":[{"first":"R.","last":"McDonald"},{"first":"G.","last":"Satta"}],"year":"2007","title":"On the complexity of non-projective data-driven dependency parsing"},{"authors":[{"first":"R.","middle":"T.","last":"McDonald"},{"first":"F.","last":"Pereira"},{"first":"K.","last":"Ribarov"},{"first":"J.","last":"Hajic"}],"year":"2005","title":"Non-projective dependency parsing using spanning tree algorithms"},{"authors":[{"first":"R.","last":"McDonald"},{"first":"K.","last":"Lerman"},{"first":"F.","last":"Pereira"}],"year":"2006","title":"Multilingual dependency analysis with a two-stage discriminative parser"},{"authors":[{"first":"J.","last":"Nivre"},{"first":"J.","last":"Hall"},{"first":"J.","last":"Nilsson"},{"first":"G.","last":"Eryiǧit"},{"first":"S.","last":"Marinov"}],"year":"2006","title":"Labeled pseudo-projective dependency parsing with support vector machines"},{"authors":[{"first":"J.","last":"Nocedal"},{"first":"S.","middle":"J.","last":"Wright"}],"year":"1999","title":"Numerical optimization"},{"authors":[{"first":"Alexander","middle":"M","last":"Rush"},{"first":"Slav","last":"Petrov"}],"year":"2012","title":"Vine pruning for efficient multi-pass dependency parsing"},{"authors":[{"first":"A.","last":"Rush"},{"first":"D.","last":"Sontag"},{"first":"M.","last":"Collins"},{"first":"T.","last":"Jaakkola"}],"year":"2010","title":"On dual decomposition and linear programming relaxations for natural language processing"},{"authors":[{"first":"D.","last":"Smith"},{"first":"J.","last":"Eisner"}],"year":"2008","title":"Dependency parsing by belief propagation"},{"authors":[{"first":"M.","last":"Surdeanu"},{"first":"R.","last":"Johansson"},{"first":"A.","last":"Meyers"},{"first":"L.","last":"Màrquez"},{"first":"J.","last":"Nivre"}],"year":"2008","title":"The CoNLL-2008 shared task on joint parsing of syntactic and semantic dependencies"},{"authors":[{"first":"R.","middle":"E.","last":"Tarjan"}],"year":"1977","title":"Finding optimum branchings"},{"authors":[{"first":"H.","last":"Yamada"},{"first":"Y.","last":"Matsumoto"}],"year":"2003","title":"Statistical dependency analysis with support vector machines"},{"authors":[{"first":"H.","last":"Zhang"},{"first":"R.","last":"McDonald"}],"year":"2012","title":"Generalized higher-order dependency parsing with cube pruning"},{"authors":[{"first":"Y.","last":"Zhang"},{"first":"J.","last":"Nivre"}],"year":"2011","title":"Transition-based dependency parsing with rich non-local features"}],"cites":[{"authors":[{"last":"Técnico"}],"year":"1049","style":0},{"authors":[{"last":"Kübler"},{"last":"al."}],"year":"2009","style":0,"reference":{"authors":[{"first":"S.","last":"Kübler"},{"first":"R.","last":"McDonald"},{"first":"J.","last":"Nivre"}],"year":"2009","title":"Dependency parsing"}},{"authors":[{"last":"Huang"},{"last":"Sagae"}],"year":"2010","style":0,"reference":{"authors":[{"first":"L.","last":"Huang"},{"first":"K.","last":"Sagae"}],"year":"2010","title":"Dynamic programming for linear-time incremental parsing"}},{"authors":[{"last":"Zhang"},{"last":"Nivre"}],"year":"2011","style":0,"reference":{"authors":[{"first":"Y.","last":"Zhang"},{"first":"J.","last":"Nivre"}],"year":"2011","title":"Transition-based dependency parsing with rich non-local features"}},{"authors":[{"last":"Rush"},{"last":"Petrov"}],"year":"2012","style":0,"reference":{"authors":[{"first":"Alexander","middle":"M","last":"Rush"},{"first":"Slav","last":"Petrov"}],"year":"2012","title":"Vine pruning for efficient multi-pass dependency parsing"}},{"authors":[{"last":"Eisner"}],"year":"1996","style":0,"reference":{"authors":[{"first":"J.","middle":"M.","last":"Eisner"}],"year":"1996","title":"Three new probabilistic models for dependency parsing: An exploration"}},{"authors":[{"last":"McDonald"},{"last":"Pereira"}],"year":"2006","style":0,"reference":{"authors":[{"first":"R.","middle":"T.","last":"McDonald"},{"first":"F.","middle":"C. N.","last":"Pereira"}],"year":"2006","title":"Online learning of approximate dependency parsing algorithms"}},{"authors":[{"last":"Carreras"}],"year":"2007","style":0,"reference":{"authors":[{"first":"X.","last":"Carreras"}],"year":"2007","title":"Experiments with a higher-order projective dependency parser"}},{"authors":[{"last":"Koo"},{"last":"Collins"}],"year":"2010","style":0,"reference":{"authors":[{"first":"T.","last":"Koo"},{"first":"M.","last":"Collins"}],"year":"2010","title":"Efficient third-order dependency parsers"}},{"authors":[{"last":"Rush"},{"last":"Petrov"}],"year":"2012","style":0,"reference":{"authors":[{"first":"Alexander","middle":"M","last":"Rush"},{"first":"Slav","last":"Petrov"}],"year":"2012","title":"Vine pruning for efficient multi-pass dependency parsing"}},{"authors":[{"last":"Zhang"},{"last":"Nivre"}],"year":"2011","style":0,"reference":{"authors":[{"first":"Y.","last":"Zhang"},{"first":"J.","last":"Nivre"}],"year":"2011","title":"Transition-based dependency parsing with rich non-local features"}},{"authors":[{"last":"Zhang"},{"last":"McDonald"}],"year":"2012","style":0,"reference":{"authors":[{"first":"H.","last":"Zhang"},{"first":"R.","last":"McDonald"}],"year":"2012","title":"Generalized higher-order dependency parsing with cube pruning"}},{"authors":[{"last":"McDonald"},{"last":"Satta"}],"year":"2007","style":0,"reference":{"authors":[{"first":"R.","last":"McDonald"},{"first":"G.","last":"Satta"}],"year":"2007","title":"On the complexity of non-projective data-driven dependency parsing"}},{"authors":[{"last":"Smith"},{"last":"Eisner"}],"year":"2008","style":0,"reference":{"authors":[{"first":"D.","last":"Smith"},{"first":"J.","last":"Eisner"}],"year":"2008","title":"Dependency parsing by belief propagation"}},{"authors":[{"last":"Koo"},{"last":"al."}],"year":"2010","style":0,"reference":{"authors":[{"first":"T.","last":"Koo"},{"first":"A.","middle":"M.","last":"Rush"},{"first":"M.","last":"Collins"},{"first":"T.","last":"Jaakkola"},{"first":"D.","last":"Sontag"}],"year":"2010","title":"Dual decomposition for parsing with non-projective head automata"}},{"authors":[{"last":"Martins"},{"last":"al."}],"year":"2009","style":0,"reference":{"authors":[{"first":"A.","middle":"F. T.","last":"Martins"},{"first":"N.","middle":"A.","last":"Smith"},{"first":"E.","middle":"P.","last":"Xing"}],"year":"2009","title":"Concise integer linear programming formulations for dependency parsing"}},{"authors":[{"last":"Martins"},{"last":"al."}],"year":"2010","style":0,"reference":{"authors":[{"first":"A.","middle":"F. T.","last":"Martins"},{"first":"N.","middle":"A.","last":"Smith"},{"first":"E.","middle":"P.","last":"Xing"},{"first":"M.","middle":"A. T.","last":"Figueiredo"},{"first":"P.","middle":"M. Q.","last":"Aguiar"}],"year":"2010","title":"Turbo parsers: Dependency parsing by approximate variational inference"}},{"authors":[{"last":"Koo"},{"last":"Collins"}],"year":"2010","style":0,"reference":{"authors":[{"first":"T.","last":"Koo"},{"first":"M.","last":"Collins"}],"year":"2010","title":"Efficient third-order dependency parsers"}},{"authors":[{"last":"Martins"},{"last":"al."}],"year":"2011","style":0,"reference":{"authors":[{"first":"A.","middle":"F. T.","last":"Martins"},{"first":"N.","middle":"A.","last":"Smith"},{"first":"P.","middle":"M. Q.","last":"Aguiar"},{"first":"M.","middle":"A. T.","last":"Figueiredo"}],"year":"2011","title":"Dual decomposition with many overlapping components"}},{"authors":[{"last":"Martins"},{"last":"al."}],"year":"2011","style":0,"reference":{"authors":[{"first":"A.","middle":"F. T.","last":"Martins"},{"first":"N.","middle":"A.","last":"Smith"},{"first":"P.","middle":"M. Q.","last":"Aguiar"},{"first":"M.","middle":"A. T.","last":"Figueiredo"}],"year":"2011","title":"Dual decomposition with many overlapping components"}},{"authors":[{"last":"Martins"},{"last":"al."}],"year":"2012","style":0,"reference":{"authors":[{"first":"A.","middle":"F. T.","last":"Martins"},{"first":"M.","middle":"A. T.","last":"Figueiredo"},{"first":"P.","middle":"M. Q.","last":"Aguiar"},{"first":"N.","middle":"A.","last":"Smith"},{"first":"E.","middle":"P.","last":"Xing"}],"year":"2012","title":"Alternat-ing directions dual decomposition"}},{"authors":[{"last":"Koo"},{"last":"al."}],"year":"2010","style":0,"reference":{"authors":[{"first":"T.","last":"Koo"},{"first":"A.","middle":"M.","last":"Rush"},{"first":"M.","last":"Collins"},{"first":"T.","last":"Jaakkola"},{"first":"D.","last":"Sontag"}],"year":"2010","title":"Dual decomposition for parsing with non-projective head automata"}},{"authors":[{"last":"Eisner"}],"year":"1996","style":0,"reference":{"authors":[{"first":"J.","middle":"M.","last":"Eisner"}],"year":"1996","title":"Three new probabilistic models for dependency parsing: An exploration"}},{"authors":[{"last":"McDonald"},{"last":"al."}],"year":"2005","style":0,"reference":{"authors":[{"first":"R.","middle":"T.","last":"McDonald"},{"first":"F.","last":"Pereira"},{"first":"K.","last":"Ribarov"},{"first":"J.","last":"Hajic"}],"year":"2005","title":"Non-projective dependency parsing using spanning tree algorithms"}},{"authors":[{"last":"Carreras"}],"year":"2007","style":0,"reference":{"authors":[{"first":"X.","last":"Carreras"}],"year":"2007","title":"Experiments with a higher-order projective dependency parser"}},{"authors":[{"last":"Martins"},{"last":"al."}],"year":"2011","style":0,"reference":{"authors":[{"first":"A.","middle":"F. T.","last":"Martins"},{"first":"N.","middle":"A.","last":"Smith"},{"first":"P.","middle":"M. Q.","last":"Aguiar"},{"first":"M.","middle":"A. T.","last":"Figueiredo"}],"year":"2011","title":"Dual decomposition with many overlapping components"}},{"authors":[{"last":"Koo"},{"last":"Collins"}],"year":"2010","style":0,"reference":{"authors":[{"first":"T.","last":"Koo"},{"first":"M.","last":"Collins"}],"year":"2010","title":"Efficient third-order dependency parsers"}},{"authors":[{"last":"Komodakis"},{"last":"al."}],"year":"2007","style":0,"reference":{"authors":[{"first":"N.","last":"Komodakis"},{"first":"N.","last":"Paragios"},{"first":"G.","last":"Tziritas"}],"year":"2007","title":"MRF optimization via dual decomposition: Message-passing revisited"}},{"authors":[{"last":"Rush"},{"last":"al."}],"year":"2010","style":0,"reference":{"authors":[{"first":"A.","last":"Rush"},{"first":"D.","last":"Sontag"},{"first":"M.","last":"Collins"},{"first":"T.","last":"Jaakkola"}],"year":"2010","title":"On dual decomposition and linear programming relaxations for natural language processing"}},{"authors":[{"last":"Martins"},{"last":"al."}],"year":"2011","style":0,"reference":{"authors":[{"first":"A.","middle":"F. T.","last":"Martins"},{"first":"N.","middle":"A.","last":"Smith"},{"first":"P.","middle":"M. Q.","last":"Aguiar"},{"first":"M.","middle":"A. T.","last":"Figueiredo"}],"year":"2011","title":"Dual decomposition with many overlapping components"}},{"authors":[{"last":"Rush"},{"last":"al."}],"year":"2010","style":0,"reference":{"authors":[{"first":"A.","last":"Rush"},{"first":"D.","last":"Sontag"},{"first":"M.","last":"Collins"},{"first":"T.","last":"Jaakkola"}],"year":"2010","title":"On dual decomposition and linear programming relaxations for natural language processing"}},{"authors":[{"last":"Martins"},{"last":"al."}],"year":"2012","style":0,"reference":{"authors":[{"first":"A.","middle":"F. T.","last":"Martins"},{"first":"M.","middle":"A. T.","last":"Figueiredo"},{"first":"P.","middle":"M. Q.","last":"Aguiar"},{"first":"N.","middle":"A.","last":"Smith"},{"first":"E.","middle":"P.","last":"Xing"}],"year":"2012","title":"Alternat-ing directions dual decomposition"}},{"authors":[{"last":"Koo"},{"last":"al."}],"year":"2010","style":0,"reference":{"authors":[{"first":"T.","last":"Koo"},{"first":"A.","middle":"M.","last":"Rush"},{"first":"M.","last":"Collins"},{"first":"T.","last":"Jaakkola"},{"first":"D.","last":"Sontag"}],"year":"2010","title":"Dual decomposition for parsing with non-projective head automata"}},{"authors":[{"last":"Martins"},{"last":"al."}],"year":"2011","style":0,"reference":{"authors":[{"first":"A.","middle":"F. T.","last":"Martins"},{"first":"N.","middle":"A.","last":"Smith"},{"first":"P.","middle":"M. Q.","last":"Aguiar"},{"first":"M.","middle":"A. T.","last":"Figueiredo"}],"year":"2011","title":"Dual decomposition with many overlapping components"}},{"authors":[{"last":"Smith"},{"last":"Eisner"}],"year":"2008","style":0,"reference":{"authors":[{"first":"D.","last":"Smith"},{"first":"J.","last":"Eisner"}],"year":"2008","title":"Dependency parsing by belief propagation"}},{"authors":[{"last":"Koo"},{"last":"al."}],"year":"2010","style":0,"reference":{"authors":[{"first":"T.","last":"Koo"},{"first":"A.","middle":"M.","last":"Rush"},{"first":"M.","last":"Collins"},{"first":"T.","last":"Jaakkola"},{"first":"D.","last":"Sontag"}],"year":"2010","title":"Dual decomposition for parsing with non-projective head automata"}},{"authors":[{"last":"Martins"},{"last":"al."}],"year":"2009","style":0,"reference":{"authors":[{"first":"A.","middle":"F. T.","last":"Martins"},{"first":"N.","middle":"A.","last":"Smith"},{"first":"E.","middle":"P.","last":"Xing"}],"year":"2009","title":"Concise integer linear programming formulations for dependency parsing"}},{"authors":[{"last":"Martins"},{"last":"al."}],"year":"2011","style":0,"reference":{"authors":[{"first":"A.","middle":"F. T.","last":"Martins"},{"first":"N.","middle":"A.","last":"Smith"},{"first":"P.","middle":"M. Q.","last":"Aguiar"},{"first":"M.","middle":"A. T.","last":"Figueiredo"}],"year":"2011","title":"Dual decomposition with many overlapping components"}},{"authors":[{"last":"Martins"},{"last":"al."}],"year":"2011","style":0,"reference":{"authors":[{"first":"A.","middle":"F. T.","last":"Martins"},{"first":"N.","middle":"A.","last":"Smith"},{"first":"P.","middle":"M. Q.","last":"Aguiar"},{"first":"M.","middle":"A. T.","last":"Figueiredo"}],"year":"2011","title":"Dual decomposition with many overlapping components"}},{"authors":[{"last":"Martins"},{"last":"al."}],"year":"2011","style":0,"reference":{"authors":[{"first":"A.","middle":"F. T.","last":"Martins"},{"first":"N.","middle":"A.","last":"Smith"},{"first":"P.","middle":"M. Q.","last":"Aguiar"},{"first":"M.","middle":"A. T.","last":"Figueiredo"}],"year":"2011","title":"Dual decomposition with many overlapping components"}},{"authors":[{"last":"Martins"},{"last":"al."}],"year":"2012","style":0,"reference":{"authors":[{"first":"A.","middle":"F. T.","last":"Martins"},{"first":"M.","middle":"A. T.","last":"Figueiredo"},{"first":"P.","middle":"M. Q.","last":"Aguiar"},{"first":"N.","middle":"A.","last":"Smith"},{"first":"E.","middle":"P.","last":"Xing"}],"year":"2012","title":"Alternat-ing directions dual decomposition"}},{"authors":[{"last":"Martins"},{"last":"al."}],"year":"2012","style":0,"reference":{"authors":[{"first":"A.","middle":"F. T.","last":"Martins"},{"first":"M.","middle":"A. T.","last":"Figueiredo"},{"first":"P.","middle":"M. Q.","last":"Aguiar"},{"first":"N.","middle":"A.","last":"Smith"},{"first":"E.","middle":"P.","last":"Xing"}],"year":"2012","title":"Alternat-ing directions dual decomposition"}},{"authors":[{"last":"Nocedal"},{"last":"Wright"}],"year":"1999","style":0,"reference":{"authors":[{"first":"J.","last":"Nocedal"},{"first":"S.","middle":"J.","last":"Wright"}],"year":"1999","title":"Numerical optimization"}},{"authors":[{"last":"Martins"},{"last":"al."}],"year":"2012","style":0,"reference":{"authors":[{"first":"A.","middle":"F. T.","last":"Martins"},{"first":"M.","middle":"A. T.","last":"Figueiredo"},{"first":"P.","middle":"M. Q.","last":"Aguiar"},{"first":"N.","middle":"A.","last":"Smith"},{"first":"E.","middle":"P.","last":"Xing"}],"year":"2012","title":"Alternat-ing directions dual decomposition"}},{"authors":[{"last":"McDonald"},{"last":"al."}],"year":"2005","style":0,"reference":{"authors":[{"first":"R.","middle":"T.","last":"McDonald"},{"first":"F.","last":"Pereira"},{"first":"K.","last":"Ribarov"},{"first":"J.","last":"Hajic"}],"year":"2005","title":"Non-projective dependency parsing using spanning tree algorithms"}},{"authors":[{"last":"Chu"},{"last":"Liu"}],"year":"1965","style":0,"reference":{"authors":[{"first":"Y.","middle":"J.","last":"Chu"},{"first":"T.","middle":"H.","last":"Liu"}],"year":"1965","title":"On the shortest arborescence of a directed graph"}},{"authors":[{"last":"Edmonds"}],"year":"1967","style":0,"reference":{"authors":[{"first":"J.","last":"Edmonds"}],"year":"1967","title":"Optimum branchings"}},{"authors":[{"last":"Tarjan"}],"year":"1977","style":0,"reference":{"authors":[{"first":"R.","middle":"E.","last":"Tarjan"}],"year":"1977","title":"Finding optimum branchings"}},{"authors":[{"last":"Gabow"},{"last":"al."}],"year":"1986","style":0,"reference":{"authors":[{"first":"H.","middle":"N.","last":"Gabow"},{"first":"Z.","last":"Galil"},{"first":"T.","last":"Spencer"},{"first":"R.","middle":"E.","last":"Tarjan"}],"year":"1986","title":"Efficient algorithms for finding minimum spanning trees in undirected and directed graphs"}},{"authors":[{"last":"Koo"},{"last":"al."}],"year":"2010","style":0,"reference":{"authors":[{"first":"T.","last":"Koo"},{"first":"A.","middle":"M.","last":"Rush"},{"first":"M.","last":"Collins"},{"first":"T.","last":"Jaakkola"},{"first":"D.","last":"Sontag"}],"year":"2010","title":"Dual decomposition for parsing with non-projective head automata"}},{"authors":[{"last":"Martins"},{"last":"al."}],"year":"2011","style":0,"reference":{"authors":[{"first":"A.","middle":"F. T.","last":"Martins"},{"first":"N.","middle":"A.","last":"Smith"},{"first":"P.","middle":"M. Q.","last":"Aguiar"},{"first":"M.","middle":"A. T.","last":"Figueiredo"}],"year":"2011","title":"Dual decomposition with many overlapping components"}},{"authors":[{"last":"Martins"},{"last":"al."}],"year":"2011","style":0,"reference":{"authors":[{"first":"A.","middle":"F. T.","last":"Martins"},{"first":"N.","middle":"A.","last":"Smith"},{"first":"P.","middle":"M. Q.","last":"Aguiar"},{"first":"M.","middle":"A. T.","last":"Figueiredo"}],"year":"2011","title":"Dual decomposition with many overlapping components"}},{"authors":[{"last":"Koo"},{"last":"Collins"}],"year":"2010","style":0,"reference":{"authors":[{"first":"T.","last":"Koo"},{"first":"M.","last":"Collins"}],"year":"2010","title":"Efficient third-order dependency parsers"}},{"authors":[{"last":"Koo"},{"last":"al."}],"year":"2010","style":0,"reference":{"authors":[{"first":"T.","last":"Koo"},{"first":"A.","middle":"M.","last":"Rush"},{"first":"M.","last":"Collins"},{"first":"T.","last":"Jaakkola"},{"first":"D.","last":"Sontag"}],"year":"2010","title":"Dual decomposition for parsing with non-projective head automata"}},{"authors":[{"last":"Huang"},{"last":"Sagae"}],"year":"2010","style":0,"reference":{"authors":[{"first":"L.","last":"Huang"},{"first":"K.","last":"Sagae"}],"year":"2010","title":"Dynamic programming for linear-time incremental parsing"}},{"authors":[{"last":"Zhang"},{"last":"Nivre"}],"year":"2011","style":0,"reference":{"authors":[{"first":"Y.","last":"Zhang"},{"first":"J.","last":"Nivre"}],"year":"2011","title":"Transition-based dependency parsing with rich non-local features"}},{"authors":[{"last":"Martins"},{"last":"al."}],"year":"2011","style":0,"reference":{"authors":[{"first":"A.","middle":"F. T.","last":"Martins"},{"first":"N.","middle":"A.","last":"Smith"},{"first":"P.","middle":"M. Q.","last":"Aguiar"},{"first":"M.","middle":"A. T.","last":"Figueiredo"}],"year":"2011","title":"Dual decomposition with many overlapping components"}},{"authors":[{"last":"Zhang"},{"last":"McDonald"}],"year":"2012","style":0,"reference":{"authors":[{"first":"H.","last":"Zhang"},{"first":"R.","last":"McDonald"}],"year":"2012","title":"Generalized higher-order dependency parsing with cube pruning"}},{"authors":[{"last":"Rush"},{"last":"Petrov"}],"year":"2012","style":0,"reference":{"authors":[{"first":"Alexander","middle":"M","last":"Rush"},{"first":"Slav","last":"Petrov"}],"year":"2012","title":"Vine pruning for efficient multi-pass dependency parsing"}},{"authors":[{"last":"Yamada"},{"last":"Matsumoto"}],"year":"2003","style":0,"reference":{"authors":[{"first":"H.","last":"Yamada"},{"first":"Y.","last":"Matsumoto"}],"year":"2003","title":"Statistical dependency analysis with support vector machines"}},{"authors":[{"last":"Crammer"},{"last":"al."}],"year":"2006","style":0,"reference":{"authors":[{"first":"K.","last":"Crammer"},{"first":"O.","last":"Dekel"},{"first":"J.","last":"Keshet"},{"first":"S.","last":"Shalev-Shwartz"},{"first":"Y.","last":"Singer"}],"year":"2006","title":"Online passive-aggressive algorithms"}},{"authors":[{"last":"Martins"},{"last":"al."}],"year":"2009","style":0,"reference":{"authors":[{"first":"A.","middle":"F. T.","last":"Martins"},{"first":"N.","middle":"A.","last":"Smith"},{"first":"E.","middle":"P.","last":"Xing"}],"year":"2009","title":"Concise integer linear programming formulations for dependency parsing"}},{"authors":[{"last":"Rush"},{"last":"Petrov"}],"year":"2012","style":0,"reference":{"authors":[{"first":"Alexander","middle":"M","last":"Rush"},{"first":"Slav","last":"Petrov"}],"year":"2012","title":"Vine pruning for efficient multi-pass dependency parsing"}},{"authors":[{"last":"Nivre"},{"last":"al."}],"year":"2006","style":0,"reference":{"authors":[{"first":"J.","last":"Nivre"},{"first":"J.","last":"Hall"},{"first":"J.","last":"Nilsson"},{"first":"G.","last":"Eryiǧit"},{"first":"S.","last":"Marinov"}],"year":"2006","title":"Labeled pseudo-projective dependency parsing with support vector machines"}},{"authors":[{"last":"McDonald"},{"last":"al."}],"year":"2006","style":0,"reference":{"authors":[{"first":"R.","last":"McDonald"},{"first":"K.","last":"Lerman"},{"first":"F.","last":"Pereira"}],"year":"2006","title":"Multilingual dependency analysis with a two-stage discriminative parser"}},{"authors":[{"last":"Koo"},{"last":"al."}],"year":"2010","style":0,"reference":{"authors":[{"first":"T.","last":"Koo"},{"first":"A.","middle":"M.","last":"Rush"},{"first":"M.","last":"Collins"},{"first":"T.","last":"Jaakkola"},{"first":"D.","last":"Sontag"}],"year":"2010","title":"Dual decomposition for parsing with non-projective head automata"}},{"authors":[{"last":"Rush"},{"last":"Petrov"}],"year":"2012","style":0,"reference":{"authors":[{"first":"Alexander","middle":"M","last":"Rush"},{"first":"Slav","last":"Petrov"}],"year":"2012","title":"Vine pruning for efficient multi-pass dependency parsing"}},{"authors":[{"last":"Zhang"},{"last":"McDonald"}],"year":"2012","style":0,"reference":{"authors":[{"first":"H.","last":"Zhang"},{"first":"R.","last":"McDonald"}],"year":"2012","title":"Generalized higher-order dependency parsing with cube pruning"}},{"authors":[{"last":"Buchholz"},{"last":"Marsi"}],"year":"2006","style":0,"reference":{"authors":[{"first":"S.","last":"Buchholz"},{"first":"E.","last":"Marsi"}],"year":"2006","title":"CoNLL-X shared task on multilingual dependency parsing"}},{"authors":[{"last":"Surdeanu"},{"last":"al."}],"year":"2008","style":0,"reference":{"authors":[{"first":"M.","last":"Surdeanu"},{"first":"R.","last":"Johansson"},{"first":"A.","last":"Meyers"},{"first":"L.","last":"Màrquez"},{"first":"J.","last":"Nivre"}],"year":"2008","title":"The CoNLL-2008 shared task on joint parsing of syntactic and semantic dependencies"}},{"authors":[{"last":"Rush"},{"last":"Petrov"}],"year":"2012","style":0,"reference":{"authors":[{"first":"Alexander","middle":"M","last":"Rush"},{"first":"Slav","last":"Petrov"}],"year":"2012","title":"Vine pruning for efficient multi-pass dependency parsing"}}]}
