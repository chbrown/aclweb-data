{"sections":[{"title":"Construct Algebra: Analytical Dialog Management Alicia Abella and Allen L. Gorin AT cT Labs Research 180 Park Ave. Bldg 103 Florham Park, NJ 07932 Abstract","paragraphs":["In this paper we describe a systematic approach for creating a dialog management system based on a Construct Algebra, a collection of relations and operations on a task representation. These relations and operations are analytical components for building higher level abstractions called dialog motivators. The dialog manager, consisting of a collection of dialog motivators, is entirely built using the Construct Algebra."]},{"title":"1 INTRODUCTION","paragraphs":["The dialog manager described in this paper implements a novel approach to the problem of dialog management. There are three major contributions: the task knowledge representation, a Construct Algebra and a collection of dialog motivators. The task knowledge representation exploits object-oriented paradigms. The dialog motivators provide the dialog manager with the dialog strategies that govern its behavior. The Construct Algebra provides the building blocks needed to create new dialog motivators and analyze them.","The first main component of this dialog manager is the task knowledge representation. The task knowledge is encoded in objects. These objects form an inheritance hierarchy that defines the relationships that exists among these objects. The dialog manager exploits this inheritance hierarchy in determining what queries to pose to the user. No explicit states and transitions need to be defined using this framework (Bennacef et al., 1996; Meng and et. al., 1996; Sadek et al., 1996). A change to the dialog does not require a change to the dialog manager, but more simply, a change to the inheritance hierarchy.","The second main component of this dialog manager is the collection of dialog motivators. The dialog motivators determine what actions need to be taken (e.g. ask a confirmation question). The dialog motivators are founded on a theoretical framework called a Construct Algebra. The Construct Algebra allows a designer to add new motivators in a principled way. Creating a new application requires defining the inheritance hierarchy and perhaps additional dialog motivators not encompassed in the existing collection.","This dialog manager has been used for two applications. The first is a spoken dialog system that enables a user to respond to the open-ended prompt"]},{"title":"How may I help you?","paragraphs":["(HMIHY) (Gorin et al., 1997). The system recognizes the words the customer has said (Riccardi and Bangalore, 1998) and extracts the meaning of these words (Wright et al., 1998) to determine what service they want, conducting a dialog (Abella and Gorin, 1997; Abella et al., 1996) to effectively engage the customer in a conversa-tion that will result in providing the service they requested. The second application is to Voice Post Query (VPQ) (Buntschuh et al., 1998) which provides spoken access to the information in large personnel database (> 120,000 entries). A user can ask for employee information such as phone number, fax number, work location, or ask to call an employee. These applications are"]},{"title":"signifi- 191","paragraphs":["cantly different but they both use the same dialog manager."]},{"title":"2 Task Representation","paragraphs":["Information about the task is defined using an object inheritance hierarchy. The inheritance hierarchy defines the relationships that exist amongst the task knowledge. Objects are defined to encode the hierarchy. This representation adheres to the principles of object-oriented design as described in (Booch, 1994). Each of the objects has three partitions. The first partition contains the name of the object, the second contains a list of variables with associated values that are specific to the object, and the third partition contains any methods associated with the object. For simplicity of illustration we will not include any of the methods. Each of the objects inherits its methods from a higher level object called the Construct. The Construct's methods are the relations and operations that will be described in section 4.","The result of the speech recognizer is sent to the spoken language understanding (SLU) module. The SLU module extracts the meaning of the user's utterance and produces a list of possible objects with associated confidence scores that is interpreted by the dialog manager. The dialog manager then uses the inheritance hierarchy and an algorithm 1 fully described in (Abella and Gorin, 1997) to produce a set of semantically consistent inputs to be used by the dialog manager. The input is represented as a boolean expression of constructs extracted from the utterance. This input is then manipulated by the dialog motivators to produce an appropriate action, which most of-ten consists of playing a prompt to the user or generating a query to a database."]},{"title":"3 The Construct","paragraphs":["A construct is the dialog knowledge representation manager's general","vehicle. The task","1An understanding of this algorithm is not necessary for the understanding of the work described in this paper. DIAL FOR ME :ORWARD NUMBER 555-1234"]},{"title":"I","paragraphs":["BILLING NULL Figure 1: A construct example for HMIHY knowledge is encoded as a hierarchy of constructs. The construct itself is represented as a tree structure which allows for the building of a containment hierarchy. It consists of two parts, a head and a body. Figure 1 illustrates a construct example for HMIHY. The DIAL_FOR_ME construct is the head and it has two constructs for its body, FORWARD_NUMBER and BILLING. These two constructs represent the two pieces of information necessary to complete a call. If a user calls requesting to place a call it is the DIAL_FOR_ME construct that is created with the generic BILLING construct and the FORWARD_NUMBER construct with its value set to empty. The dialog manager will then ask for the forward number and for the type of billing method. In figure 1 the dialog manager has received a response to the forward number request."]},{"title":"4 Construct Algebra","paragraphs":["The construct algebra defines a collection of elementary relations and operations on a set of constructs. These relations and operations are then used to build the larger processing units that we call the dialog motivators. The set of dialog motivators defines the application. In this section we formally define these relations and operations. 4.1 The Construct Definition 1 Head A head is an ordered pair <name, value>, where name belongs to some set of prede-192 fined names, N, and"]},{"title":"value","paragraphs":["belongs to some set of predefined values, V. A value may be NULL (not assigned a value). Definition 2 Construct"]},{"title":"A construct","paragraphs":["is defined recursively as an ordered pair"]},{"title":"<head, body>","paragraphs":["where"]},{"title":"body","paragraphs":["is a (possibly empty) set of constructs. 4.2","Relations The Construct Algebra defines six relations in the set of constructs. In each of the definitions, Cl and c2 are constructs. Note that the symbols C and C, introduced here, should not be understood in their usual \"subset\" and \"proper subset\" interpretation but will be described in definitions 4 and 5. Definition 3 Equality Two constructs are equal, denoted cl = c2 when"]},{"title":"head(c1) = head(c2)","paragraphs":["and"]},{"title":"body(c1)","paragraphs":["= body(c2) Definition 3 requires that the heads of c1 and c2 be equal. Recall that the head of a construct is an ordered pair"]},{"title":"<name, value>","paragraphs":["which means that their names and values must be equal. A value may be empty (NULL) and by definition be equal to any other value. The equality of bodies means that a bijective mapping exists from the body of cl into the body of c2 such that elements associated with this mapping are equal. Definition 4 Restriction Cl is a restriction of c2, denoted cl C c~, when"]},{"title":"head(c1) = head(c2)","paragraphs":["and (3f :"]},{"title":"body(c1) --+ body(c2))(fis","paragraphs":["1 to 1 A"]},{"title":"(Vbl • body(cl))(bl C_ f(bl))","paragraphs":["Intuitively, cl can be obtained by \"pruning\" elements of c2. The second part of the definition, (3f : ...) is what differentiates C from =. It is required that a mapping f be-tween the bodies of Cl and c2 exist with the following properties: [ ~RSON Cl C <"]},{"title":"\\","paragraphs":["PERSON \"\",,,. ........... , ADD ~ES s STREET ............................ ..- 3H(}NE NUMBEI c2 Figure 2: STREET and PHONE_NUMBER are \"pruned\" from c2 to obtain Cl.","• f is 1 to 1. In other words, different elements of the body of O, call them hi, are associated with different elements of the body of c2, call them b2","• The elements of the body of c1 are restrictions of the elements of the body of c2. In other words, bl C_ b2, where bl are elements from the body of Cl and b2 are elements from the body of c2.","Figure 2 illustrates an example. Definition 5 Containment cl is contained in c2, denoted Cl C c2, when Cl C_ c2 or"]},{"title":"(3b2 • body(c2))(Cl C","paragraphs":["52) We assume that c1 C c2 either if Cl is a restriction of c2 or if Cl is contained in any element of the body of c2. Figure 3 gives an example. The AMBIGUITY construct represents the fact that the system is not sure whether the user has requested a COLLECT call or a CALLING_CARD call. This would trigger a clarifying question from the dialog manager. 193"]},{"title":"?","paragraphs":["el C AMBIGUIT I 'k ............. \"\"¢2 ~'ALLING_CARD CARD NUMBEI~ 8485417 Cl BILLING C2 Figure 4: cj ¢--->c2 Figure 3: cl C c2 Definition 6 Generalization c2 is a generalization of el, denoted c1~__.~c2, when CALLING_CARD DIALFOR_ME head(cl)c--+head(c2) and (3f: body(c2) ~ body(c1)) (fis 1 to 1 A (Vba • body(c2)))(f(b2)~___b2)","The generalization of heads means that the name of c2 is on the inheritance path of cl and their values are equal. Intuitively, c2 is an ancestor of Cl or in object-oriented","C ~. terms ~C 1 is-a, 2 Note the similarity of this relation to C. Figure 4 illustrates an example. BILLING is a generalization of CALLING_CARD, or in other words CALLING_CARD is-a BILLING. Definition 7 Symmetric Generalization Cl is a symmetric generalization of c2, denoted cl ~ c2, when C1¢--->C2 or c2¢---~Cl This definition simply removes the directionality of __¢---~. In other words, either 'tE 1 iS-a C2\" 194"]},{"title":"?","paragraphs":["CARD_NUMBER 8485417 BILLING Cl c2 Figure 5: cl ¢--> c2 or ;;c2 is-a c1\" Definition 8 Containment Generalization Cl is a containment generalization of c2, denoted ci ¢---> c2, when b2 is contained in c2 and cl is a symmetric generalization of b2. An example is illustrated in figure 5. BILLING is contained in DIAL_FOR_ME and is a symmetric generalization of CALLING_CARD. 4.3 Operations The Construct Algebra consists of two operations union, U and projection, \\. Definition 9 Union (U) We will define this operation in several steps. Each step is a progression towards a more general definition. Definition 9.1 Union of values (vl U v2) V 1 U V 2 =","Vl, Vl = v2 and vl # NULL","v2, Vl = v2 and Vl = NULL","not defined, Vl # v2 Recall that by definition, NULL is equal to any other value. Definition 9.2 Union of heads We define"]},{"title":"head(c1) U head(c2)","paragraphs":["only in the case c] ¢-~c2, which is all that is needed for a definition of U."]},{"title":"head(c","paragraphs":["I"]},{"title":") U head(c2) : value(el) U vatue( ))","paragraphs":["Definition 9.3 (c, U c2) If c1~_~_c2, C 1 U C 2 ="]},{"title":"( head( c","paragraphs":["1"]},{"title":") U head(c2), u • body( )} u","paragraphs":["{bllbl • body(c 1) A (Vb2 •"]},{"title":"body(c2))(bl #/(b2))})","paragraphs":["In this definition the head of the resulting construct is the union of the heads of the operands. The body of the resulting construct consists of two parts. The first part is a set of unions (denoted f(b2)"]},{"title":"U","paragraphs":["b2 in the definition above) where b2 spans the body of the second operand c2 and f is a mapping from Definition 6. Recall that the mapping f associates elements of the"]},{"title":"body(c1)","paragraphs":["with elements of the"]},{"title":"body(c2)","paragraphs":["such that"]},{"title":"f(b2)~-+b2","paragraphs":["for"]},{"title":"b2 • body(c2)","paragraphs":["so the union"]},{"title":"f(bj","paragraphs":["U b2 is (recursively) defined in Definition 9.3. The second part of the body of the resulting construct consists of those elements bl of the"]},{"title":"body(c1)","paragraphs":["that no element from the"]},{"title":"body(c2)maps","paragraphs":["into through the mapping f. In other words, the second part of the body consists of those elements \"left"]},{"title":"CALLIN ¢ CARD-NUMB 1","paragraphs":["NULL u EXP|RATIO~ __ 299 / Cl"]},{"title":"_CARD :ALLI~ 1 CARD NlYMB~,","paragraphs":["1239834 = c2 Figure 6: cl"]},{"title":"U","paragraphs":["c2 if"]},{"title":"c1¢-.-~c2 LLINO_CARD ~","paragraphs":["ARD_NUMBER 1239834","EXPIRATIO1 ~ 299 behind\" in the"]},{"title":"body(cl)","paragraphs":["after the mapping f. Figure 6 illustrates an example. The union operations results in a construct with the head CALLING_CARD and a body that contains both CARD_NUMBER and EXPIRATION. The CARD_NUMBER construct from Cl and c2 can be combined because the value of CARD__NUMBER from cl is NULL. The construct EXPIRATION is added because it does not exist on the body of c2. Definition 9.4 Cl U c2 If C 1 ,-v C2,"]},{"title":"ciUc2,","paragraphs":["ci ~-+c2 C 1 U ¢2 = C 2 U el, C2 ~ C1 Definition 9.5 cl U c2 If cl ~-+ c2, C 1 U c 2 =","C 1 U c2,"]},{"title":"(head(c2),","paragraphs":["{el U"]},{"title":"b~lb~ • body(c2)","paragraphs":["A cl ~"]},{"title":"b2}U {b2152 • body(c2) ̂Cl b£),","paragraphs":["C1 ,\"-' C2 C1 ~ C2 Figure 7 illustrates this union. The head of the resulting construct is the head of c2 which is DIAL_FOR_ME. The resulting construct no longer has BILLING but 195 :ALLING CARD EXPIRATION AL ~ORWARD~NUMB FZ~ BILLING [ Cl C2 DIAL_FOR_ME ~LLING_CARD ARD_NUMBEI EXPIRATION ! Figure 7: Cl I.J C2 if cl ~ c2 rather CALLING_CARD since BILLING is a generalization of CALLING_CARD. In addition the resulting construct contains the construct FORWARD_NUMBER because it remains from DIAL_FOR_ME.","Definition 9.6 Cl U e2","In the general case,","C1 ~ C2 -~- el [,-J e2, c2 [..J Cl, ((REP, NULL), {cl, c2}), C1 ~ C2","e2 ~ el","Cl ~ C2 and","C2 ~ Cl In this definition REP is a construct used to represent the union of those constructs that do not satisfy any of the aforementioned conditions. By definition REP has a value of NULL and the body consists of the constructs Cl and e2. Definition 10 Projection (\\)","CI\\C 2 ~-. ((AMBIGUITY, NULL), {hi U c2161 C c1 A bl ~- c2}) e2 ¢-+ cl Cl C2 ~ el Figure 8 illustrates an example of an ambiguous construct and the result of the FIRST NA] C2 C1\\C2 Figure 8: Projection operation example projection operation. The construct is AMBIGUITY because all the elements of its"]},{"title":"body","paragraphs":["have the value of 6151 for DEPT. In this example, c2 contains the construct LAST_NAME with the value of Smith. There are 2 constructs on the body of Cl that are in the relation"]},{"title":"b2","paragraphs":["C Cl, in other words have value for LAST_NAME of Smith. Therefore the result is an AMBIGUITY construct with two elements on its body, both with the LAST_NAME value of Smith."]},{"title":"5 Dialog Motivators","paragraphs":["A dialog motivator determines what action the dialog manager needs to take in conducting its dialog with a user. The dialog manager for HMIHY currently consists of 5 dialog motivators. They are"]},{"title":"dis- ambiguation , confirmation, error handling","paragraphs":["(recovery from misrecognition or misunderstanding and silence),"]},{"title":"missing information","paragraphs":["and"]},{"title":"context switching.","paragraphs":["VPQ uses two additional motivators, they are"]},{"title":"continuation","paragraphs":["and 196 co: Construct used for disambiguation, cQ Ec CA: User response"]},{"title":"Dk(c, cigK) =","paragraphs":["c, c ~ AMBIGUITY Dk+l (c, CIDK), CA ~__~_ERROR Dk+l"]},{"title":"(C,","paragraphs":["CID g (.J CQ), c A IDK C\\CA, C A ¢-----} C C A C A ~ C Figure 9: Disambiguation Motivator database querying.","The disambiguation motivator determines when there is ambiguous semantic information, like conflicting billing methods. Confirmation is used when the SLU returns a result with low confidence. Error handling takes on three forms. There is error recovery when the speech recognizer has likely misrecognized what the user has said (low confidence scores associated with the recognition results), when the user falls silent, and when the user says something the SLU does not expect or does not handle. Missing information determines what information to ask about in order to complete a transaction. Context switching is the ability of the system to realize when the user has changed his/her mind or realizes that it has misunderstood and allows the user to correct it. The continuation motivator determines when it is valid to offer the user the choice to query the system for additional information. Database querying decides when the system has acquired enough information to query a database for the requested information. 5.1","Disambiguation Motivator Figure 9 illustrate how the disambiguation motivator is created using the Construct Algebra. The disambiguation motivator is called with the current construct c and a set of constructs called CID g that represents information that the user does not know (IDK - \"I Don't Know\"), in other words, the user explicitly responds to a prompt with the phrase \"I don't know\" or its equivalent s. 2The phrases chosen are based on trials Input: A sequence of semantic input from the SLU module in response to a prompt Output: Complete construct c (no need for further dialog)"]},{"title":"Repeat","paragraphs":["For all dialog motivators DMI","if DMi applies to c","Perform action(DMi,c)","Apply Dialog Manager to get CA","Using Construct Algebra,","combine c and CA into c","Until no motivator applies","Return c Figure 10: Dialog Manager algorithm The motivator runs through several checks on the construct c. The first is to check to see if in fact the motivator applies, or in other words if c is a restriction of AMBIGUITY. If it is not then the motivator simply return c without changing it. The second step is to check to see if the ERROR construct is a generalization of CA where CA represents the user's response. The ERROR construct represents an error condition like silence or misrecognition. If it is, then it goes on to next motivator because this motivator does not apply to error conditions. If CA equals the IDK construct then this means that the user did not know the answer to our query and we add the construct used for disambiguation, cQ to the set of constructs ¢IDK. If however, CA is in the containment generalization relation with c then the projection operation is applied and the result is returned. If CA is not in this relation then this indicates a context switch on the part of the user and the disambiguation motivator returns CA as the result.","All other motivators are constructed in a similar fashion. An application can use these motivators or create new ones that are application specific using the operations and relations of the Construct Algebra. 197 System\" VPQ. What can I do for you? User: I need the phone number for Klein. System- I have more than 20 listings for Klein. Can you please say the first name? User: William. System\" I have 2 listings for William Klein. Can you tell me the person's work location? User: Bedminster System\" The phone number for William Klein is 973 345 5432. Would you like more information? User: No. System\" Thank you for using VPQ. Figure 11: A sample dialog for VPQ"]},{"title":"6 Dialog Manager","paragraphs":["The input to the dialog manager is a collection of semantic input generated by the SLU. Figure 10 illustrates the algorithm used by the dialog manager. The output is the complete construct c which no longer requires further dialog. The algorithm loops through all the dialog motivators determining which one needs to be applied to c. If it finds a motivator that applies then it will perform the necessary action (e.g. play a prompt or do a database lookup). The algorithm repeats itself to obtain CA (the construct answer). In other words, the construct that results from the action is subject to the dialog motivators starting from the beginning. Once CA has been found to be complete it is combined with c using Construct Algebra to produce a new construct. This new construct c also goes through the loop of dialog motivators and the procedure continues until no motivator applies and the algorithm returns the final construct c. 6.1 Example To illustrate how the dialog manager functions we will use an example from VPQ. Figure 11 illustrates a sample dialog with the system. The sequence of motivators for"]},{"title":"VPQ","paragraphs":["is error handling, confirmation, miss-ing information, database querying and disambiguation. The construct that is created as a result of the user's initial utterance is shown in figure 12. All the information needed to do a database lookup is found in the user's utterance, namely the piece of information the user is seeking and the name of the person. Therefore the first motivator that applies is database querying. This motivator creates the database query and based on the result creates the construct CA. The construct CA is then searched by each of the motivators beginning again with error handling. The motivator that applies to CA is the disambiguation motivator because there are more than 20 people in the database whose last name is pronounced Klein, in-cluding Klein, Cline and Kline. The disambiguation motivator searches through CA to determine, based on preset parameters, which piece of information is most useful for the disambiguation process as well as which piece of information the user is likely to know, which is selected when the inheritance hierarchy is designed. For VPQ this includes asking about the first name and work location. In this example the dialog manager searches the database entries and determines that the most discriminating piece of information is the first name. Once the user responds with the first name there are still 2 possible candidates and it asks for the next piece of information which is work location. Had the user not known the work location the system would have read out the phone number of both people since the total number of matches is less than 3. If the number of entries after disambiguation remains greater than 3 the system refers the user to a live operator during work hours."]},{"title":"7 Conclusion","paragraphs":["In this paper we have described a novel approach to dialog management. The task knowledge representation defined intuitively and without the need to define call flows in the traditional finite-state approach. The Construct Algebra serves as the building blocks from which the dialog motivators that drive the dialog system are comprised. Building a new application will only require the designer to define the objects (e.g. COL-198"]},{"title":"Figure 12: Sample construct for VPQ. LECT, CREDIT etc.) and the inheritance hierarchy. The Construct Algebra serves as an analytical tool that allows the dialog mo- tivators to be formally defined and analyzed and provides an abstraction hierarchy that hides the low-level details of the implemen- tation and pieces together the dialog motiva- tors. This same dialog manager is currently being used by two very different applications (HMIHY and VPQ). A.L. Gorin, G. Riccardi, and J.H. Wright. 1997. How May I Help You? Speech Com- munciation. Helen Meng and Senis Busayapongchai et. al. 1996. Wheels: A conversational sys- tem in the automobile classifieds domain. International Conference on Spoken Lan- guage Processing. G. Riccardi and S. Bangalore. 1998. Au- tomatic acquisision of phrase grammars for stochastic language modeling. In Proc. ACL Workshop on Very Large Corpora, Montreal. M.D. Sadek, A. Ferrieux, A. Cozannet, P. Bretier, F. Panaget, and J. Simonin. 1996. Effective Human-Computer Co- operative Spoken Dialogue: the AGS Demonstrator. International Conference on Spoken Language Processing. Jerry Wright, Allen L. Gorin, and Alicia Abella. 1998. Spoken language under- standing within dialogs using a graphical model of task structure. In Proc. ICSLP Sydney. References","paragraphs":["/"]},{"title":"Alicia Abella and Allen L. Gorin. 1997. Generating semantically consistent inputs to a dialog manager. In Proc. EuroSpeech Rhodes, Greece. A. Abella, M. K. Brown, and B. Buntschuh. 1996. Development principles for dialog- based interfaces. European Conference on Artificial Intelligence. S. Bennacef, L. Devillers, S. Rosset, and L. Lamel. 1996. Dialog in the rail- tel telephone-based system. International Conference on Spoken Language Process- ing. Grady Booch. 1994. Object-Oriented Anal- ysis and Design with Applications. Ben- jamin Cummings. B. Buntschuh, C. Kamm, G. DiFabbrizio, A. Abella, M. Mohri, S. Narayan, I. Zelj- vokic, R.D. Sharp, J. Wright, S. Marcus, J. Shaffer, R. Duncan, and J.G. Wilpon. 1998. VPQ: A spoken language interface to large scale directory information. In Proc. ICSLP Sydney. 199","paragraphs":[]}]}
