{"sections":[{"title":"","paragraphs":["TRANSLATING ENGLISH INTO LOGICAL FORM'","Stanley J. Rosenscbein Stuart M, Shieber ABSTRACT","A scheme for syntax-directed translation that mirrors compositional model-theoretic semantics is discussed. The scheme is the basis for an English translation system called PArR and was used to specify a semantically interesting fragment of English, including such constructs as tense, aspect, modals, and various iexically controlled verb complement structures. PATR was embedded in a question-answering system that replied appropriately to questions requiring the computa-tion of logical entailments. I INTRODUCTION","When contemporary linguists and philosophers speak of \"semantics,\" they usually mean m0del-theoretic semantics-- mathematical devices for associating truth conditions with Sentences. Computational linguists, on the other hand, often use the term \"semantics\" to denote a phase of processing in which a data structure (e.g., a formula or network) is constructed to represent the meaning of a sentence and serve as input to later phases of processing. {A better name for this process might be \"translation\" or \"traneduction.\") Whether one takes \"semantics\" to be about model theory or translation, the fact remains that natural languages are marked by a wealth of complex constructions--such as tense, aspect, moods, plurals, modality, adverbials, degree terms, and sententiai complemonts--that make semantic specification a complex and challenging endeavor.","Computer scientists faced with the problem of managing software complexity have developed strict design disciplines in their programming methodologies. One might speculate that a similar requirement for manageability has led linguists (since Montague, at least) to follow a discipline of strict compositiouality in semantic specification, even though model*theoretic semantics per me does not demand it. Compositionaiity requires that the meaning of a pbrase be a function of the meanings of its immediate constituents, a property that allows the grammar writer to correlate syntax and semantics on a rule-by-rule basis and keep the specification modular. Clearly, the natural analogue to compositionality in the case of translation is syntax-directed trans-"]},{"title":"lation;","paragraphs":["it is this analogy that we seek to exploit.","We describe a syntax-directed translation scheme that bears a close resemblance to model-theoretic approaches and achieves a level of perspicuity suitable for the development of large and complex grammars by using a declarative format for specifying grammar rules. In our formalism, translation types are associated with the phrasal categories of English in much the way that logical-denotation types are associated Artificial Intelligence Center","SRI International 333 Raveoswood Avenue Menlo Park, CA 94025 with phrasal categories in model-theoretic semantics. The translation 'types are classes of data"]},{"title":"objects","paragraphs":["rather than abstract"]},{"title":"denotations,","paragraphs":["yet they play much the same role in the translation process that denotation types play in formal semantics.","In addition to this parallel between logical types and translation types, we have intentionally designed the language in which translation rules are stated to emphasize parallels between the syntax-directed translation and corresponding model-theoretic interpretation rules found in, say, the GPSG literature [Gazdar, forthcoming]. In the GPSG approach, each syntax rule has an associated semantic rule (typically involving functional application) that specifies how to compose the meaning of a phrase from the meanings of its constituents. In an analogous fashion, we provide for the translation of a phrase to be synthesized from the translations of its immediate constituents according to a local rule, typically involving symbol/c"]},{"title":"application and","paragraphs":["~-conversiou.","It should be noted in passing that doing translation rather than model theoretic interpretation offers the temptation to abuse the formalism by having the \"meaning\" (translation) of a phrase depend on syntactic properties of the translations of its constituents--for in-stance, on the order of conjuncts in a logical expression. There are several points to be made in this regard. First, without severe a priori restrictions on what kinds of objects can be translations (coupled with the associated strong theoretical claims that such restrictions would embody) it seems impossible to prevent such abuses. Second, as in the case of programming languages, it is reasonable to mmume that there would emerge a set of stylistic practices that would govern the actual form of grammars for reasons of manageability and esthetics. Third, it is still an open question whether the model*theoretic program of strong compositiouality will actually succeed. Indeed, whether it succeeds or not is of little concern to the computational linguist, whose systems, in any event, have no direct way of using the sort of abstract model being proposed and whose systems must, iu general, be based on deduction (and hence translation).","The rest of the paper discusses our work in more detail. Section II presents the grammar formalism and describes PATR, an implemented parsing and translation system that can accept a grammar in our formalism and uses it to process sentences. Examples of the system's operation, including its application in a simple deductive question-answering system, are found in Section HI. Finally, Section IV describes further extensions of the formalism and the parsing system. Three appendices are included: the first contains sample grammar rules; the second contains meaning postulates (axioms) used by the question-answering system; the third presents a sample dialogue session. \"This research wns supported by the Defense Advanced Research Projects Agency under Contract N000SO-SO-C.-0575 with the Naval Electronic Systems Conunand. The views and conclusions contained in this document are those of the authors and should not be interpreted ns representative of the ol~cial policies, either expres~.d or implied, of the Defense Ad~eanced Research Projects Agency or the United States Government."]},{"title":"il A GRAMMAR FORMALISM A General Characterization","paragraphs":["Our grammar formalism is beet characterized as n specialized type of augmented context-free grammar° That is, we take a grammar to be a set of context-fres rules that define a language and associate structural descriptions (parse trees) for each sentence in that language in the usual way. Nodes in the parse tree are assumed to have a set of features which may assume binary values"]},{"title":"(True","paragraphs":["or"]},{"title":"False),","paragraphs":["and there is a distinguished attribute--the \"translation'--whoee values range over a potentially infinite set of objects, i.e., the translations of English phrases.","Viewed more abstractly, we regard translation as a binary relation between word sequences and logical formulas. The use of a relation is intended to incorporate the fact that many word sequences have several logical forms, while some have none at all. Furthermore, we view this relation as being composed (in the mathematical sense) of four simpler relations corresponding to the conceptual phases of analysis: (1) LEX (lexical analysis), (2) PARSE (parsing), (3) ANNOTATE (assignment of attribute values, syntactic filtering), and (4) TRANSLATE (translation proper, i.e., synthesis of logical form).","The domains and ranges of these relations are as follows: Word Sequences"]},{"title":"-LEX-*","paragraphs":["Morpheme Sequences -PARSE-* Phrase Structure Trees"]},{"title":"-ANNOTATE-*","paragraphs":["Annotated Trees"]},{"title":"-TRANSLATE-*","paragraphs":["Logical Form The relational composition of these four relations is the full translation relation associating word sequences with logical forms. The subphases too are viewed as"]},{"title":"relations","paragraphs":["to reflect the inherent nondeterminism of each stage of the process. For example, the sentence =a hat by every designer sent from Paris was felt\" is easily seen to be nondeterministic in LEX ('felt'), PARSE (poetnominal modifier attachment), and TRANSLATE (quantifier scoping).","It should be emphasized that the correspondence between"]},{"title":"processing","paragraphs":["phases and these conceptual phases is loose. The goal of the separation is to make specification of the process perspicous and to allow simple, clean implementations. An actual system could achieve the net effect of the various stages in many ways, and numerous optimizatious could be envisioned that would have the effect of folding back later phases to increase efficiency."]},{"title":"B The Relations LEX, PARSE, and ANNOTATE","paragraphs":["We now describe a characteristic form of specification ap-RULES:"]},{"title":"constant","paragraphs":["corn,'"]},{"title":"- (~ e (X Q CX x CP CQ x))))) S--* NPVP","paragraphs":["Truss: VP' [NP'] VP -* T~qSEV Aano: [-~Transitivo(V) ]"]},{"title":"Tr,=,: { couP'","paragraphs":["[~']"]},{"title":"t~'] }","paragraphs":["lEXICON: If -* John Aano: [Proper(W) ]"]},{"title":"Truss: { John } TENSE","paragraphs":["-* &put"]},{"title":"Trash: { (X x CpastX)) } V-*go","paragraphs":["Anon: [ -~Trasnitivn(V) ]"]},{"title":"Trnn: { C~ x Can x)) }","paragraphs":["Figure"]},{"title":"1:","paragraphs":["Sample specification of augmented phrase structure grammar propriate to each phase and illustrate how the word sequence \"John went\" is analyzed by stages as standing in tbe translation relation to \"(past (go john))\" according to the (trivial) grammar presented in Figure 1.","Lexieal analysis is specified by giving a kernel relation between individual words and morpheme sequences I (or equivalently, a"]},{"title":"mapping","paragraphs":["from words to sets of morpheme sequences), for example: John -* (john) : vent -* (kput go) : persuaded -+ (kput persuade) o","(kppl persuadn) :","The kernel relation is extended in a standard fashion to the full LEX relation. For example, \"went\" is mapped onto the single morpheme sequence (&past go), and \"John\" is mapped to (john). Thus, by extension, \"John went\" is transformed to (John &post go) by the lexical analysis phase. Parsing is"]},{"title":"specified","paragraphs":["in the usual manner by a context-free grammar. Utilizing the eontext,-free rules presented in the sample system specification shown in Figure 1, (John 8cpast go) is transformed into the parse tree (S (NP john)"]},{"title":"C~ (r~rsE tput) Cvso)))","paragraphs":["Every node in the parse tree has a set of associated features. The purpo6e of ANNOTATE is to relate the bate parse tree to one that has been enhanced with attribute values, filtering out three that do not satisfy stated syntactic restrictions. These restrictions are given as Boolean expressions associated with the context-free rules; a tree is properly annotated only if all the Boolean expressions corresponding to the rules used in the analysis are simultaneously true. Again, using the rules of Figure 1, lof course, more sophisticated spprotehe~ to morpholoslesl sualysls would seek to analyze the LEX relgtion more fully. See, for example, ~Kartunnen, lgS2J gad [Ksplan, 19811. (s (SP john) (W (~ aput) (V go)) ) is transformed into","(S (NP: Proper john) (W : \"~ Trandlive (~ ~aet) (V: -Transitive go)))"]},{"title":"C The Relation TRANSLATE","paragraphs":["Logical-form synthesis rules are specified as augments to the context-free grammar. There is a language whose expressions denote translations (syntactic formulas); an expression from this language is attached to each context-free rule and serves to define the composite translation at a node in terms of the translations of its immediate constituents. In the sample sentence, TENSE' and V' {the translations of TENSE and V respectively) would denote the ),-expressions specified in their respective translation rules. VP' {the translation of the VP) is defined to be the value of (SAP (SAP COMP' TENSE') V'), where COMF' is a constant k-expression and SAP is the symbolic-application operator. This works out to be (k X [past (go X))). Finally, the symbolic application of VP' to N'P' yields (past (go John)). (For convenience we shall henceforth use square brackets for SAP and designate (SAP a ~) by a[~].)","Before describing the symbolic-application operator in more detail, it is necessary to explain the exact nature of the data objects serving as translations. At one level, it is convenient to think of the translations as X-expressions, since X-expressions are a convenient notation for specifying how fragments of a translation are substituted into their appropriate operator-operand positions in the formula being assembled-especially when the composition rules follow the syntactic structure as encoded in the parse tree. There are several phenomena, however, that require the storage of more information at a node than can be represented in a bare k-expression. Two of the most conspicuous phenonema of this type are quantifier scoping and unbounded dependencies (\"gaps\").","Our approach to quantifier scoping has been to take a version of Cooper's storage technique, originally proposed in the context of model-tbeoretic semantics, [Cooper, forthcoming[ and adapt it to the needs of translation. For the time being, let us take translations to be ordered pairs whose first component (the head) is an expression in the target language, characteristically a k-expression. The second component of the pair is an object called storage, a structured collection of sentential operators that can be applied to a sentence matrix in such a way as to introduce a quantifier and \"capture\" a free variable occurring in that sentence matrix. 2","For example, the translation of \"a happy man\" might be < m , (X S (some m (and (man m)(happy m)) S)) >.s Here the head is m (simply a free variable), and storage consists of the X-expression (k S 2in the sample grammar presented in Appendix A, the storage.formlng operation is notated mk.mbd. 3Followlng [Moore, lO80~, a quantified expression is of the form (quauti6er, variable, restriction, body) ...). If the verb phrase \"sleeps ~ were to receive the translation < (X X (sleep X)), ~ > (i.e., a unary predicate as head and no storage), then the symbolic application of the verb phrase translation to the noun phrase translation would compose the heads in the usual way and take the \"uniou\" of the storage yielding < (sleep m), (k S (some m (and (man m)(happy m)) S)) >.","We define an operation called ~pull.s,\" which has the effect of \"pulling\" the sentence operator out of storage and applying it to the head. There is another pull operation, pull.v, which operates on heads representing unary predicates rather than sentence matrices. When pull.s is applied in our example, it yields < (some m (and (man m)(happy m)) (sleep m)), ~b >, corresponding to the translation of the clause ~a happy man sleeps.\" Note that in the process the free variable m has been \"captured.\" In model-theoretic semantics this capture would ordinarily be meaningless, although one can complicate the mathematical machinery to achieve the same effect. Since translation is fundamentally a syntactic process, however, this operation is well-defined and quite natural.","To handle gaps, we enriched the translations with a third component: a variable corresponding to the gapped position. For example, the translation of the relative clause \".,.[that] the man saw\" would be a triple: < (past (see X Y)), Y, (k S (the X (man X) $))>, where the second component, Y, tracks the free variable corresponding to the gap. At the node at which the gap was to be discharged, X-abstraction would occur (as specified in the grammar by the operation \"uugap') producing the unary predicate (X Y (past (see X Y))), which would ultimately be applied to the variable corresponding to the head of the noun phrase.","It turns out that triples consisting of (head, var, storage) are adequate to serve as translations of a large class of phrases, but that the application operator needs to distinguish two subcases (which we call type A and type B objects). Until now we have been discussing type A objects, whose application rule is given (roughly) as","< hal,vat,san>l< hal',vat',san'>[ -~ <(hd hd'),var LI var', sto i3 sto'> where one of vat or vat' must be null. In the ease of type B objects, which are assigned primarily as translations of determiners, the rule is","< h d,var ,san > [< hd',var',sto' >]","= <var, var', hd(hd') U sto U sto'> For example, if the meaning of \"every\" is","every' ~- <(k P (X S (every X (P X) S))), X, ~b> and the meaning of ~man\" is man' ---- < man, ~, ~ > then the meaning of \"every man\" is","every'[man'] = ( X , ¢, (X S (man X) S)> , as expected.","Nondeterminism enters in two ways. First, since pull opera, tions can be invoked nondeterministically at various nodes in the parse tree (as specified by the grammar), there exists the possibility of computing multiple scopings for a single context-free parse tree. (See Section III.B for an example of this phenomenon.) In addition, the grammar writer can specify explicit nondeterminism by associating several distinct translation rules with a single context-free production. In this case, he can control the application of a translation schema by specifying for each schema a guard, a Boolean combination of features that the nodes analyzed by the production must satisfy in order for the translation schema to be applicable. D Implementation of a Translation System","The techniques presented in Sections H.B and II.C were implemented in a parsing and translation system called PATR which was used as a component in a dialogue system discussed in Section III.B. The input to the system is a sentence, which is preprocessed by a lexical analyzer. Parsing is performed by a simple recursive descent parser, augmented to add annotations to the nodes of the parse tree. Translation is then done in a separate pass over the annotated parse tree. Thus the four conceptual phases are implemented as three actual processing phases. This folding of two phases into one was done purely for reasons of efficiency and has no effect on the actual results obtained by the system. Functions to perform the storage manipulation, gap handling, and the other features of translation presented earlier have all been realized in the translation component of the running system. The next section describes an actual grammar that has been used in conjunction with this translation system.","III EXPERIMENTS IN PRODUCING AND USING LOGICAL FORM A A Working Grammar","To illustrate the ease with which diverse semantic features could be handled, a grammar was written that defines a semantically interesting fragment of English along with its translation into logical form [Moore, 1981]. The grammar for the fragment illustrated in this dialogue is compact occupying only a few pages, yet it gives both syntax and semantics for modais, tense, aspect, passives, and lexically controlled infinitival complements. (A portion of the grammar is included as Appendix A.) 4 The full test grammar, Io,~ely based on DIAGRAM [Robinson, 1982] but restricted and modified to reflect changes in a~ proach, was the grammar used to specify the translations of the sentences in the sample dialogue of Appendix C. B An Example of the System's Operation","The grammar presented in Appendix A encodes a relation between sentences and expressions in logical form. We now present a sample of this relation, as well as its derivation, with a sample sentence: \"Every man persuaded a woman to go.\" Lexical analysis relates the sample sentence to two morpheme streams: every man &ppi persuade a woman to go 4Since this is just a small portion of the actual grammar selected for expository purposes, many of the phrasal categories and annotations will seem unmotivated and needlessly complex. These categories and annotations m'e utilized elsewhere in the test grammar. *, every man ,~past persuade a woman to go. The first is immediately eliminated because there is no context-free parse for it in the grammar. The second, however, is parsed as","[S (SDEC (NP (DETP (DDET (VET every)))","C~u CN0m~V (SOUN Cs re,a)))))","(Pn~ICar~ (*u~ (TE~E kpaat))","(VPP (V? CV?T (Vpersuado)))","(~ (DET? CA a))","(~u (Nnm~ (~vtm CN womm)))))","(INFINITIVE (TO to)","CV~ Cv? CWT CV go]","While parsing is being done, annotations are added to each node of the parse tree. For instance, the NP -* DETP NOM rule includes the annotation rule AGREE( NP, DETP, Definite ). AGREE is one of a set of macros defined for the convenience of the grammar writer. This particular macro invocation is equivalent to the Boolean expression Definite(NP) ~ Definite(DETP). Since the DETP node itself has the annotation Definite as a result of the preceding annotation process, the NP node now gets the annotation Definite as wello At the bottom level, the Definite annotation was derived from the lexical entry for the word \"evesy'. s The whole parse tree receives the following annotation:","[S Cb'~O (lqP: Delinite","(DETP: DeBnite","CDDET: DeBnite","(DET: DeBuite eve1\"y) ) )","CNOU (stump CNO~ CSm~)))))","CPR~ICATE CAU~ CTENSE ~put))","(VPP CVP: Active (VPT: Active, Ttansitlve, Takesln?","(V: Active, Transitive, Takesfn[","porsuade) ) ) 0~' (DET? CA a) ) CNOU C~la'~ C~ml C~ ,,on~))))) CDr~ISZTZ'W (TO to) (vPP (w: Active","(VPT: Active","Cv: Active","sol","Finally, the entire annotated parse tree is traversed to assign translations to the nodes through a direct implementation of the process described in Section II.C. (Type A and B objects in the following examples are marked with a prefix 'A:' or 'B:'.) For instance, the VP node covering (persuade a woman to go), has the translation rule VPT'[N'P'][INFINITIVE']. When this is applied to the translations of the node's constituents, we have CA: CA X CA P (~ T (persuade ¥ X (P X)))~ [,CA: X2. ~,. C~ S (some X2 Cwomu X2) S))~] [cA: (~x C~x))~] which, after the appropriate applications are performed, yields CA: CAP (~Y (persuade YX2 CPX2)))). ~, (A S (some X2 (~- X2) S))~ 5Note that, although the annotation phase was described and is implemented procedurally, the process actually used guarantees that the resulting annotation is ex\" \"t|y the one specified declaratlve~y by the annotation rules. [o,: (A x (gox))>] = CA: ()/¥ (persuadeTX2 (goX2))). ~b,","CA S (some X2 (roman X2) S))~","After the past operator has been applied, we have <A: CA T (pant (persumde YX2 (goX2)))). ~b,","CA S (some X2 (~znu X2) S)))","At this point, the pull operator (pull.v) can be used to bring the","quantifier out of storage, yielding 6 <A: CA Y (some ~2 (womb ][2) (pant (peramado T~ (go Yg))))). This will ultimately result in \"a woman\" getting narrow scope. The other alternative is for the quantifier to remain in storage, to be pulled only at the full sentence level, resulting in the other scoping. In Figure 2, we have added the translations to all the nodes of the parse tree. Nodes with the same translations as their parents were left unmarked. From examination of the S node translations, the original sentence is given the fully-scoped translations","(every X2 (man ](2) (some Xi (woman Xi) (paSt (persuade %,9 X! (go Xl))))) and","(some XI (vo~ Xl) (every X~2 (nan X2) (pant (persuade X2 Xl (go Xl) ))) )"]},{"title":"C A Simple Question-Answering System","paragraphs":["As mentioned in Section I, we were able to demonstrate the semantic capabilities of our language system by assembling a small question-answering system. Our strategy was to first translate English into logical formulas of the type discussed in [Moore, 1981], which were then postprocessed into a form suitable for a first-order deduction system. 7 (Another possible approach would have been to translate directly into first-order logic, or to develop direct proof procedures for the non-first-order language.) Thus, we were able to integrate all the components into a question-answering system by providing a simple control structure that accepted an input, translated it into logical form, reduced the translation to first-order logic, and then either asserted the translation in the case of declarative sentences or attempted to prove it in the case of interrogatives. (Only yes/no questions have been implemented.)","The main point of interest is that our question-answering system was able to handle complex semantic entailments involving tense, modality, and so on--that, moreover, it was not restricted to extensional evMuation in a data base, as with conventional question-answering systems. For example, our system was able to handle the entailments of sentences like","John could not have been persuaded to go. (The transcript of a sample dialogue is included as Appendix C.) 6For convenience, when a final constituent o1' a translation is ~ it is often not written. Thus we could have written <A: (k Y (some ...) ...)> in this cue. 7We used a connection graph theorem prover written by Mark Stickel [Stlckel, forthcoming].","(S: <A: (pant (persuade XI X2 (go ~))). ~. (A S (every X1 (nan X1) S)) ()~ S (some ~ (veto ][2) S))>,","<A: (some ][2 (~man X2) (past Cpersua4e X1 Y,2 (go Yo)))) 0 ~. (~ 8 (every Zl (man ][I) S))> <A: (everyX2 CnanX2)","(some XI (woman X1) (pant (persuade X2 Xl (go Y~)) )))> cA: (sou Xl (wuan X1)","(every ][2 (man X2) (pant (p0rsuade X2 li (go ][2)) ) )) >","(SV~","(NP: <A: Xl. ~. (A S (everyXl (muXl)S))) CDKTP: ¢~: CA P (~ S (every X (PI) S))).","X~ (DDET (DET every))) (NDU: cA: CA X (man X))) (None (Nmm (x m~n)))))","(PREDICATE: <A: (AX (past (persuade YX2 (goX2)))). ~b.","CA S (some X2 (woma X2) S))),","<X: CA X (son X2 (woeanX2)","(pant (persuade YX2 (goX2))))).","(AU~P: o,: CA P CA X (pant (P x))))>","C'X'~ a~,,.t))","(VPP: <A: (A ¥ (persuade ¥ ][2 (go ][2))). ~b. CA S (some X2 (wn--X2) S))~","(VP (VPT: cA: (XX","CA P","()~ Y (persuade ¥X (P ¥)))) (V persuade))) (~: cA: X2. ~, CA S (someX2 (wona Z2) S))~ (DETP: <S: (kP (AS (SoNX (PX) S))).","X~ CA n)) (~li: (A: (XX (wommX))> (N0~ (N0uw (w ,mm~))))) (INFINITIVE (TO: none","to)","(VPP: ca: (>,X (goX))>","(w (vPT (v so]","Figure 2:. Node-by-node translation of a sample sentence","The reduction of logical form to first-order logic (FOL) was parameterized by a set of recursive expansions for the syntactic elements of logical form in a manner similar to Moore's use of an sxiomatization of a modal language of belief. [Moore, 1980] For example, (past P) is expanded, with respect to a possible world w, as (some w2 (and (past w2 w) <P,w2>)) where \"<P,w2>\" denotes the recursive FOL reduction of P relative to the world w2. The logical form that was derived for the sample sentence \"John went ~ therefore reduces to the first-order sentence (some w (and (past w REALWORLD)(go w John))). More complicated illustrations of the results of translation and reduction are shown in Figure 3. Note, for example, the use of restricted quantification in LF and ordinary quantification in FOL.","To compute the correct semantic entailments, the deduction system was preloaded with a set of meaning postulates (axioms) giving inferential substance to the predicates associated with lexical items (see IMrffT: every ntanus~ be happy iF: (everyX (m X)","(tacosnry (tad (happy X)"]},{"title":"(thlngX)))) FOL:","paragraphs":["(every x0172","(implies (mtuREALWORLDxOI72) (overywO173 (implies (posnBEALgORLD~173)","(tad (happy~O175zOt72)","(~hi~Ot73z0172))))))","II~UT: bill persuaded john to go","iF: (ptat (porsutde bill john (go john)))","FOL: (some s0175","(ud (pant w0175 RF..AL|QP.LD)","(sou wOrTS","(Imd (permaade w0175"]},{"title":"bill","paragraphs":["John wOlT§) (go wOlTe John))))) Figure 3: Translation to LF and Reduction to FOL Appendix B)."]},{"title":"IV FURTHER EXTENSIONS","paragraphs":["We are continuing to refine the grammar formalism and improve the implementation. Some of the refinements are intended to make the annotations and translations easier to write. Examples include: Allowing nonbinary features, including sets of values, in the annotations and guards (extending the language to include equality and set operations). Generalizing the language used to specify synthesis of logical forms and developing a more uniform treatment of translation types. Generalizing the \"gap* variable feature to handle arbitrary collections of designated variables by using an \"environment\" mechanism. This is useful in achieving a uniform treatment of free word order in verb complements and modifiers. In addition, we are working on extensions of the syntactic","machinery, including phrase-linking grammars to handle displacement","phenomena [Peters, 1981], and methods for generating the augmented","phrase structure grammar through a metarule formalism similar to","that of [Konolige, 1980]. We have also experimented with alternative","parsing algorithms, including a chart parser [Bear, 197g] adapted to","carry out annotation and translation in the manner described in this","paper."]},{"title":"REFERENCES","paragraphs":["Bear, John, and Lanri Karttunen. PSG: A Simple Phrase Structure Parser. Texas Linguistic Forum, vol. 14. 1979. Cooper, Robin. Quantification and Syntactic Theory. Forthcoming. Reidel, Dordrecht.","Gazdar, Gerald. Phrase Structure Grammar. To appear in Jacobsen, O. and G. K. Pullum (eds.) On the Nature of Syntactic Representation.","Kaplan, R. M., and Martin Kay. Personal communication. 1981.","Karttunen, Lauri, Rebecca Root, and Hans Uszkoreit. Morphological analysis of Finnish by computer. Paper presented at the ACL session of the 1981 LSA Annual Meeting, New York, December 1981.","Konolige, Karl. Capturing linguistic generalizations with metarules in an annotat.d phrase-structure grammar. Proceedings of the 18th Annual Meeting of the Association for Computational Linguistics, University of Pennsylvania, Philadelphia, June 1980.","Moore, Robert C. Problems in Logical Form. Proceedings of the 19th Annual Meeting of the Association for Computational Linguistics, Stanford University, Pale Alto, June, 1981.","Moore, Robert C. Reasoning About Knowledge and Action. SRI International, Technical Note 191. October, 1980.","Peters, Stanley, and Robert W. Ritchie. Phrase Linking Grammars. December 1981. Unpublished manuscript. Robinson, Jane. DIAGRAM: A Grammar for Dialogues° Communications of the ACM, ~5:1 (January, 1982) 27--47. Stickel, Mark. A Non-Clausal Connection Graph Resolution Theorem Proving Program. Forthcoming. APPENDIX A. Sample Grammar Rules","The following is a portion of a test grammar for the PATR English translation system. Only those portions of the grammar utilized in analyzing the sample sentences in the text were included. The full grammar handles the following constructs: medals, adjecrivals, tense, predicative and nonpredicative copulatives, adverbials, quantified noun phrases, aspect, NP, PP, and infinitival complements, relative clauses, yes/no questions, restricted wh-questions, noun-noun compounds, passives, and prepositional phrases as predicates and ad* jectivals. a~smffiamumam GrlmlN, r hles •.m~ .... ~mssmtm Cone~mt EQ' • curry (X,,AIIBDA (X ¥) (equal X ¥)) Coast&at PASS' 8 <A: (LA~DA P (LAIEDA X ((P X) T))). NIL,","(IIX.IIBD (QUOTE (LAIIBDA S (some T (thing Y) S)))) > Constant PhSSIIF' • <A: (LAM~)A P (LAMBDA I (~& x (((P x) I) ¥)))). NIL,","(MI(.MBD (QUOTE (IAMBDA S Csome ¥ (thing ¥) S)))) > AUXP-> TENSE; Trtaslation: TENSE' DDET -> DET: Annotation:","[ Defiaite(DDET) ] Trtaslation: DET' DETP -> A; Annotation:","[ ~Definite(DETP) ] Translation: A' DETP -> DDET; Annotation:","[ AGREE(DET?. DDET, Definite) ] Translation: DDET' II~INITIV~ -~ TO VPP; Annotation:","[ AGREECINFINITIVE. VPP, G*ppy. |h) ] Translation: pull.v(VPP') NON -> NO~qD; Annotation:","[ AOREE(NOM. NOMHD. O~ppy) ] Translation: NON~ID' NOMHD -) NOUN; Translation: NOUN' NOUN -> N; Translation: N'","NP -) DE?P ~M; Annotation: [ AOP~CNP. NOM. Gappy) ] [ Predicative(NP) %/ ~Predicative(NP) ] [AGREE(N~. DETP, Definite) ] Translation: ~Predica~ive(~): DET~'[NOM'] Definite(NP) A Predicative(NP): E~'[DETP'[NQM']] ~Definite(NP) • Predicative(NP): NON' PREDICATE -> AU]~ ~; Annotation:","[ AORE~(PREDICATE. VPP. Active. 0appy. ~h) ] Translation :","pull.v(A~' [VPP'])","S -) SDEC; Annotation: [ ~Oappy(.~'~EC) ] [ ~(~EC) ] Translation : SDEC'","&DEC -) NP PREDICATE;","Annotation: [ 0appy(NP) V Gappy(I~DICATE) ¢-) G~ppy(S)EC) ] [ ~Predicative(NP) ] [ |h(N~) ~/ |b(PREDICATE) <=> Wb(SDEC) ] [ - (Onppy (NP) a Onppy (PKEDICATE)) ]","Truslation: pull.s(PR~DICATE'[NP'])","VP -, VPT; Annotation: [ ~TrLnsitive(VPT) ] [-TLkeelnZCV~T) ] [ Active(VPT) ] [ ActiveCVP) ]","Translation: VPT'","VP -> VPT NP I~FINITIVE;","Annotation: [ Takeslnf(VPT) ] [ Transitive(VPT) ] [ ~P~,dicativ,(~) ] [ AOP~:~(~. VPT. Active) ] [ Wh(NP) %/ Wh(INFmITIW) ~-* Wh(VP) ] [ IY(lctive(VPT).","((O&ppy(~) ~/ Oappy(~INITIVE)) ,=) Sappy(%~D)),","(~Oappy(~T) k Oappy(NP))) ] Truslation: Active(%?): pulI.v(%~OT°[NP '] [I~INITI~']) ~Active(VP): pull.v(P~Sl~'~T'] [INFINITIVE'])","V~ -~ VP; Annotation: [ a~(vl~. VP, Gappy. |h) ] [ Active(VP) ] Translation: VP' VPT -> V; Annotation:","[ AOREE(VPT. V. Active. Transitive. T~kenInf) ] Trsnslatlon: V' N -> nan: Translation: ¢a: mum, NIL, NIL ) Translation : ¢A: ~man. NIL, NIL ) DET -) every: Annotation:","[ Definite(DET) ] Translation: (B: (LAI~A P (LAMBDA S (every X (P X) S))). X. NIL • A -~ &; Translation: ~B: (IA~mDA P (~DA S (some X (P X) S))). X, NIL •","V -~ persuade;","Annotation: [ Transitive(V) ] [ Active(V) ~/ ~Active(V) ] [ TLkeslnf(V) ] Translation: curry (LAIfBDA (X P Y) (persuade Y l (P X)))","V -> go;","Annotation: [ ~Traneitive(V) ] [ -TskesZ~CV) ] [ ActiveCV) ] Translation: <A: go, NIL. NIL TENSE -> &past; Translation: curry (LAI~A (P X) (past ~ X)))"]},{"title":"APPENDIX B. Meaning Postulates","paragraphs":["(every • (every u (iff (pant • u)","(.or (put u •] (eTery • (some u (put • U))) [every • (every • (every y (every z (implies (promise • • y z)","(put • z] [every • (every • (every y (every z (implies (persuade • • y z) (pant • z] (every • (every • (thing • x))) [every • (every x (every z (implies (want • s z)","(put • z] (every • (pose • v)) [every v (every u (implies (pant • u)","(pose"]},{"title":"• u)","paragraphs":["[every • (every u (every v (implies (and (pantl • u)","(pantl u v))","(pant2 • v]","[every • (every z (implies (past2 • z)","(pant • z]","[every v (every z (if! (past • z) (putl• z] ~ is john a happy man Yes. • > no man could have hidden a book OK. >) did john hide a book No. >~ bill hid a book OK. • ~ is bill a man No. ~> ww john a sum I don't know. >> every •an •ill be a nan OK. >) •ill joh•be • nan Yes. ~, bill persuaded john to go OK. • > could john have been persuaded to p Yes. >> •ill john be persuaded to go I don't knee."]},{"title":"APPENDIX C. Transcript of Sample Dialo~ue","paragraphs":["• ~ john is happy OK. ~ is john happy Yes. >> is john a happy mnn I don't kno•. >> john is a man nK."]}]}