{"sections":[{"title":"A UNIFICATION-BASED PARSER FOR RELATIONAL GRAMMAR","paragraphs":["David E. Johnson IBM Research Division","P.O. Box 218","Yorktown Heights, NY 10598 dj ohns @ war son. ibm. com","Adam Meyers Linguistics Department New York University New York, NY 10003 meyers@acf2.nyu.edu Lawrence S. Moss","Mathematics Department Indiana University","Bloomington, IN 47401 lmoss@indiana.edu Abstract","We present an implemented unification-based parser for relational grammars developed within the stratified feature grammar (SFG) framework, which generalizes Kasper-Rounds logic to handle relational grammar analyses. We first in-troduce the key aspects of SFG and a lexicalized, graph-based variant of the framework suitable for implementing relational grammars. We then describe a head-driven chart parser for lexicalized SFG. The basic parsing operation is essentially ordinary feature-structure unification augmented with an operation of label unification to build the stratified features characteristic of SFG. INTRODUCTION","Although the impact of relational grammar (RG) on theoretical linguistics has been substantial, it has never previously been put in a form suitable for computational use. RG's multiple syntactic strata would seem to preclude its use in the kind of monotonic, unification-based parsing system many now consider standard ([1], [11]). However, recent work by Johnson and Moss [2] on a Kasper-Rounds (KR) style logic-based formalism [5] for RG, called Stratified Feature Grammar (S FG), has demonstrated that even RG's multiple strata are amenable to a feature-structure treatment.","Based on this work, we have developed a unification-based, chart parser for a lexical version of SFG suitable for building computational relational grammars. A lexicalized SFG is simply a collection of stratified feature graphs (S-graphs), each of which is anchored to a lexical item, analogous to lexicalized TAGs [10]. The basic parsing operation of the system is S-graph unification (S-unification): This is essentially ordinary feature-structure unification augmented with an operation of label unification to build the stratified features characteristic of SFG. RELATED WORK","Rounds and Manaster-Ramer [9] suggested encoding multiple strata in terms of a \"level\" attribute, using path equations to state correspondences across strata. Unfortunately, \"unchanged' relations in a stratum must be explicitly \"carried over\" via path equations to the next stratum. Even worse, these \"carry over\" equations vary from case to case. SFG avoids this problem. STRATIFIED FEATURE GRAM-MAR","SFG's key innovation is the generalization of the concept ]eature to a sequence of so-called relational signs (R-signs). The interpretation of a stratified feature is that each R-sign in a sequence denotes a primitive relation in different strata. 1","For instance, in Joe gave Mary tea there are, at the clause level, four sister arcs (arcs with the same source node), as shown in Figure h one arc labeled [HI with target gave, indicating gave is the head of the clause; one with label [1] and target Joe, indicating Joe is both the predicate-argument, and surface subject, of the clause; one with label [3,2] and target Mary, indicating that","l We use the following R-signs: 1 (subject), 2 (direct object), 3 (indirect object), 8 (chSmeur), Cat (Category), C (comp), F (flag), H (head), LOC (locative), M (marked), as well as the special Null R-signs 0 and/, explainedbelow. 97"]},{"title":"[Ca~] s [1] Joe [Hi save [3, 2] Mary [2, 8] tea","paragraphs":["Figure 1: S-graph for Joe gave Mary tea. Mary is the predicate-argument indirect object, but the surface direct object, of the clause; and one with label [2,8] and target tea, indicating tea is the predicate-argument direct object, but surface ch6meur, of the clause. Such a structure is called a stratified feature graph (S-graph).","This situation could be described in SFG logic with the following formula (the significance of the different label delimiters (,), [, ] is explained below): RI:-- [Hi:gave A [1):Joe A [3, 2): Mary A [2, 8): tea .","In RG, the clause-level syntactic information captured in R1 combines two statements: one characterizing gave as taking an initial 1, initial 2 and initial 3 (Ditransltive); and one characterizing the concomitant \"advancement\" of the 3 to 2 and the \"demotion\" of the 2 to 8 (Dative). In SFG, these two statements would be: Ditransitive :: [Hi:gave A [1):T A .[2):T A [3):T ; Dative :---- (3, 2): T ~ (2, 8_): T.","Ditransitive involves standard Boolean conjunction (A). Dative, however, involves an operator, &, unique to SFG. Formulas involving ~ are called e~tension formulas and they have a more complicated semantics. For example, Dative has the following informal interpretation: Two distinct arcs with labels 3 and 2 may be \"extended\" to (3,2) and (2,8) respectively. Extension formulas are, in a sense, the heart of the SFG description language, for without them RG analyses could not be properly represented. 2","2We gloss over many technicalities, e.g., the SFG notion data justification and the formal semantics of stratified features; cf. [2].","RG-style analyses can be captured in terms of rules such as those above. Moreover, since the above formulas state positive constraints, they can be represented as S-graphs corresponding to the minimal satisfying models of the respective formulas. We compile the various rules and their combinations into Rule Graphs and associate sets of these with appropriate lexical anchors, resulting in a lexicalized grammar, s","S-graphs are formally feature structures: given a collection of sister arcs, the stratified labels are required to be functional. However, as shown in the example, the individual R-signs are not. Moreover, the lengths of the labels can vary, and this crucial property is how SFG avoids the \"carry over\" problem. S-graphs also include a strict partial order on arcs to represent linear precedence (cf. [3], [9]). The SFG description language in-cludes a class of linear precedence statements, e.g., (1] -4 (Hi means that in a constituent \"the final subject precedes the head\".","Given a set 7Z,9 of R-signs, a (stratified) feature (or label) is a sequence of R-signs which may be closed on the left or right or both. Closed sides are indicated with square brackets and open sides with parentheses. For example, [2, 1) denotes a label that is closed on the left and open on the right, and [3, 2, 1, 0] denotes a label that is closed on both sides. Labels of the form [-.-] are called (totally) closed; of the form (...) (totally) open; and the others partially closed (open) or closed (open) on the right (left), as appropriate.","Let B£ denote the set of features over 7Z*. B£ is partially ordered by the smallest relation C_ permitting eztension along open sides. For example, (3) ___ (3,2) U [3,2,1) C [3,2, 1,0]. Each feature l subsuming (C) a feature f provides a partial description of f. The left-closed bracket [ allows reference to the \"deepest\" (initia~ R-sign of a left-closed feature; the right-closed bracket ] to the \"most surfacy\" (fina~ R-sign of a right-closed feature. The totally closed features are maximal (completely defined) and with respect to label unification, defined below, act like ordinary (atomic) features.","Formal definitions of S-graph and other definitions implicit in our work are provided in [2]. s We ignore negative constraints here. 98"]},{"title":"AN EXAMPLE","paragraphs":["Figure 2 depicts the essential aspects of the S-graph for John seemed ill. Focus on the features [0,1] and [2,1,0], both of which have the NP John as target (indicated by the ~7's). The R-sign 0 is a member of Null, a distinguished set of R-signs, members of which can only occur next to brackets [ or ]. The prefix [2,1) of the label [2,1,0] is the SFG representation of RG's unaccusative analysis of adjectives. The suffix (1,0] of [2,1,0]; the prefix [0,1) of the label [0,1] in the matrix clause; and the structure-sharing collectively represent the raising of the embedded subject (cf. Figure 3).","Given an S-graph G, Null R-signs permit the definitions of the predicate-argument graph, and the surface graph, of G. The predicate-argument graph corresponds to all arcs whose labels do not begin with a Null R-sign; the relevant R-signs are the first ones. The surface graph corresponds to all arcs whose labels do not end with a Null R-sign; the relevant R-signs are the final ones. In the example, the arc labeled [0,1] is not a predicate-argument arc, indicating that John bears no predicate-argument relation to the top clause. And the arc labeled [2,1,0] is not a surface arc, indicating that John bears no surface relation to the embedded phrase headed by ill.","The surface graph is shown in Figure 4 and the predicate-argument graph in Figure 5. Notice that the surface graph is a tree. The treehood of surface graphs is part of the definition of S-graph and provides the foundation for our parsing algorithm; it is the SFG analog to the \"context-free backbone\" typical of unification-based systems [11]."]},{"title":"LEXICALIZED SFG","paragraphs":["Given a finite collection of rule graphs, we could construct the finite set of S-graphs reflecting all consistent combinations of rule graphs and then associate each word with the collection of derived graphs it anchors. However, we actually only construct all the derived graphs not involving extractions. Since extractions can affect almost any arc, compiling them into lexicalized S-graphs would be impractical. Instead, extractions are handled by a novel mechanism involving multi-rooted graphs (of. Concluding Remarks).","We assume that all lexically governed rules such as Passive, Dative Advancement and Raising are compiled into the lexical entries governing them."]},{"title":"[Cat]","paragraphs":["vP"]},{"title":"[0,11 [HI seemed [Cat]","paragraphs":["AP"]},{"title":"[c] [2,1,0] [n] in","paragraphs":["Figure 2: S-graph for John seemed ill"]},{"title":"[o,1) (1,o] m [el","paragraphs":["Figure 3: Raising Rule Graph [cat]"]},{"title":"(1] [H] [c] VP ~John seemed","paragraphs":["[Cat]"]},{"title":"AP [HI in","paragraphs":["Figure 4: Surface Graph for John seemed ill [Cat]"]},{"title":"VP [H] seemed [c t] AP [c] [2) John [H] iJ.J. Figure","paragraphs":["5: Predicate-Argument Graph for John seemed ill 99 Thus, given has four entries (Ditransitive, Ditransitive + Dative, Passive, Dative + Passive). This aspect of our framework is reminiscent of LFG [4] and HPSG [7], except that in SFG, relational structure is transparently recorded in the stratified features. Moreover, SFG relies neither on LFG-style annotated CFG rules and equation solving nor on HPSG-style SUBCAT lists.","We illustrate below the process of constructing a lexical entry for given from rule graphs (ignor-ing morphology). The rule graphs used are for Ditransitive, Dative and (Agentless) Passive constructions. Combined, they yield a ditransitivedative-passive S-graph for the use of given occur-ring in Joe was given ~ea (cf. Figure 6). Dltransitive:"]},{"title":"[H] given [3) [2) [I)","paragraphs":["DATive: (2, 8)"]},{"title":"(3,2)","paragraphs":["DI tl DAT:"]},{"title":"[H] given [3, 2) [2, 8) [1)","paragraphs":["PASsive: (2,1)"]},{"title":"[1, 8, 0] [Cat] s [0,11 m Joe [H] was [c] [Cat] vP","paragraphs":["[H] given"]},{"title":"[3,2,1,0] m","paragraphs":["[2, 8] tea"]},{"title":"[1,8,0]","paragraphs":["Figure 6: S-graph for Joe was given iea. D113 DAT) U PAS: [H]"]},{"title":"given [3,2, i) [2, 8) [1, s, 0]","paragraphs":["The idea behind label unification is that two compatible labels combine to yield a label with maximal nonempty overlap. Left (right) closed labels unify with left (right) open labels to yield left (right) closed labels. There are ten types of label unification, determined by the four types of bracket pairs: totally closed (open), closed only on the left (right). However, in parsing (as opposed to building a lexicalized grammar), we stipulate that successful label unification must result in a ~o~ally closed label. Additionally, we assume that all labels in well-formed lexicalized graphs (the input graphs to the parsing algorithm) are at least partially closed. This leaves only four cases: Case"]},{"title":"1.","paragraphs":["[or] Ll [o~1 = [Or] Case"]},{"title":"2. [~) u [~#] = [~#1","paragraphs":["Case 3. (o~] LI [~] : [~c~]"]},{"title":"Case 4. [+#) u (#+] = [+#+]","paragraphs":["Note: c~, fl, 7 @ T~S+ and/3 is the longest common, nonempty string. 100 The following list provides examples of each. 1. [1,0] U [1,0] = [1,0] 2. [1) U [1,0] = [1,0] 3. (~,0] U [2,1,0] = [2,1,0] 4. [2,1) U (1,0] = [2,1,0]","Case 1 is the same as ordinary label unification under identity. Besides their roles in unifying rule-graphs, Cases 2, 3 and 4 are typically used in parsing bounded control constructions (e.g., \"equi\" and \"raising\") and extractions by means of \"splicing\""]},{"title":"Null","paragraphs":["R-signs onto the open ends of labels and closing off the labels in the process. We note in passing that cases involving totally open labels may not result in unique unifications, e.g., (1, 2) U (2, 1) can be either (2,1,2) or (1,2,1). In practice, such aberrant cases seem not to arise. Label unification thus plays a central role in building a lexicalized grammar and in parsing. THE PARSING ALGORITHM","S-unification is like normal feature structure unification ([1], [11]), except that in certain cases two arcs with distinct labels 1 and l' are replaced by a single arc whose label is obtained by unifying 1 and l'.","S-unification is implemented via the procedures Unify-Nodes, Unify-Arcs, and Unify-Sets-of-Arcs: 1. Unify-Nodes(n,n') consists of the steps:","a. Unify label(n) and label(n'), where node","labels unify under identity","b. Unify-Sets-of-Arcs(Out-Arcs(n), Out-","Arcs(n')) 2. Unify-Arcs(A,A') consists of the steps: a. Unify label(A) and label(A') b. Unify-Nodes(target (A),target (A')) 3. Unify-Sets-of-Arcs(SeQ,"]},{"title":"Set2),","paragraphs":["where"]},{"title":"Sett","paragraphs":["= {Aj,...,A~} and"]},{"title":"Set2 = {Am,..., An},","paragraphs":["returns a set of arcs"]},{"title":"Set3,","paragraphs":["derived as follows: a. For each arc"]},{"title":"Ai • SeQ,","paragraphs":["attempt to find some arc"]},{"title":"A~ • Set2,","paragraphs":["such that Step 2a of Unify-arcs(Ai,A~) succeeds. If Step 2a succeeds, proceed to Step 2b and remove A~ from"]},{"title":"Sets.","paragraphs":["There are three possibilities: i. If no A~ can be found, Ai •"]},{"title":"Set3.","paragraphs":["ii. If Step 2a and 2b both succeed, then Unify-arcs(Ai,"]},{"title":"A~) • Set3.","paragraphs":["iii. If Step 2a succeeds, but Step 2b fails, then the procedure fails. b. Add each remaining arc in"]},{"title":"Set2","paragraphs":["to"]},{"title":"Set3.","paragraphs":["We note that the result of S-unification can be a set of S-graphs. In our experience, the unification of linguistically well-formed lexical S-graphs has never returned more than one S-graph. Hence, S-unification is stipulated to fail if the result is not unique. Also note that due to the nature of label unification, the unification procedure does not guarantee that the unification of two S-graphs will be functional and thus well-formed. To insure functionality, we filter the output.","We distinguish several classes of Arc: (i) Surface Arc vs. Non-Surface, determined by absence or presence of a"]},{"title":"Null","paragraphs":["R-sign in a label's"]},{"title":"last","paragraphs":["position; (ii) Structural Arc vs. Constraint Arc (stipulated by the grammar writer); and (iii) Relational Arc vs. Category Arc, determined by the kind of label (category arcs are atomic and have R-signs like Case, Number, Gender, etc.). The parser looks for arcs to complete that are Surface, Structural and Relational (SSR).","A simplified version of the parsing algorithm is sketched below. It uses the predicates Left-Precedence , Right-Precedence and Complete: . Precedence: Let"]},{"title":"Q~ = [n~,Li, R~], F","paragraphs":["• SSR-Out-Arcs(n~) such that"]},{"title":"Target(F) = Anchor(Graph(n~)),","paragraphs":["and A • SSR-Out-Arcs(ni) be an incomplete terminal arc. Then: A. Left-Precedence(A, n~) is true iff: a. All surface arcs which must follow F are incomplete. b. A can precede F. c. All surface arcs which must both precede F and follow A are complete. B. Right-Precedence(A, n~) is true iff: a. All surface arcs which must precede F are complete. b. A can follow F. c. All surface arcs which must both follow F and precede A are complete. 101","2. Complete : A node is complete if it is either a lexical anchor or else has (obligatory) outgoing SSR arcs, all of which are complete. An arc is complete if its target is complete.","The algorithm is head-driven [8] and was in-spired by parsing algorithms for lexicalized TAGs ([6], [10]). Simplified Parsing Algorithm: Input: A string of words Wl,..., w~. Output: A chart containing all possible parses. Method: A. Initialization: 1.","Create a list of k state-sets $1,..., Sk, each empty.","2. For c = 1,...,k, for each"]},{"title":"Graph(hi)","paragraphs":["of Wc, add [ni, c - 1, c] to Se. B. Completions: For c = 1,..., k, do repeatedly until no more states can be added to Se:","1. Leftward Completion: For all ="]},{"title":"¢] Se,","paragraphs":["Qj = [nj, Lj, L~] E SL,, such that"]},{"title":"Complete(nj )","paragraphs":["and A E SSR-Out-Arcs(ni), such that"]},{"title":"Left-Precedence(A, hi)","paragraphs":["IF"]},{"title":"Unify-a~-end-of-Path(ni, nj, A ) n~, 2.","paragraphs":["THEN","Add [n~,Lj,c] to So. Rightward Completion: For all"]},{"title":"Qi","paragraphs":["= [n/, L~, R~] E SR,, Qj = [nj,Pq, c] 6 Sc such that"]},{"title":"Complete(nj ),","paragraphs":["and A E SSR-Out-Arcs(ni), such that"]},{"title":"Right-Precedence(A, hi)","paragraphs":["IF"]},{"title":"Unify-at-end-of-Path(n~, nj, A)","paragraphs":["THEN Add [n~, Li, el to So. To illustrate, we step through the chart for"]},{"title":"John seemed ill (","paragraphs":["cf. Figure 7). In the string 0"]},{"title":"John 1 seemed 2 ill 3,","paragraphs":["where the integers represent string positions, each word w is associated via the lexicalized grammar with a finite set of anchored S-graphs. For expository convenience, we will assume counterfactually that for each w there is only one S-graph G~ with root r~ and anchor w. Also in the simplified case, we assume that the anchor is always the target of an arc whose source is the root. This is true in our example, but false in general.","For each G~, r~ has one or more outgoing SSR arcs, the set of which we denote SSR-Out-Arcs(r~). For each w between integers x and y in the string, the Initialization step (step A of the algorithm) adds [n~, x, y] to state set y. We denote state Q in state-set"]},{"title":"Si","paragraphs":["as state i:Q. For an input string w = Wl,...,w,~, initialization creates n state-sets and for 1 < i < n, adds states i : Qj,1 _< j < k, to Si , one for each of the k S-graphs G~. associated with wi. After initialization, the example chart consists of states 1:1, 2:1, 3:1.","Then the parser traverses the chart from left to right starting with state-set 1 (step B of the algorithm), using left and right completions, according to whether left or right precedence conditions are used. Each completion looks in a state-set to the"]},{"title":"left","paragraphs":["of Sc for a state meeting a set of conditions. In the example, for c = 1, step B of the algorithm does not find any states in any state-set preced-ing S1 to test, so the parser advances c to 2. A left completion succeeds with"]},{"title":"Qi =","paragraphs":["state 2:1 = [hi, 1, 2] and Qj = state 1:1 = [nj, 0, 1]. State 2:2 = [n~, 0, 2] is added to state-set $2, where n~ = Unify-at-end-of-Path(n,, nj, [0, 1)). Label [0, 1) is closed off to yield [0, 1] in the output graph, since no further R-signs may be added to the label once the arc bearing the label is complete.","The precedence constraints are interpreted as strict partial orders on the sets of outgoing SSR arcs of each node (in contrast to the totally ordered lexicalized TAGs). Arc [0, 1) satisfies left-precedence because: (i) [0, 1) is an incomplete terminal arc, where a terminal arc is an SSR arc, the target of which has no incomplete outgoing surface arcs; (ii) all surface arcs (here, only [C]) which must follow the [H] arc are incomplete; (iii) [0 1) can precede [H]; and (iv) there are no (incomplete) surface arcs which must occur"]},{"title":"between","paragraphs":["[0 1) and [H]. (We say"]},{"title":"can","paragraphs":["in (iii) because the parser accomodates variable word order.)","The parser precedes to state-set $3. A right completion succeeds with Q~ = state 2:2 = [n~, 0, 2] and Q~ = state 3:1 = [n~,2,3]. State 3:2 - [n~', 0, 3] is added to state set $3, n~' = Unify-at-102"]},{"title":"1..11","paragraphs":["LP=0 RP=I L.P=I RP=2 VP [H] • [o, / seemed AP John seemed =:=J LP:0","RP:2 VP\""]},{"title":"OlJl ,","paragraphs":["[H] ~. John","John seemed 3:1J LP:2","RP=3 AP\""]},{"title":"'~ [.\"]","paragraphs":["NP ill ill 3:2] LP=0 RP=3 VP\"","John John seemed ill Figure 7: Chart for John seemed ill. end-of-Path(n~, n~, [C]). State 3:2 is a successful parse because n~' is complete and spans the entire input string.","To sum up: a completion finds a state Qi = [hi, L,, R~] and a state Qj = [nj, Lj, Rj] in adjacent state-sets (Li = Rj or P~/ = Lj) such that ni is incomplete and nj is complete. Each successful completion completes an arc A E SSR-Out-Arcs(n~) by unifying nj with the target of A. Left completion operates on a state Qi = [ni,Li, c] in the current state-set Sc looking for a state Qj = [nj, Lj, L~] in state-set SL, to complete some arc A E SSR-Out-Arcs(ni). Right completion is the same as left completion except that the roles of the two states are reversed: in both cases, success adds a new state to the current state-set So. The parser completes arcs first leftward from the anchor and then rightward from the anchor."]},{"title":"CONCLUDING REMARKS","paragraphs":["The algorithm described above is simpler than the one we have implemented in a number of ways. We end by briefly mentioning some aspects of the VP //~[LOC] V pp [FJJ~[MI"]},{"title":"/ \\ in","paragraphs":["NP [/,Q] Figure 8: Example: in P"]},{"title":"~ [c] d what","paragraphs":["Figure 9: Example: What general algorithm.","Optional Arcs: On encountering an optional arc, the parser considers two paths, skipping the optional arc on one and attempting to complete it on the other.","Constraint Arcs These are reminiscent of LFG constraint equations. For a parse to be good, each constraint arc must unify with a structural arc.","Multi-tiered S-graphs: These are S-graphs having a non-terminal incomplete arc I (e.g., the [LOC] arc in Figure 8. Essentially, the parser searches I depth-first for incomplete terminal arcs to complete.","Pseudo-R-signs: These are names of sets of R-signs. For a parse to be good, each pseudo-R-sign must unify with a member of the set it names.","Extractions: Our approach is novel: it uses pseudo-R-signs and multirooted S-graphs, illustrated in Figure 9, where p is the primary root and d, the dangling root, is the source of a \"slashed arc\" with label of the form (b,/] (b a pseudo-R-sign). Since well-formed final parses must be"]},{"title":"103","paragraphs":["single-rooted, slashed arcs must eventually unify with another arc.","To sum up: We have developed a unification-based, chart parser for relational grammars based on the SFG formalism presented by Johnson and Moss [2]. The system involves compiling (combinations) of rules graphs and their associated lexical anchors into a lexicalized grammar, which can then be parsed in the same spirit as lexicalized TAGs. Note, though, that SFG does not use an adjunction (or substitution) operation. [10] Yves Schabes."]},{"title":"Mathematical and Compu- tational Properties of Lezicalized Grammars.","paragraphs":["PhD thesis, University of Pennsylvania, 1990. [11] Stuart Shieber."]},{"title":"Constraint-Based Grammar Formalisms.","paragraphs":["MIT Press, 1992. References [1] Bob Carpenter."]},{"title":"The Logic of Typed Feature Structures.","paragraphs":["Cambridge UP, Cambridge, 1992.","[2] David E. Johnson and Lawrence S. Moss. Some formal properties of stratified feature grammars. To appear in"]},{"title":"Annals of Mathe- matics and Artificial Intelligence,","paragraphs":["1993. [3] David E. Johnson and Paul M. Postal."]},{"title":"Are Pair Grammar.","paragraphs":["Princeton University Press, 1980.","[4] Ronald Kaplan and Joan Bresnan. Lexical-functional grammar, a formal system for grammatical representation. In J. Bresnan, editor,"]},{"title":"The Mental Representation of Gram- matical Relations.","paragraphs":["MIT Press, 1982.","[5] Robert Kasper and William C. Rounds. The logic of unification in grammar."]},{"title":"Linguistics and Philosophy,","paragraphs":["13:35-58, 1990.","[6] Alberto Lavelli and Giorgio Satta. Bidirectional parsing of lexicalized tree adjoining grammars. In"]},{"title":"Proceedings of the 5th Confer- ence of the European Chapter of the Associa- tion of Computational Linguistics,","paragraphs":["1991. [7] Carl Pollard and Ivan Sag."]},{"title":"Information-based Syntaz and Semantics.","paragraphs":["CSLI Lecture Notes. University of Chicago Press, Chicago, 1987.","[8] Derek Proudian and Carl Pollard. Parsing head-driven phrase structure grammar. In"]},{"title":"Proceedings of the 23rd Annual Meeting of the ACL,","paragraphs":["1985.","[9] William C. Rounds and Alexis Manaster-Ramer. A logical version of functional grammar. In"]},{"title":"Proceedings of The 25th Annual Meeting of the Association for Computational Linguistics,","paragraphs":["1987."]},{"title":"104","paragraphs":[]}]}
