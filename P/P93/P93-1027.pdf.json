{"sections":[{"title":"ON THE DECIDABILITY OF FUNCTIONAL UNCERTAINTY* Rolf","paragraphs":["Backofen","German Research Center for Artificial Intelligence (DFKI) W-6600 Saarbrficken, Germany","backofen@dfki.uni-sb.de Abstract We show that feature logic extended by functional uncertainty is decidable, even if one admits cyclic descriptions. We present an algorithm, which solves feature descriptions containing functional uncertainty in two phases, both phases using a set of deterministic and non-deterministic rewrite rules. We then compare our algorithm with the one of Kaplan and Maxwell, that does not cover cyclic feature descriptions. 1 Introduction Feature logic is the main device of unification grammars, the currently predominant paradigm in computational linguistics. More recently, feature descriptions have been proposed as a constraint system for logic programming (e.g. see [ll D . They provide for partial descriptions of abstract objects by means of functional attributes called features.","Formalizations of feature logic have been proposed in various forms (for more details see [3] in this volume). We will follow the logical approach introduced by Smolka [9, 10], where feature descriptions are standard first order formulae interpreted in first order structures. In this formalization features are considered as functional relations. Atomic formulae (which we will call atomic constraints) are of either the form A(x) or zfy, where x, y are first order variables, A is some sort predicate and f is a feature (written in infix notation). The constraints of the form xfy can be generalized to constraints of the form xwy, where w = fl-.. fn is a finite feature path. This does not affect the computational properties.","In this paper we will be concerned with an extension to feature descriptions, which has been introduced as \"functional uncertainty\" by Kaplan and Zaenen [7] and Kaplan and Maxwell [5]. This for-mal device plays an important role in the framework of LFG in modelling so-called long distance dependencies and constituent coordination. For a detailed linguistic motivation see [7], [6] and [5]; a more general use of functional uncertainty can be found in [8].","Functional uncertainty consists of constraints of","*This work was supported by a research grant, ITW 9002 0, from the German Bundesministerium ffir Forschung und Technologic to the DFKI project DISCO. I would like to thank Jochen Dhrre, Joachim Niehren and Ralf Treinen for reading draft version of this paper. For space limitations most of the proofs are omitted; they can be found in the complete paper [2] the form xLy, where L is a finite description of a regular language of feature paths. A constraint xLy holds if there is a path w E L such that zwy holds. Under this existential interpretation, a constraint xLy can be seen as the disjunction = I ,.,, e"]},{"title":"xLy L}.","paragraphs":["Certainly, this disjunction may be infinite, thus functional uncertainty yields additional expressivity. Note that a constraint zwy is a special case of a functional uncertainty constraint.","To see some possible application of functional uncertainty we briefly recall an example that is given in Kaplan and Maxwell [5, page 1]. Consider the topicalized sentence Mary John telephoned yesterday. Using s as a variable denoting the whole sentence, the LFG-like clause s topic x A s obj x specifies that in s Mary should be interpreted as the object of the relation telephoned. The sentence could be extended by introducing additional complement predicates, as e.g. in sentences like Mary John claimed thai Bill telephoned; Mary John claimed thai Bill said that ...Henry telephoned yesterday; .... For this family of sentences the clauses s topic x A s comp obj x, s topic xAs comp cornp obj x and so on would be appropriate; specifying all possibilities would yield an infinite disjunction. This changes if we make use of functional uncertainty allowing to specify the above as the single clause s topic x A s comp* obj x.","Kaplan and Maxwell [5] have shown that consistency of feature descriptions is decidable, provided that a certain aeyclicity condition is met. More recently, Bander et hi. [1] have proven, that consistency is not decidable if we add negation. But it is an open problem whether consistency of feature descriptions without negation and without additional restrictions (such as acyclicity) is decidable. In the work presented here we show that it indeed is decidable. 2 ']?he Method We will first briefly describe the main part of solving the standard feature terms and then turn to their extension with functional uncertainty.","Consider a clause ¢ = xplyl A xpzy2 (from now on we will refer to pure conjunctive formulae as clauses). A standard method for solving feature terms would rewrite ¢ in order to achieve a solved form. This rewriting depends on the paths Pl and Pz. If Pl equals Pz, we know that yl and Y2 must be equal. This implies that ¢ is equivalent to xplyx Ayl -- Yz. If 201 p~ is a prefix of p2 and hence P2 ="]},{"title":"P~P~,","paragraphs":["we can transform ¢ equivalently into the formulae"]},{"title":"xplyi A YlP'Y2.","paragraphs":["The reverse case is treated in a similar'fashion. If neither prefix or equality holds between the paths, there is nothing to be done. By and large, clauses where this holds for every x and every pair of different constraints"]},{"title":"xp~y","paragraphs":["and"]},{"title":"xp2z","paragraphs":["are the solved forms","in Smolka [9], which are consistent. If we consider a clause of the form ¢ ="]},{"title":"zL~y~ A zL2y~,","paragraphs":["then we again have to check the relation between ys and y~. But now there is in general no unique relation determined by ¢, since this depends on which paths p~ and P2 we choose out of L~ and L~. Hence, we have to guess the relation between pl and p~ before we can calculate the relation between yl and y~. However, there is a problem with the original syntax, namely that it does not allow one to express any relation between the chosen paths (in a later section we will compare our algorithm to the one of Kaplan/Maxwell, thus showing where exactly the problem occurs in their syntax). Therefore, we extend the syntax by introducing so-called path variables (written c~, fl, a',...), which are interpreted as feature paths (we will call the other variables first order variables). Hence, if we use the modified subterm relation"]},{"title":"xo~y","paragraphs":["and a restriction constraint o~ ~ L, a constraint"]},{"title":"xLy","paragraphs":["can equivalently be expressed as"]},{"title":"xay A a ~ L (4","paragraphs":["new). The interpretation of"]},{"title":"xay","paragraphs":["is done in two steps. Given a valuation V~, of the path variables as feature paths, a constraint"]},{"title":"=c~y","paragraphs":["in ¢ is substituted by"]},{"title":"xV~,(cQy.","paragraphs":["This constraint is then interpreted using the valuation for the first order variables in the way such constraints are usually interpreted.","By using this extended (two-sorted) syntax we are now able to reason about the relations between different path variables. In doing so, we introduce additional constraints c~ - fl (equality), o~ ~ fl (prefix) and c~ fl fl (divergence). Divergence holds if neither equality nor prefix holds. Now we can describe a nor-mal form equivalent to the solved clauses in Smolka's work, which we will call pre-solved clauses. A clause ¢ is"]},{"title":"pre-solved","paragraphs":["iff for each pair of different constraint"]},{"title":"xayl","paragraphs":["and"]},{"title":"x~y2","paragraphs":["in ~b there is a constraint a I] ~ in ¢. We call this clauses pre-solved, since such clauses are not necessarily consistent. It may happen, that the divergence constraints together with the restrictions of form a ~ L are inconsistent (e.g. think of the clause"]},{"title":"a~ f+ A ~ ~ ff+ A (~ fl fl).","paragraphs":["But pre-solved clauses have the property, that if we find a valuation for the path variables, then the clause is consistent.","Our algorithm first transforms a clause into a set of pre-solved clauses, which is (seen as a disjunction) equivalent to the initial clause. In a second phase the pre-solved clauses are checked for consistency with respect to the path variables. In this paper we will concentrate on the first phase, since it is the more difficult one.","Before looking at the technical part we will illustrate the first phase. For the rest of the paper we will write clauses as sets of atomic constraints. Now consider the clause 7 ="]},{"title":"{xay, al ~ L1, xflz, fl~","paragraphs":["L2}. The first step is to guess the relation between the path variables c~ and ft. Therefore, 7 can be expressed equivalently by the set of clauses 71 = {4"]},{"title":",) ~} u 7 73 = {~ ~ ~} u 7","paragraphs":["72 = {,~ - ~} u 7 74 = {~ -~ ,~} u 7 The clause 71 is pre-solved. For the others we have to evaluate the relation between a and ]Y, which is done as follows. For 72 we substitute/~ by ot and z by y, which yields"]},{"title":"{y \"--z, xay, o~E L1, aEL2}.","paragraphs":["We keep only the equality constraint for the first order variables, since we are only interested in their valuation. Combining {4 ~ L1, a ~ L2} to {4 ~"]},{"title":"(L1 f')L2)}","paragraphs":["then will give us the equivalent pre~solved clause","For 73 we know that the variable/3 can be split into two parts, one of them covered by 4. We can use concatenation of path variables to express this, i.e. we can replace fl by the term c~.fl', where ~' is new. Thus we get the clause"]},{"title":"7~ - {xc~y, a~ L1, yfl' z,","paragraphs":["c~.fl'~L2},","The only thing that we have to do additionally in order to achieve a pre-solved clause is to resolve the constraint a./~ ~ ~ L2. To do this we have to guess a so-called decomposition P, S of L2 with"]},{"title":"P.S C_ L2","paragraphs":["such that a ~ P and ]~' ~ S. In general, there can be an infinite number of decompositions (think of the possible decompositions of the language f'g). But as we use regular languages, there is a finite set of regular decompositions covering all possibilities. Finally, reducing {c~ ~ L~, ~ ~ P} to {~ ~ (L1 n P)} will yield a pre-solved clause.","Note that the evaluation of the prefix relation in 73 has the additional effect of introducing a new constraint"]},{"title":"y~z.","paragraphs":["This implies that there again may be some path variables the relation of which is unknown. Hence, after reducing the terms of form a --\" ]~ or","~ fl we may have to repeat the non-deterministic choice of relations between path variables. In the end, the only remaining constraints between path variables will be of the form a fl ft.","We have to consider some additional point, namely that the rules we present will (naturally) loop in some cases. Roughly speaking, one can say that this always occurs if a cycle in the graph coincides with a cycle in the regular language. To see this let us vary the above example and let 7 now be the clause"]},{"title":"{xax, c~ ~ f, xflz, fl ~ f'g}.","paragraphs":["Then a possible looping derivation could be 1. adda4]~:"]},{"title":"{4 4 fl, xax, a~f, xflz, fl~f*g}","paragraphs":["2. split fl into a-f~': 3. decompose c~-/~ I~"]},{"title":"f'g: {=~, ~f, ~f~'~, a~f*, Z'~f*g} 202","paragraphs":["4. join a-restrictions:"]},{"title":"{=~z, ~I, ~/~'z, ~'~y*g}","paragraphs":["However, we will proof that the rule system is quasi-terminating, which means that the rule system may cycle, but produces only finitely many different clauses (see [4]). This means that checking for cyclic derivations will give us an effective algorithm.","Quasi-termination is achieved by the following measures: first we will guarantee that the rules do not introduce additional variables; second we restrict concatenation to length 2; and third we will show that the rules system produces only finitely many regular languages. In order to show that our rewrite system is complete, we also have to show that every solution can be found in a pre-solved clause. 3 Preliminaries Our signature consists of a set of sorts S (A, B,...), first order variables X (z,y,...), path variables 7 9 (a,/3,...) and features Jr (f, g,...). We will assume a finite set of features and infinite sets of variables and sorts. A path is a finite string of features. A path u is a prefix of a path v (written u ~ v) if there is a non-empty path w such that v = uw. Note that","is neither symmetric nor reflexive. Two paths u, v diverge (written u n v) if there are features f, g with f ~ g and possibly empty paths w, wl, w2 such that u = wfw~ A v = wgw2. Clearly, n is a symmetric relation. Proposition 3.1 Given two paths u and v, then exactly one of the relations u = v, u .~ v, u ~- v oru II v holds.","A path term (p, q .... ) is either a path variable a or a concatenation of path variables a.fl. We will allow complex path terms only in divergence constraints and not in prefix or equality constraints. Hence, the set of atomic constraints is given by","e ~ Az sort restriction","z \":- y agreement","z f~.....fn Y subterm agreement 1","zo~y subterm agreement 2","p~ L path restriction","p fi q divergence","~ [3 prefix","c~ - fl path equality We exclude empty paths in subterm agreement since xey is equivalent to x - y. Therefore, we require fl\"...'fn E ~r+ and L C_ jr+.","A clause is a finite set of atomic constraint denoting their conjunction. We will say that a path term a.fl is contained (or used) in some clause ¢ if ¢ contains either a constraint a-fl ~ L or a constraint a.fl ti q) Constraints of the form p~ L, p fl q, a :~ fl and c~ - fl will be called path constraints.","An interpretation Z is a standard first order structure, where every feature f ~ ~ is interpreted as a binary, functional relation F z and where sort symbols We will not differentiate between p fl q and q ~ p. are interpreted as unary, disjoint predicates (hence A zOBz= 0 for A 5£ B). A valuation is a pair (Vx, VT~), where Vx is a standard first order valuation of the variables in X and Vv is a function V~v : P ---+ ~'+. We define V~,(a.fl) to be VT,(a)V~,(13),","The validity of an atomic constraint in an interpretation 2\" under a valuation (Vx, V~,) is defined as follows:"]},{"title":"(Vx, V~,) ~z Ax :¢=:~ Vx(x) e A z (Vx, Vr) Pz = - Y :¢=~ Vx(=) = Vx(U) (vx,vr) ~z zpy (vx, vv) ~z =.u (vx, vT~) ~z p e L (Vx, VT~) ~z pbq :¢=, vx(~) F? 0...o F, ~ Vx(y) :¢:=~ (Vx, Vv) ~z • Vv(a) y","paragraphs":[":¢==~ V~,(p) C L :¢::~ Vp(p) o VT~(q)","for aC {u,k,--\" }, where p is the path fl\"...'f, and F/z are the interpretations of fi in Z.","For a set ~ C X we define =£ to be the following relation on first order valuation: Vx =~ V/~ iff W e ~ : Vx(~) = V/~(x). Similarly, we define =~ with 7r C 79 for path valuations. Let 0 C_ XU79 be a set of variables. For a given interpretation 7: we say that a valuation (Vx, V~) is a O-solution of a clause ¢ in 2\" if there is a valuation (V~, V~) in 2\" such that Vx =a'ne V~:, Vp =~,no V~ and (V~:, V~) ~z ¢. The set of all 0-solutions of ¢ in 2: is denoted by [¢]~. We will call X-solutions just solutions and write [¢]z instead of [¢],~.","For checking satisfiability we will use transformation rules. A rule R is O-sound ¢ --*n 7 [¢]z D [7]~ z for every interpretation 2\". R is called O-preserving if ¢ \"+R 3' :¢\" [¢]Z C [7]~. R is globally O-preservingif [¢]z C_ U [7]$-","¢--*n7 4 The First Phase 4.1 A Set of Rules Recall that we have switched from the original syntax to a (two-sorted) syntax by translating constraints zLy into {zay, ~ ~ L}, where a is new. The result of the translation constitutes a special class of clauses, namely the class of prime clauses, which will be defined below. Hence, it suffices to show decidability of consistency of prime clauses. They are the input clauses for the first phase.","Let ¢ be some clause and z, y be different variables. We say that ¢ binds y t0 z if z - y E ¢ and y occurs only once in ¢. Here it is important that we consider equations as directed, i.e. we assume that z -\" y is different from y - x. We say that ¢ eliminates y if ¢ binds y to some variable x. A clause is called basic if 1. x - y appears in ¢ iff ¢ eliminates y,","2. For every path variable a used in ¢ there is at most one constraint zc~y E ¢."]},{"title":"203 (Eq) {c~ -/3, zay, x/3z) U ¢ {v - z, ~v} u ¢[/3.---, ~.--u] (Pre) {'~ \"~ /3' z~y, x/3z) U ¢ {x~,v} u {v/3z} u ¢[/3.- ~./3] (Join) {a ~ L, ~ ~ L'} U ¢ L :/: L' {,~ ~ (L","paragraphs":["n"]},{"title":"L')} U ¢","paragraphs":["(Divl) {a fi/3') U {a./3 fi/3'} U ¢"]},{"title":"{~ ii y} u ¢","paragraphs":["(Div2) {a-/3 fi ~./3'}"]},{"title":"U","paragraphs":["¢"]},{"title":"{/3fi y} u¢","paragraphs":["J_","(DClashl) {a'/3 fi a} U ¢ _L (DClash2)"]},{"title":"{o~ fi","paragraphs":["a}"]},{"title":"U","paragraphs":["¢ J_ (Empty)","{a ~ 0) O ¢ _L Figure 1: Simplification rules. Note that (Pre) does not introduce a new variable. A basic clause ¢ is called"]},{"title":"prime","paragraphs":["if ¢ does not contain an atomic constraint of the form p fl q, c~ -~/3 or ot - /3. Every clause ¢ in the original Kaplan/Maxwell syntax can be translated into a prime clause 7 such that ¢ is consistent iff 9' is consistent.","Now let's turn to the output clauses of the first step. A basic clause is said to be"]},{"title":"pre-soived","paragraphs":["if the following holds:"]},{"title":"1. Ax","paragraphs":["6 ¢ and"]},{"title":"Bz 6 ¢5","paragraphs":["implies A - B. 2. c~ d L 6 ¢ and a d L' 6 ¢ implies L = L*.","Furthermore, a d O is not in ¢. 3. a-/3, c~ -/3 or a ~/3 are not contained in ¢. 4. afl/36¢iffa~/3, x(~y6¢andz/3z6¢. Lemma 4.1"]},{"title":"A pre-soived clause ¢ is consistent iff there is a path valuation V~, with VT~ ~ Cp, where Cp is the set of path constraints in ~.","paragraphs":["Now let's turn to the rule system. As we have explained informally, the first rule adds nondeterministiely relational constraints between path variables. In one step we will add the relations between one fixed variable a and all other path variables/3 which are used under the same node x as a. Furthermore, we will consider only the constraints","- /3, c~ fl /3 and a ~ /3 and not additionally the constraint a 9/3.","For better readability we will use pseudo-code for describing this rule (using the usual don't care/don't know distinction for non-determinism): (PathRel) Choose"]},{"title":"x","paragraphs":["6"]},{"title":"l)arsx(¢)","paragraphs":["(don't care) Choose"]},{"title":"xay","paragraphs":["6 ¢ (don't know) For each"]},{"title":"x/3z","paragraphs":["6 ¢ with c~ #/3 and c~ fl/3 ~ ¢ add a 6~/3 with 5Z 6 {-, 4~, fl} (don't know)","\"don't care non-determinism\" means that one is free to choose an arbitrary alternative at this choose point, whereas \"don't know\" means that one has to consider every alternative in parallel (i.e. for every alternative of the don't care non-determinism a clause ¢ is equivalent to the set of all don't know alternatives that can be generated by applying the rule to ¢). Note that the order of rule application is another example for don't care non-determinism in our rule system.","Although we have restricted the relations 6~ to {-, :(, u}, this rule is globally preserving since we have non-deterministically chosen"]},{"title":"zay.","paragraphs":["To see this let ¢ be a clause, 27 be an interpretation and"]},{"title":"(Vx, VT~)","paragraphs":["be a valuation in 27 with"]},{"title":"(Vx, V~) ~z ¢.","paragraphs":["To find an instance of (PathRel) such that"]},{"title":"(Vx,","paragraphs":["V~,) ~z 7 where 3' is the result of applying this instance, we choose"]},{"title":"xay","paragraphs":["6 ¢ with V~(a) is prefix minimal in"]},{"title":"{v~@ 1~/3z ~ ¢}.","paragraphs":["Then for each x/3z 6 ¢ with a #/3 and ~ fi /3 ~ ¢ we add a 6~ /3 where"]},{"title":"Vp(a) o~ V~(/3)","paragraphs":["holds. Note that 5 0 equals ~ will not occur since we have chosen a path variable a whose interpretation is prefix minimal. Therefore, the restriction 6~ 6 {-, k, fi} is satisfied.","We have defined (PathRel) in a very special way. The reason for this is that only by using this special definition we can maintain the condition that concatenation of path variables is restricted to binary concatenation. E.g. assume that we would have added both"]},{"title":"/31","paragraphs":["\"~ O~ and a :¢ /32 to a clause 7. Then first splitting up the variable a into/31 .a' and then 132 into a./3~ will result in a substitution of/32 in 7 by/31\"a\"/3~. By the definition of (PathRel) we have ensured that this does not occur.","The second non-deterministic rule is used in the decomposition of regular languages. For decomposition we have the following rules: (DecClash) {a./3~L} O ¢ {w e"]},{"title":"L llwl","paragraphs":["> 1} = g _L (LangDecn) {a.fl ~ L) U ¢"]},{"title":"P.S C L {o~P} U {/3~S} U¢","paragraphs":["where P, S, L C F + and A is a finite set of reg. languages with L, P, S 6 A. L must contain a word w with [w[ > 1. The clash rule is needed since we require regular languages not to contain the empty path. The remaining rules are listed in Figure 1.","We use A in (LangDecA) as a global restriction, i.e. for every A we get an different rule (LangDecA) (and hence a different rule system 7~A). This is done because the rule system is quasi-terminating. By restricting (LangDeca) we can guarantee that only finitely many regular languages are produced. 204","For (LangDec)̂ to be globally preserving we need to find a suitable pair P, S in A for every possible valuation of (~ and ]3. Therefore, we require A to satisfy VL E A, Vwl, w2 ~ e : [WlW 2 E L =:~"]},{"title":"BP, S","paragraphs":["e"]},{"title":"A : (P.S C_ L A Wl","paragraphs":["E"]},{"title":"PAw2","paragraphs":["e S)]. We will call A"]},{"title":"closed under decomposition","paragraphs":["if it satisfies this condition. Additionally we have to ensure that L E A for every L that is contained in some clause ¢. We will call such a set A"]},{"title":"C-closed.","paragraphs":["Surely, we will not find a"]},{"title":"finite","paragraphs":["A that is closed under decomposition and C-closed for arbitrary ¢. But the next lemma states some weaker condition that suffices. We say that 7 is a"]},{"title":"(¢,TiA)-derivative","paragraphs":["if 7 is derivable from C by using only rules from 7~h. If R̂ is clear from the context, we will just say that 7 is a C-derivative. Lemma 4.2"]},{"title":"1. If A is C-closed and closed under intersection, then A is 7-closed for all (C, T~h)-derivaLives 7. 2. For every prime clause C there is a","paragraphs":["finite A"]},{"title":"such that A is C-closed and closed under intersection and decomposition.","paragraphs":["The proof of this lemma (containing the construc-tion of the set A) can be found in the appendix. 4.2 Completeness and Quasi-Termination The rule system serves for an algorithm to transform a prime clause into an equivalent set of pre-solved clauses. The rules are applied in arbitrary order until a pre-solved clause has been derived. If one of the non-deterministic rules is applied, a clause is substituted by a whole set of clauses, one for each of the don't know alternatives. Since the rule system is quasi-terminating, we may encounter cycles during the application of the rules. In this case we skip the corresponding alternative, since every pre-solved clause that can be produced via a cyclic derivation can also be produced via a derivation that does not contain a cycle. Theorem 4.3"]},{"title":"Let ¢ be a prime clause. If A is C- closed, closed under intersection and decomposition, then","paragraphs":["[[C] z = U.y~ [[7] z"]},{"title":"for every interpretation Z, where ¢b is the set of pre-solved (C, T~)̂-derivatives. The set (9 is finite and effectively computable.","paragraphs":["To prove this theorem we have to show that the rule system is sound and complete. Sound means, that we do not add new solutions during the processing, whereas complete means that we find all solutions in the set of pre-solved derivatives.","For the completeness it normally suffices to show that (1) every rule preserves (or globally preserves) the initial solutions and (2) the pre-solved clauses are exactly the T~h-irreducible clause (i.e. if a clause is not pre-solved, then one rule applies). But in our case this is not sufficient as the rule system is quasiterminating. A prime clause ¢ may have a solution"]},{"title":"Vx","paragraphs":["which is a solution of all (C, T~A)-derivatives in some cyclic derivation, but can not be found in any pre-solved (¢, T~h)-derivative. We have to show that this cannot happen. Since this part of the proof is unusual, we will explain the main idea (see the appendix for a more detailed outline of the proofs).","Let ¢ be some (consistent) prime clause and let"]},{"title":"Vx E","paragraphs":["~¢]z for some Z. Then there exists a path valuation Vp such that"]},{"title":"(Vx,","paragraphs":["V~) ~z ¢. We will find a pre-solved C-derivative that has"]},{"title":"Vx","paragraphs":["as a solution by imposing an additional control that depends on V~,. This control will guarantee (1) finiteness of derivations, (2) that each derivation ends with a pre-solved clause, (3) the initial solution is a solution of every clause that is derivable under this control. Since the (Pre) rule does not preserve the initial path valuation V~, (recall that the variable fl is substituted by the term a.~), we have to change the path valuation V~, every time (Pre) is applied. It is important to no-tice that this control is only used for proof purposes and not part of the algorithm. For the algorithm it suffices to encounter"]},{"title":"all","paragraphs":["pre-solved e-derivatives.","To understand this control, we will compare derivations in our syntax to derivations in standard feature logic. Recall that we have a two-level interpretation. A constraint"]},{"title":"xay","paragraphs":["is valid under"]},{"title":"Vx","paragraphs":["and V~ if"]},{"title":"xV~(c~)y","paragraphs":["is valid under"]},{"title":"Vx.","paragraphs":["Hence, for each clause ¢ and each valuation"]},{"title":"Vx, Vp","paragraphs":["with C valid under"]},{"title":"Vx","paragraphs":["and Vp there is a clause Cv~ in standard feature logic syntax (not containing functional uncertainty) such that ¢v~ is valid under"]},{"title":"Vx.","paragraphs":["E.g. for the clause"]},{"title":"{xax, a~f, xflz, fl~f*g}","paragraphs":["and a path valuation V~, with VT,(a) = f and V~,(j3) = g the clause Cv~, is"]},{"title":"{xfx, xgy}.","paragraphs":["The control we have mentioned requires (by and large) that only those rewrite rules will be applied, that are compatible to the clause Cv~ and thus preserve"]},{"title":"Vx.","paragraphs":["If one of the rules (Eq) or (Pre) is applied, we also have to rewrite Cv~. Tak-ing the above example, we are only allowed to add ali fl to C (using (PathRel)), since ev~ is already in pre-solved form.","Now let's vary the example and let Vp be a path valuation with V~,(a) = f and V~,(f~) = Hg. Then we have to add a ~ /3 in the first step, since this relation holds between a and ft. The next step is to apply (Pre) on a :~ /3. Here we have to rewrite both ¢ and Cv~. Hence, the new clauses ¢1 and evv are"]},{"title":"{xax, a~f, x/3z, a./3~ f*g}","paragraphs":["and"]},{"title":"{x f x, x fgy}","paragraphs":["respectively. Note that the constraint"]},{"title":"xffgy has","paragraphs":["been reduced to"]},{"title":"x fg y","paragraphs":["by the application of (Pre). Since infinite derivations must infinitely often use (Pre), this control guarantees that we find a pre-solved clause that has"]},{"title":"Vx","paragraphs":["as a solution. 5 The Second Phase In the second phase we have to check consistency of pre-solved clauses. As we have mentioned, a pre-solved clause is consistent if we find some appropriate path valuation. This means that we have to check the consistency of divergence constraints of the form al fi a2 together with path restrictions"]},{"title":"205","paragraphs":["al ~ L1 and a2 ~ L2. A constraint al ti a2 is va|id under some valuation V~, if there are (possibly empty) words w, wl, w2 and features'f ~ g such that V~,(al) ="]},{"title":"WfWl","paragraphs":["and V~,(c~2) ="]},{"title":"wgw2.","paragraphs":["This definition could directly be used for a rewrite rule that solves a single divergence constraint, which gives us {al fi ct2} U¢"]},{"title":"f#g,","paragraphs":["~,~1 2new where ¢' = ¢[al ~--/?.a~,a2 ~/3.a~]. By the application of this rule we will get constraints of the form j3.a~ ~ L1 and fl.a~ ~ L2. Decomposing these restriction constraints and joining the corresponding path restrictions for ~ and ~,~ will result in {fl~ (Pl nP2), ~i ~ (S~:*ns,), ,~ (g~'*MS2)} with"]},{"title":"PI.S~ C L~","paragraphs":["and"]},{"title":"P2.S2 C_ L~,","paragraphs":["which completes the consistency check.","Additionally, one has to consider the effects of introducing the path terms/~.a~. The main part of this task is to resolve constraints of the form fl.tr~ li tr. There are two possibilities: Either a has also f~ as an prefix, in which case we have to add fl ~ a; or fl is not a prefix of c~, which means that we have to add c~ fl ft. After doing this, the introduced prefix constraints have to be evaluated using (Pre). (In the appendix we present a solution which is more appropriate for proofing termination). 6 Kaplan and Maxwell's Method We are now able to compare our method with the one used by Kaplan and Maxwell. In our method, the non-deterministic addition of path relation and the evaluation of these relations are done at different times. The evaluation of the introduced constraints c~ - fl and o~ :¢ fl are done after (PathRel) in the first phase of the algorithm, whereas the evaluation of the divergence constraints is done in a separate second phase.","In Kaplan and Maxwell's algorithm all these steps are combined into one single rule. Roughly, they substitute a clause"]},{"title":"{xL~y, xL2z,","paragraphs":["} O ¢ nondeterministicly by one of the following clauses: ~"]},{"title":"{ x(L~f3L~)y, x-y}U¢ { x(L~f3P)y, ySz }U¢ P.SC_L~ { x(L~NP)z, zSy }U¢ P.S C L1 { x(P1NP2)u, u(f.S1)y, u(g.S2)z","paragraphs":["}U¢ with"]},{"title":"PI'f'S~ C_ L~, P2\"g'S~ C_ L~, f # g, u","paragraphs":["new Recall that"]},{"title":"{XLly, xL2z}","paragraphs":["is expressed in our syntax by the clause 3' ="]},{"title":"{xay, o~ ~ L1, x~z, j~ ~ L2},","paragraphs":["which is the example we have used on page 2. The first three cases correspond exactly to the result of the","2This is not the way their algorithm was originally described in [5] as they use a slightly different syntax. Furthermore, they don't use non-deterministic rules, but use a single rule that produces a disjunction. However, the way we describe their method seems to be more appropriate in comparing both approaches. derivations that have been described for 72, 73 and 3'4. By and large, the last case is achieved if we first add c~ [I ~ to 3' and then turn over to the second phase as described in the last section.","The problem with Kaplan/Maxwell's algorithm is that one has to introduce a new variable u in the last case, since there is no other possibility to express divergence. If their rule system is applied to a cyc!ic description, it will not terminate as the last part in-troduces new variables. Hence it cannot be used for an algorithm in case of cyclic descriptions.","The delaying of the evaluation of divergence constraint may not only be useful when applied to cyclic feature descriptions. As Kaplan and Maxwell pointed out, it is in general useful to postpone the consistency check for functional uncertainty. With the algorithm we have described it is also possible to delay single parts of the evaluation of constraints containing functional uncertainty. Appendix Proof of Lemma 4.2. The first claim is easy to prove. For the second claim let {L1,...,Ln} C P(~+) be the set of regular languages used in ¢ and let"]},{"title":".Ai = (Q.4~, i.4~, cr a~, Fin.4~)","paragraphs":["be finite, deterministic automatons such that .A i recognizes"]},{"title":"Li.","paragraphs":["For each .Ai we define dec(.Ai) to be the set dee(A/)"]},{"title":"= {L~ ]p,q E","paragraphs":["QJt,}, whereL~ = {w E 2 \"+ I a~,(p,w) = q}. It is easy to show that dec(.Ai) is a set of regular languages that contains"]},{"title":"Li","paragraphs":["and is closed under decomposition. Hence, the set A0 = [.Jinx dec (Ai) contains each"]},{"title":"Li","paragraphs":["and is closed under decomposition. Let A = fi (A0) be the least set that contains A0 and is closed under intersection. Then A is finite and e-closed, since it contains each"]},{"title":"Li.","paragraphs":["We will prove that A is also closed under decomposition. Given some L E A and a word w ="]},{"title":"wlw2 E L,","paragraphs":["we have to find an appropriate decomposition P, S in A. Since each L in A can be written as a finite","m L intersection L = Nk=l i~ where"]},{"title":"Lik","paragraphs":["is in A0, we know that w ="]},{"title":"wlw2","paragraphs":["is in"]},{"title":"Li~","paragraphs":["for 1..m. As A0 is closed under decomposition, there are languages Pi~ and"]},{"title":"Si~","paragraphs":["for k = 1..m with"]},{"title":"wl E Pi~, w2 E Si~","paragraphs":["and Pik'Sik C Li~. Let P = M~n=l Pik and S ="]},{"title":"s,~.","paragraphs":["Clearly, wl 6 P, w2 6 S and"]},{"title":"P.S C L.","paragraphs":["Furthermore, P, S 6 A as A is closed under intersection. This implies that P, S is an appropriate decomposition for Wl W2 . I\"1 A.1 Phase I: Soundness, Completeness and","Quasi-Termination Proposition A.1"]},{"title":"The rule","paragraphs":["(PathRel)"]},{"title":"is X U 12- sound and globally X U 12-preserving. If A is closed under decomposition, then","paragraphs":["(LangDec)̂"]},{"title":"is X U 12- sound and globally X U IJ-preserving. The","paragraphs":["(Pre)"]},{"title":"rule is X-sound and X-preserving. All other rules are X U 13-sound and X U 13-preserving. 206","paragraphs":["Next we will prove some syntactic properties of the clauses derivable by the rule system. For the rest of the paper we will call clauses that are derivable from prime clauses admissible. Proposition A.2 Every admissible clause is basic. Ira -~ 13, o~ -- [3 or c~ (I 13 is contained in some admissible clause ¢, then there is a variable z such that zc~y and zflz is in ¢.","Note that (by this proposition) (Pre) (resp. (Eq)) can always be applied if a constraint c~ 4 [3 (resp.","-/3) is contained in some admissible clause. The next lemma will show that different applications of (Pre) or (Eq) will not interact. This means the application of one of these rule to some prefix or path equality constraint will not change any other prefix or path equality constraint contained in the same clause. This is a direct consequence of the way (PathP~el) was defined. Lemma A.3 Given two admissible clauses 7, 7' with 7 ---~r 7' and r different from (PathRel). Then c~ \"- 13 E 7' (resp. ~ 4 13 E 7 I) implies ~ -- 13 E 7 (resp. a :¢ [3 E 7). Furthermore, if a.13 is contained in 7', then either a.fl or a -~ 13 is contained in 7.","Note that this lemma implies that new path equality or prefix constraints are only introduced by (PathRel). We can derive from this lemma some syntactic properties of admissible clauses which are needed for proving completeness and quasitermination.","Lemma A.4 If ¢ is an admissible clause, then","1. If c~ :< 13 is contained in ¢, then there is no other prefix or equality constraint in ¢ involving 13. Furthermore, neither 13.[3~ nor 13~.[3 is contained in ¢.","e. ira.13 fi 13' is in ¢, then either 13' equals a or ¢ contains a constraint of form afi t3', a - 13' or",":~ ~'.","The first property will guarantee that concatenation does not occur in prefix or equality constraints and that the length of path concatenation is restricted to 2. The second property ensures that a constraint c~.13 fi 13' is always reducible. Theorem A.5 For every finite A the rule system 7~a is quasi-terminating. Proof. The rule system produces only finitely many different clauses since the rules introduce no additional variables or sort symbols and the set of used languages is finite. Additionally, the length of concatenation is restricted to 2. [] Lemma A.6 There are no infinite derivations using only finitely many instances of (Pre).","Since the rule system is quasi-terminating, the completeness proof consists of two parts. In the first part we will proof that pre-solved clauses are just the irreducible clauses. In the second part we will show that one finds for each solution Vx of a prime clause ¢ a pre-solved e-derivative 7 such that Vx is also a solution of 7. Theorem A.7 (Completeness I) Given an admissible clause ¢ ~ _1_ such that ¢ is not in pre-solved form. If A is e-closed and closed under decomposition, then ¢ is T~A-reducible. Theorem A.8 (Completeness II) For every prime clause ¢ and for every A that is e-closed, closed under decomposition and intersection we have"]},{"title":"I¢] _c U b] z","paragraphs":["7 E pre-solved (¢,R)̂ where pre-solved(¢,R)̂ is the set of pre-solved (¢, R A )-derivat ives. Proof (Sketch) We have to show, that for each prime clause ¢ and each Vx, V~,Z with (Vx, V~) ~z ¢ there is a pre-solved (¢, T~A)-derivative 7 such that Vx E ~7] z. We will do this by controlling derivation using the valuation (Vx, VT~). The control will guarantee finiteness of derivations and will maintain the first completeness property, namely that the irreducible clauses are exactly the pre-solved clauses.","We allow only those instances of the non-deterministic rules (PathRel) and (LangDecA), which preserve exactly the valuation (Vx, V~). That means if (Vx,V~) ~z ¢ and ¢ --~r 7 for one of these rules, then (Va', V~) ~z 7 must hold. Note that the control depends only on VT,. E.g. for the clause ¢ = {xc~y, a ~ L1, x13z, 13~ L2} and arbitray Z, Vx this means that if VT,(a) = f, V~,(13) = g and (Vx, VT,) ~z ¢, the rule (PathRel) can transform ¢ only into {a h 13} U ¢.","If V~, satisfies V~, (tr) 7~ V~, (13) for ~ different from fl with zcry E ¢ and 213z E ¢, we cannot add any prefix constraint using this control. Hence, (Pre) cannot be applied, which implies (by lemma A.6) that in this case there is no infinite controlled derivation. We will call such path valuations prefix-free with respect to"]},{"title":"¢.","paragraphs":["If V~, is not prefix-free, then (Pre) will be applied during the derivations. In this case we have to change the path valuation, since (Pre) is not P-preserving. If (Vx, V~) ~z ¢ = {a k 13} U ¢ and we apply (Pre) on cr -~ fl yielding 7, then the valuation V¢ with v (13) = and = for #","will satisfy (Vx, pz % We will use for controlling the further derivations.","If we change the path valuation in this way, there will again be only finite derivations. To see this, note that every time (Pre) is applied and the path valuation is changed, the valuation of one variable is shortened by a non-empty path. As the number of variables used in clauses does not increase, this shortening can only be done finitely many times. This implies, that (Pre) can only finitely often be applied under this control. Hence (by lemma A.6), there are again only finite controlled derivations. 1:3 207 A.2 Consistency of Pre-Solved Clauses We will first do a minor redefinition of divergence. We say that two paths u, v are directly diverging (written u u0 v) if there are features f ~ g such that u E f/'* and v 6 g/'*. Then u n v holds if there are a possible empty prefix w and paths u', v' such that u = wu' and v = wC and u' n0 v'.","We will reformulate the reduction of divergence constraints in order to avoid constraints of form a.fl fi fl'. Handling such constraints would make the termination proof somewhat complicated. For the reformulation we use a special property of pre-solved clauses, namely that a fi fl is in a pre-solved clause ¢ iff zay and zflz is in ¢. Hence, if a fi/? and ~ fi df is in ¢, then a Ii df is also in ¢. This implies, that we can write ep as fi(At) ~...~ fl(A,) t9 ¢, where fl (A) is a syntactic sugar for fi(A) = {a fia' I a # a'Aa, a' 6 A}, As,...,An are disjoint sets of path variables and ¢ does not contain divergence constraints. Note that for every Ai = {al,...,a,} there are variables x, Yt,...,yn such that {xatyt,...,x~,y,} C_ ¢. Now given such that a constraint fi (A), we assume that a whole set of path variables A1 C A diverges with the same prefix ft. That means we can replace fl(At) C fl(A) by As = fl.A',O fi0(A~), where fl is new, A~ = {a~,..., a~} is a disjoint copy of A1 = {or1,...,an} and A - fi.A~ is an abbreviation for the clause {al - fl'a~,..., c~, - fl.a~}. fl 0(A) is defined similar to fl (A). Assuming additionally that the common prefix fl is maximal implies that fl fl a holds for a E (A-A1). If we also consider the effects of A1 = fl'A'l on the subterm agreements in ¢ that involves variables of At, then we result in the following rule:"]},{"title":".A, YxU fi(A) u","paragraphs":["(Red1) {xflz} U zA'IY1 U fi0(A~) U Ii({fl}UA2) U ¢' where ¢' = ¢[al ~-- fl'a~,..., a, ~ fl.a'], AI~A2 =A,"]},{"title":"IAll >","paragraphs":["1 and z, fl new. A~ is a disjoint copy of A1. xAtY1 is short for {zalm,...,za,y,}. ¢ may not contain constraints of form 6.6 ~ L in ¢. Note that we have avoided constraints of the form a-fl fi fit The rules (Reds) fl (A) U %b fi0(A) U¢"]},{"title":"u¢ (so,v)","paragraphs":["o"]},{"title":"f~#f~, for a#~'","paragraphs":["together with the rules (LangDech), (Join) and (Empty) completes the rule system 7~ °iv. (Reds) is needed as path variables always denote non-empty paths. We will view (Redz) and (Red2) as one single rule (Reduce).","A clause ~ is said to be solved if (1) a.fl ~ L and ot~0 is not in ep; (2) a~L1 in ep and a~L~ in ep implies Lz = L2; (3) ¢ does not contain constraints of form afl fl, a Ii0 fl, oL :< fl, or a -\" fl; and (4) for every {xay, z/~z} _C ~ with a ¢/? there are features f #g with {a~fLs,fl~gL2} _C ¢. It is easy to see that every solved clause is consistent. Note that every solved clause is also prime. Lemma A.9 The rules (Reduce) = (Redt) + (Reds) and (Solv) are X-sound and globally X-preserving. Furthermore, 7~ s°lv is terminating. Lemma A.10 Let ¢ be a pre-soived clause. If A is e-closed, closed under intersection and decomposition, then a (¢, TiS°lv)-derivative different from 1 is irreducible if and only if it is solved. Finally we can combine both phases of the algorithm. Theorem A.11 Consistency of prime clauses is decidable."]},{"title":"References","paragraphs":["[1] F. Baader, H.-J. Bfirckert, B. Nebel, W. Nutt, and G. Smolka. On the expressivity of feature logics with negation, functional uncertainity, and sort equations. Research Report RR-91-01, DFKI, 1991.","[2] R. Backofen. Regular path expressions in feature logic. Research Report RR-93-17, DFKI, 1993.","[3] R. Backofen and G. Smolka. A complete and recursire feature theory. In Proc. of the 31 th ACL, 1993. this volume.","[4] N. Dershowitz. Termination of rewriting. Journal of Symbolic Computation, 3:69-116, 1987.","[5] R. M. Kaplan and J. T. Maxwell III. An algorithm for functional uncertainty. In Proc. of the 12th COL-ING, pages 297-302, Budapest, Hungary, 1988.","[6] R. M. Kaplan and A. Zaenen. Functional uncertainty and functional precedence in continental west germanic. In H. Trost, editor, 4- (gsterreichische Artificial-lnteiligence- Tagung: Wiener Workshop-Wissensbasierte Sprachverarbeitung, pages 114-123. Springer, Berlin, Heidelberg, 1988.","[7] R. M. Kaplan and A. Zaenen. Long-distance dependencies, constituent structure, and functional uncertainty. In M. Baltin and A. Kroch, editors, Alternative Conceptions of Phrase Structure. University of Chicago Press, Chicago, 1988.","[8] B. Keller. Feature logics, infinitary descriptions and the logical treatment of grammar. Cognitive Science Research Report 205, Univerity of Sussex, School of Cognitive and Computing Sciences, 1991.","[9] G. Smolka. A feature logic with subsorts. LILOG-Report 33, IBM Deutschland, Stuttgart, 1988.","[10] G. Smolka. Feature constraint logics for unification grammars. Journal of Logic Programming, 12:51-87, 1992.","[11] G. Smolka and R. Treinen. Records for logic programming. In Proceedings of the 1992 Joint International Conference and Symposium on Logic Programming, pages 240-254, Washington, DC, 1992."]},{"title":"208","paragraphs":[]}]}
