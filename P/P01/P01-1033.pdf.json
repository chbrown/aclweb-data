{"sections":[{"title":"Towards Abstract Categorial Grammars Philippe de Groote LORIA UMR n","paragraphs":["o"]},{"title":"7503 – INRIA Campus Scientifique, B.P. 239 54506 Vandœuvre lès Nancy Cedex – France degroote@loria.fr Abstract","paragraphs":["We introduce a new categorial formalism based on intuitionistic linear logic. This formalism, which derives from current type-logical grammars, is abstract in the sense that both syntax and semantics are handled by the same set of primitives. As a consequence, the formalism is reversible and provides different computational paradigms that may be freely composed together."]},{"title":"1 Introduction","paragraphs":["Type-logical grammars offer a clear cut between syntax and semantics. On the one hand, lexical items are assigned syntactic categories that combine via a categorial logic akin to the Lambek calculus (Lambek, 1958). On the other hand, we have so-called semantic recipes, which are expressed as typed λ-terms. The syntax-semantics interface takes advantage of the Curry-Howard correspondence, which allows semantic readings to be extracted from categorial deductions (van Benthem, 1986). These readings rely upon a homomorphism between the syntactic categories and the semantic types.","The distinction between syntax and semantics is of course relevant from a linguistic point of view. This does not mean, however, that it must be wired into the computational model. On the contrary, a computational model based on a small set of primitives that combine via simple composition rules will be more flexible in practice and easier to implement.","In the type-logical approach, the syntactic contents of a lexical entry is outlined by the following patern:","<atom> : <syntactic category> On the other hand, the semantic contents obeys the following scheme:","<λ-term> : <semantic type> This asymmetry may be broken by:","1. allowing λ-terms on the syntactic side (atomic expressions being, after all, particular cases of λ-terms),","2. using the same type theory for expressing both the syntactic categories and the semantic types. The first point is a powerfull generalization of the usual scheme. It allows λ-terms to be used at a syntactic level, which is an approach that has been advocated by (Oehrle, 1994). The second point may be satisfied by dropping the non-commutative (and non-associative) aspects of categorial logics. This implies that, contrarily to the usual categorial approaches, word order constraints cannot be expressed at the logical level. As we will see this apparent loss in expressive power is compensated by the first point."]},{"title":"2 Definition of a multiplicative kernel","paragraphs":["In this section, we define an elementary grammatical formalism based on the ideas presented in the introduction. This elementary formalism is founded on the multiplicative fragment of linear logic (Girard, 1987). For this reason, we call it a multiplicative kernel. Possible extensions based on other fragments of linear logic are discussed in Section 5. 2.1 Types, signature, and λ-terms We first introduce the mathematical apparatus that is needed in order to define our notion of an abstract categorial grammar.","Let A be a set of atomic types. The set T (A) of linear implicative types built upon A is inductively defined as follows: 1. if a ∈ A, then a ∈ T (A); 2. if α, β ∈ T (A), then (α −◦ β) ∈ T (A).","We now introduce the notion of a higher-order linear signature. It consists of a triple Σ = ⟨A, C, τ ⟩, where: 1. A is a finite set of atomic types; 2. C is a finite set of constants;","3. τ : C → T (A) is a function that assigns to each constant in C a linear implicative type in T (A).","Let X be a infinite countable set of λ-variables. The set Λ(Σ) of linear λ-terms built upon a higher-order linear signature Σ = ⟨A, C, τ ⟩ is inductively defined as follows: 1. if c ∈ C, then c ∈ Λ(Σ); 2. if x ∈ X, then x ∈ Λ(Σ);","3. if x ∈ X, t ∈ Λ(Σ), and x occurs free in t exactly once, then (λx. t) ∈ Λ(Σ);","4. if t, u ∈ Λ(Σ), and the sets of free variables of t and u are disjoint, then (t u) ∈ Λ(Σ). Λ(Σ) is provided with the usual notion of capture avoiding substitution, α-conversion, and β- reduction (Barendregt, 1984).","Given a higher-order linear signature Σ = ⟨A, C, τ ⟩, each linear λ-term in Λ(Σ) may be assigned a linear implicative type in T (A). This type assignment obeys an inference system whose judgements are sequents of the following form: Γ −Σ t : α where:","1. Γ is a finite set of λ-variable typing declarations of the form ‘x : β’ (with x ∈ X and β ∈ T (A)), such that any λ-variable is declared at most once; 2. t ∈ Λ(Σ); 3. α ∈ T (A). The axioms and inference rules are the following: −Σ c : τ (c) (cons) x : α −Σ x : α (var) Γ, x : α −Σ t : β (abs) Γ −Σ (λx. t) : (α −◦ β) Γ −Σ t : (α −◦ β) ∆ −Σ u : α (app) Γ, ∆ −Σ (t u) : β","2.2 Vocabulary, lexicon, grammar, and language We now introduce the abstract notions of a vocabulary and a lexicon, on which the central notion of an abstract categorial grammar is based.","A vocabulary is simply defined to be a higher-order linear signature.","Given two vocabularies Σ1 = ⟨A1, C1, τ1⟩ and Σ2 = ⟨A2, C2, τ2⟩, a lexicon L from Σ1 to Σ2 (in notation, L : Σ1 → Σ2) is defined to be a pair L = ⟨F, G⟩ such that:","1. F : A1 → T (A2) is a function that interprets the atomic types of Σ1 as linear implicative types built upon A2;","2. G : C1 → Λ(Σ2) is a function that interprets the constants of Σ1 as linear λ-terms built upon Σ2;","3. the interpretation functions are compatible with the typing relation, i.e., for any c ∈ C1, the following typing judgement is derivable: −Σ2 G(c) : F̂ (τ1(c)), where F̂ is the unique homomorphic extension of F .","As stated in Clause 3 of the above definition, there exists a unique type homomorphism F̂ : T (A1) → T (A2) that extends F . Similarly, there exists a unique λ-term homomorphism Ĝ : Λ(Σ1) → Λ(Σ2) that extends G. In the sequel, when ‘L ’ will denote a lexicon, it will also denote the homorphisms F̂ and Ĝ induced by this lexicon. In any case, the intended meaning will be clear from the context.","Condition 3, in the above definition of a lexicon, is necessary and sufficient to ensure that the homomorphisms induced by a lexicon commute with the typing relations. In other terms, for any lexicon L : Σ1 → Σ2 and any derivable judgement x0 : α0, . . . , xn : αn −Σ1 t : α the following judgement x0 : L (α0), . . . , xn : L (αn) −Σ2 L (t) : L (α) is derivable. This property, which is reminiscent of Montague’s homomorphism requirement (Montague, 1970b), may be seen as an abstract realization of the compositionality principle.","We are now in a position of giving the definition of an abstract categorial grammar.","An abstract categorial grammar (ACG) is a quadruple G = ⟨Σ1, Σ2, L , s⟩ where:","1. Σ1 = ⟨A1, C1, τ1⟩ and Σ2 = ⟨A2, C2, τ2⟩ are two higher-order linear signatures; Σ1 is called the abstract vovabulary and Σ2 is called the object vovabulary;","2. L : Σ1 → Σ2 is a lexicon from the abstract vovabulary to the object vovabulary;","3. s ∈ T (A1) is a type of the abstract vocabulary; it is called the distinguished type of the grammar.","Any ACG generates two languages, an abstract language and an object language. The abstract language generated by G (A(G )) is defined as follows: A(G ) = {t ∈ Λ(Σ1) | −Σ1 t : s is derivable} In words, the abstract language generated by G is the set of closed linear λ-terms, built upon the abstract vocabulary Σ1, whose type is the distinguished type s. On the other hand, the object language generated by G (O(G )) is defined to be the image of the abstract language by the term homomorphism induced by the lexicon L : O(G ) = {t ∈ Λ(Σ2) | ∃u ∈ A(G ). t = L (u)}","It may be useful of thinking of the abstract language as a set of abstract grammatical structures, and of the object language as the set of concrete forms generated from these abstract structures. Section 4 provides examples of ACGs that illustrate this interpretation. 2.3 Example In order to exemplify the concepts introduced so far, we demonstrate how to accomodate the PTQ fragment of Montague (1973). We concentrate on Montague’s famous sentence: John seeks a unicorn (1) For the purpose of the example, we make the two following assumptions:","1. the formalism provides an atomic type ‘string’ together with a binary associative operator ‘+’ (that we write as an infix operator for the sake of readability);","2. we have the usual logical connectives and quantifiers at our disposal. We will see in Section 4 and 5 that these two as-sumptions, in fact, are not needed.","In order to handle the syntactic part of the example, we define an ACG (G12). The first step consists in defining the two following vocabularies:","Σ1 = ⟨ {n, np, s}, {J, Sre , Sdicto, A, U }, {J ↦→ np, Sre ↦→ (np −◦ (np −◦ s)), Sdicto ↦→ (np −◦ (np −◦ s)), A ↦→ (n −◦ np), U ↦→ n} ⟩","Σ2 = ⟨ {string}, {John, seeks, a, unicorn}, {John ↦→ string, seeks ↦→ string, a ↦→ string, unicorn ↦→ string} ⟩ Then, we define a lexicon L12 from the abstract vocabulary Σ1 to the object vocabulary Σ2:","L12 = ⟨ {n ↦→ string, np ↦→ string, s ↦→ string}, {J ↦→ John, Sre ↦→ λx. λy. x + seeks + y, Sdicto ↦→ λx. λy. x + seeks + y, A ↦→ λx. a + x, U ↦→ unicorn} ⟩ Finally we have G12 = ⟨Σ1, Σ2, L12, s⟩.","The semantic part of the example is handled by another ACG (G13), which shares with G12 the same abstract language. The object language of this second ACG is defined as follows:","Σ3 = ⟨ {e, t}, {JOHN, TRY-TO, FIND, UNICORN}, {JOHN ↦→ e, TRY-TO ↦→ (e −◦ ((e −◦ t) −◦ t)), FIND ↦→ (e −◦ (e −◦ t)), UNICORN ↦→ (e −◦ t)} ⟩ Then, a lexicon from Σ1 to Σ3 is defined:","L13 = ⟨ {n ↦→ (e −◦ t), np ↦→ ((e −◦ t) −◦ t), s ↦→ t}, {J ↦→ λP. P JOHN, Sre ↦→ λP. λQ. Q (λx. P","(λy. TRY-TO y (λz. FIND z x))), Sdicto ↦→ λP. λQ. P","(λx. TRY-TO x","(λy. Q (λz. FIND y z))), A ↦→ λP. λQ. ∃x. P x ∧ Q x, U ↦→ λx. UNICORN x} ⟩ This allows the ACG G13 to be defined as ⟨Σ1, Σ3, L13, s⟩.","The abstract language shared by G12 and G13 contains the two following terms: Sre J (A U ) (2) Sdicto J (A U ) (3) The syntactic lexicon L12 applied to each of these terms yields the same image. It β-reduces to the following object term: John + seeks + a + unicorn On the other hand, the semantic lexicon L13 yields the de re reading when applied to (2): ∃x. UNICORN x ∧ TRY-TO JOHN (λz. FIND z x) and it yields the de dicto reading when applied to (3): TRY-TO JOHN (λy. ∃x. UNICORN x ∧ FIND y x)","Our handling of the two possible readings of (1) differs from the type-logical account of Morrill (1994) and Carpenter (1996). The main difference is that our abstract vocabulary contains two constants corresponding to seek. Consequently, we have two distinct entries in the semantic lexicon, one for each possible reading. This is only a matter of choice. We could have adopt Morrill’s solution (which is closer to Montague original analysis) by having only one abstract constant S together with the following type assignment: S ↦→ (np −◦ (((np −◦ s) −◦ s) −◦ s)) Then the types of J and A, and the two lexicons should be changed accordingly. The semantic lexicon of this alternative solution would be simpler. The syntactic lexicon, however, would be more involved, with entries such as: S ↦→ λx. λy. x + seeks + y (λz. z) A ↦→ λx. λy. y (a + x)"]},{"title":"3 Three computational paradigms","paragraphs":["Compositional semantics associates meanings to utterances by assigning meanings to atomic items, and by giving rules that allows to compute the meaning of a compound unit from the meanings of its parts. In the type logical approach, following the Montagovian tradition, meanings are expressed as typed λ-terms and combine via functional application.","Dalrymple et al. (1995) offer an alternative to this applicative paradigm. They present a deductive approach in which linear logic is used as a glue language for assembling meanings. Their approach is more in the tradition of logic programming.","The grammatical framework introduced in the previous section realizes the compositionality principle in a abstract way. Indeed, it provides compositional means to associate the terms of a given language to the terms of some other language. Both the applicative and deductive paradigms are available. 3.1 Applicative paradigm In our framework, the applicative paradigm consists simply in computing, according to the lexicon of a given grammar, the object image of an abstract term. From a computational point of view it amounts to performing substitution and β- reduction. 3.2 Deductive paradigm The deductive paradigm, in our setting, answers the following problem: does a given term, built upon the object vocabulary of an ACG, belong to the object language of this ACG. It amounts to a kind of proof-search that has been described by Merenciano and Morrill (1997) and by Pogodalla (2000). This proof-search relies on linear higher-order matching, which is a decidable problem (de Groote, 2000). 3.3 Transductive paradigm The example developped in Section 2.3 suggests a third paradigm, which is obtained as the composition of the applicative paradigm with the deductive paradigm. We call it the transductive paradigm because it is reminiscent of the mathematical notion of transduction (see Section 4.2). This paradigm amounts to the transfer from one object language to another object language, using a common abstract language as a pivot."]},{"title":"4 Relating ACGs to other grammatical formalisms","paragraphs":["In this section, we illustrate the expressive power of ACGs by showing how some other families of formal grammars may be subsumed. It must be stressed that we are not only interested in a weak form of correspondence, where only the generated languages are equivalent, but in a strong form of correspondence, where the grammatical structures are preserved.","First of all, we must explain how ACGs may manipulate strings of symbols. In other words, we must show how to encode strings as linear λ- terms. The solution is well known: it suffices to represent strings of symbols as compositions of functions. Consider an arbitrary atomic type ∗, and define the type ‘string’ to be (∗ −◦ ∗). Then, a string such as ‘abbac’ may be represented by the linear λ-term λx. a (b (b (a (c x)))), where the atomic strings ‘a’, ‘b’, and ‘c’ are declared to be constants of type (∗ −◦ ∗). In this setting, the empty word (ε) is represented by the identity function (λx. x) and concatena-tion (+) is defined to be functional composition (λf. λg. λx. f (g x)), which is indeed an associative operator that admits the identity function as a unit. 4.1 Context-free grammars Let G = ⟨T, N, P, S⟩ be a context-free grammar, where T is the set of terminal symbols, N is the set of non-terminal symbol, P is the set of rules, and S is the start symbol. We write L(G) for the language generated by G. We show how to construct an ACG GG = ⟨Σ1, Σ2, L , S⟩ corresponding to G.","The abstract vocabulary Σ1 = ⟨A1, C1, τ1⟩ is defined as follows:","1. The set of atomic types A1 is defined to be the set of non-terminal symbols N .","2. The set of constants C1 is a set of symbols in 1-1-correspondence with the set of rules P .","3. Let c ∈ C1 and let ‘X → ω’ be the rule corresponding to c. τ1 is defined to be the function that assigns the type [[ω]]X to c, where [[·]]X obeys the following inductive definition: (a) [[ε]]X = X; (b) [[Y ω]]X = (Y −◦ [[ω]]X ), for Y ∈ N ; (c) [[aω]]X = [[ω]]X , for a ∈ T . The definition of the object vocabulary Σ2 = ⟨A2, C2, τ2⟩ is as follows: 1. A2 is defined to be {∗}.","2. The set of constants C2 is defined to be the set of terminal symbols T .","3. τ2 is defined to be the function that assigns the type ‘string’ to each c ∈ C2. It remains to define the lexicon L = ⟨F, G⟩:","1. F is defined to be the function that interprets each atomic type a ∈ A1 as the type ‘string’.","2. Let c ∈ C1 and let ‘X → ω’ be the rule corresponding to c. G is defined to be the function that interprets c as λx1 . . . . λxn. |ω|, where x1 . . . xn is the sequence of λ-variables occurring in |ω|, and | · | is inductively defined as follows: (a) |ε| = λx. x; (b) |Y ω| = y + |ω|, for Y ∈ N , and where","y is a fresh λ-variable; (c) |aω| = a + |ω|, for a ∈ T . It is then easy to prove that GG is such that:","1. the abstract language A(GG) is isomorphic to the set of parse-trees of G.","2. the language generated by G coincides with the object language of GG, i.e., O(GG) = L(G).","For instance consider the CFG whose produc-tion rules are the following: S → ε, S → aSb, which generates the language an","bn",". The corresponding ACG has the following abstract language, object language, and lexicon:","Σ1 = ⟨ {S}, {A, B}, {A ↦→ S, B ↦→ ((S −◦ S)} ⟩","Σ2 = ⟨ {∗}, {a, b}, {a ↦→ string, b ↦→ string} ⟩","L = ⟨ {S ↦→ string}, {A ↦→ λx. x, B ↦→ λx. a + x + b} ⟩","4.2 Regular grammars and rational transducers Regular grammars being particular cases of context-free grammars, they may be handled by the same construction. The resulting ACGs (which we will call “regular ACGs” for the purpose of the discussion) may be seen as finite state automata. The abstract language of a regular ACG correspond then to the set of accepting sequences of transitions of the corresponding automaton, and its object language to the accepted language.","More interestingly, rational transducers may also be accomodated. Indeed, two regular ACGs that shares the same abstract language correspond to a regular language homomorphism composed with a regular language inverse homomorphism. Now, after Nivat’s theorem (Nivat, 1968), any rational transducer may be represented as such a bimorphism. 4.3 Tree adjoining grammars The construction that allows to handle the tree adjoining grammars of Joshi (Joshi and Schabes, 1997) may be seen as a generalization of the construction that we have described for the context-free grammars. Nevertheless, it is a little bit more involved. For instance, it is necessary to triplicate the non-terminal symbols in order to distinguish the initial trees from the auxiliary trees.","We do not have enough room in this paper for giving the details of the construction. We will rather give an example. Consider the TAG with the following initial tree and auxiliary tree: S ε","SNA  ","a S  d","b S∗ NA c","It generates the non context-free language","an bn","cn","dn",". This TAG may be represented by the","ACG, G = ⟨Σ1, Σ2, L , S⟩, where:","Σ1 = ⟨ {S, S′",", S′′ }, {A, B, C},","{A ↦→ ((S′′ −◦ S′",") −◦ S),","B ↦→ (S′′ −◦ ((S′′","−◦ S′",") −◦ S′",")),","C ↦→ (S′′ −◦ S′",")} ⟩","Σ2 = ⟨ {∗}, {a, b, c, d}, {a ↦→ string, b ↦→ string, c ↦→ string, d ↦→ string} ⟩","L = ⟨ {S ↦→ string, S′","↦→ string, S′′","↦→ string}, {A ↦→ λf. f (λx. x), B ↦→ λx. λg. a + g (b + x + c) + d, C ↦→ λx. x} ⟩","One of the keystones in the above translation is to represent an adjunction node A as a functional parameter of type A′′","−◦ A′",". Abrusci et al. (1999) use a similar idea in their translation of the TAGs into non-commutative linear logic."]},{"title":"5 Beyond the multiplicative fragment","paragraphs":["The linear λ-calculus on which we have based our definition of an ACG may be seen as a rudimentary functional programming language. The results in Section 4 indicate that, in theory, this rudimentary language is powerful enough. Nevertheless, in practice, it would be useful to increase the expressive power of the multiplicative kernel defined in Section 2 by providing features such as records, enumerated types, conditional expressions, etc.","From a methodological point of view, there is a systematic way of considering such extensions. It consists of enriching the type system of the formalism with new logical connectives. Indeed, each new logical connective may be interpreted, through the Curry-Howard isomorphism, as a new type constructor. Nonetheless, the possible addi-tional connectives must satisfy the following requirements:","1. they must be provided with introduction and elimination rules that satisfy Prawitz’s inversion principle (Prawitz, 1965) and the resulting system must be strongly normalizable;","2. the resulting term language (or at least an in-teresting fragment of it) must have a decidable matching problem. The first requirement ensures that the new types come with appropriate data constructors and discriminators, and that the associated evaluation rule terminates. This is mandatory for the applicative paradigm of Section 3. The second requirement ensures that the deductive paradigm (and consequently the transductive paradigm) may be fully automated.","The other connectives of linear logic are natural candidates for extending the formalism. In particular, they all satisfy the first requirement. On the other hand, the satisfaction of the second requirement is, in most of the cases, an open problem. 5.1 Additives The additive connectives of linear logic ‘&’ and ‘⊕’ corresponds respectively to the cartesian product and the disjoint union. The cartesian product allows records to be defined. The disjoint union, together with the unit type ‘1’, allows enumerated types and case analysis to be defined. Consequently, the additive connectives offer a good theoretical ground to provide ACG with feature structures. 5.2 Exponentials The exponentials of linear logic are modal operators that may be used to go beyond linearity. In particular, the exponential ‘!’ allows the intuitionistic implication ‘→’ to be defined, which corresponds to the possibility of dealing with non-linear λ-terms. A need for such non-linear λ- terms is already present in the example of Section 2.3. Indeed, the way of getting rid of the second assumption we made at the beginning of section 2.3 is to declare the logical symbols (i.e., the existential quantifier and the conjunction that occurs in the interpretation of A in Lexicon L13) as constants of the object vocabulary Σ3. Then, the interpretation of A would be something like: λP. λQ. EXISTS (λx. AND (P x) (Q x)). Now, this expression must be typable, which is not possible in a purely linear framework. Indeed, the λ-term to which EXISTS is applied is not linear (there are two occurrences of the bound variable x). Consequently, EXISTS must be given ((e → t) −◦ t) as a type. 5.3 Quantifiers Quantifiers may also play a part. Uses of first-order quantification, in a type logical setting, are exemplified by Morrill (1994), Moortgat (1997), and Ranta (1994). As for second-order quantification, it allows for polymorphism."]},{"title":"6 Grammars as first-class citizen","paragraphs":["The difference we make between an abstract vocabulary and an object vocabulary is purely conceptual. In fact, it only makes sense relatively to a given lexicon. Indeed, from a technical point of view, any vocabulary is simply a higher-order linear signature. Consequently, one may think of a lexicon L12 : Σ1 → Σ2 whose object language serves as abstract language of another lexicon L23 : Σ2 → Σ3. This allows lexicons to be sequentially composed. Moreover, one may easily construct a third lexicon L13 : Σ1 → Σ3 that corresponds to the sequential composition of L23 with L12. From a practical point of view, this means that the sequential composition of two lexicons may be compiled. From a theoretical point of view, it means that the ACGs form a category whose objects are vocabularies and whose arrows are lexicons. This opens the door to a theory where operations for constructing new grammars from other grammars could be defined."]},{"title":"7 Conclusion","paragraphs":["This paper presents the first steps towards the de-sign of a powerful grammatical framework based on a small set of computational primitives. The fact that these primitives are well known from programming theory renders the framework suitable for an implementation. A first prototype is currently under development."]},{"title":"References","paragraphs":["M. Abrusci, C. Fouqueré, and J. Vauzeilles. 1999. Tree-adjoining grammars in a fragment of the Lambek calculus. Computational Linguistics, 25(2):209–236.","H.P. Barendregt. 1984. The lambda calculus, its syntax and semantics. North-Holland, revised edition.","J. van Benthem. 1986. Essays in Logical Semantics. Reidel, Dordrecht.","B. Carpenter. 1996. Type-Logical Semantics. MIT Press, Cambridge, Massachussetts and London England.","M. Dalrymple, M. Lamping, F. Pereira, and V. Saraswat. 1995. Linear logic for meaning as-sembly. In G. Morrill and D. Oehrle, editors, Formal Grammar, pages 75–93. FoLLI.","J.-Y. Girard. 1987. Linear logic. Theoretical Computer Science, 50:1–102.","Ph. de Groote. 2000. Linear higher-order matching is NP-complete. In L. Bachmair, editor, Rewriting Techniques and Applications, RTA’00, volume 1833 of Lecture Notes in Computer Science, pages 127– 140. Springer.","A. K. Joshi and Y. Schabes. 1997. Tree-adjoining grammars. In G. Rozenberg an A. Salomaa, editor, Handbook of formal languages, volume 3, chapter 2. Springer.","J. Lambek. 1958. The mathematics of sentence structure. Amer. Math. Monthly, 65:154–170.","J. M. Merenciano and G. Morrill. 1997. Generation as deduction on labelled proof nets. In C. Retoré, editor, Logical Aspects of Computational Linguistics, LACL’96, volume 1328 of Lecture Notes in Artificial Intelligence, pages 310–328. Springer Verlag.","R. Montague. 1970a. English as a formal language. In B. Visentini et al., editor, Linguaggi nella Società e nella Tecnica, Milan. Edizioni di Communità. Reprinted: (Montague, 1974, pages 188–221).","R. Montague. 1970b. Universal grammar. Theoria, 36:373–398. Reprinted: (Montague, 1974, pages 222–246).","R. Montague. 1973. The proper treatment of quantification in ordinary english. In J. Hintikka, J. Moravcsik, and P. Suppes, editors, Approaches to natural language: proceedings of the 1970 Stanford workshop on Grammar and Semantics, Dordrecht. Reidel. Reprinted: (Montague, 1974, pages 247– 270).","R. Montague. 1974. Formal Philosophy: selected papers of Richard Montague, edited and with an introduction by Richmond Thomason. Yale University Press.","M. Moortgat. 1997. Categorial type logic. In J. van Benthem and A. ter Meulen, editors, Handbook of Logic and Language, chapter 2. Elsevier.","G. Morrill. 1994. Type Logical Grammar: Categorial Logic of Signs. Kluwer Academic Publishers, Dordrecht.","M. Nivat. 1968. Transduction des langages de Chomsky. Annales de l’Institut Fourier, 18:339–455.","R. T. Oehrle. 1994. Term-labeled categorial type systems. Linguistic & Philosophy, 17:633–678.","S. Pogodalla. 2000. Generation, Lambek Calculus, Montague’s Semantics and Semantic Proof Nets. In Proceedings of the 18th","International Conference on Computational Linguistics, volume 2, pages 628–634.","D. Prawitz. 1965. Natural Deduction, A Proof-Theoretical Study. Almqvist & Wiksell, Stockholm.","A. Ranta. 1994. Type theoretical grammar. Oxford University Press."]}]}