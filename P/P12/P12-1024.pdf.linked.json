{"sections":[{"title":"","paragraphs":["Proceedings of the 50th Annual Meeting of the Association for Computational Linguistics, pages 223–231, Jeju, Republic of Korea, 8-14 July 2012. c⃝2012 Association for Computational Linguistics"]},{"title":"Spectral Learning of Latent-Variable PCFGs Shay B. Cohen","paragraphs":["1"]},{"title":", Karl Stratos","paragraphs":["1"]},{"title":", Michael Collins","paragraphs":["1"]},{"title":", Dean P. Foster","paragraphs":["2"]},{"title":", and Lyle Ungar","paragraphs":["3 1"]},{"title":"Dept. of Computer Science, Columbia University","paragraphs":["2"]},{"title":"Dept. of Statistics/","paragraphs":["3"]},{"title":"Dept. of Computer and Information Science, University of Pennsylvania","paragraphs":["{scohen,stratos,mcollins}@cs.columbia.edu, foster@wharton.upenn.edu, ungar@cis.upenn.edu"]},{"title":"Abstract","paragraphs":["We introduce a spectral learning algorithm for latent-variable PCFGs (Petrov et al., 2006). Under a separability (singular value) condition, we prove that the method provides consistent parameter estimates."]},{"title":"1 Introduction","paragraphs":["Statistical models with hidden or latent variables are of great importance in natural language processing, speech, and many other fields. The EM algorithm is a remarkably successful method for parameter estimation within these models: it is simple, it is often relatively efficient, and it has well understood formal properties. It does, however, have a major limitation: it has no guarantee of finding the global optimum of the likelihood function. From a theoretical perspective, this means that the EM algorithm is not guaranteed to give consistent parameter estimates. From a practical perspective, problems with local optima can be difficult to deal with.","Recent work has introduced polynomial-time learning algorithms (and consistent estimation methods) for two important cases of hidden-variable models: Gaussian mixture models (Dasgupta, 1999; Vempala and Wang, 2004) and hidden Markov models (Hsu et al., 2009). These algorithms use spectral methods: that is, algorithms based on eigen-vector decompositions of linear systems, in particular singular value decomposition (SVD). In the general case, learning of HMMs or GMMs is intractable (e.g., see Terwijn, 2002). Spectral methods finesse the problem of intractibility by assuming separability conditions. For example, the algorithm of Hsu et al. (2009) has a sample complexity that is polynomial in 1/σ, where σ is the minimum singular value of an underlying decomposition. These methods are not susceptible to problems with local maxima, and give consistent parameter estimates.","In this paper we derive a spectral algorithm for learning of latent-variable PCFGs (L-PCFGs) (Petrov et al., 2006; Matsuzaki et al., 2005). Our method involves a significant extension of the techniques from Hsu et al. (2009). L-PCFGs have been shown to be a very effective model for natural language parsing. Under a separation (singular value) condition, our algorithm provides consistent parameter estimates; this is in contrast with previous work, which has used the EM algorithm for parameter estimation, with the usual problems of local optima.","The parameter estimation algorithm (see figure 4) is simple and efficient. The first step is to take an SVD of the training examples, followed by a projection of the training examples down to a lowdimensional space. In a second step, empirical averages are calculated on the training example, followed by standard matrix operations. On test examples, simple (tensor-based) variants of the inside-outside algorithm (figures 2 and 3) can be used to calculate probabilities and marginals of interest.","Our method depends on the following results:","• Tensor form of the inside-outside algorithm. Section 5 shows that the inside-outside algorithm for L-PCFGs can be written using tensors. Theorem 1 gives conditions under which the tensor form calculates inside and outside terms correctly.","• Observable representations. Section 6 shows that under a singular-value condition, there is an observable form for the tensors required by the inside-outside algorithm. By an observable form, we follow the terminology of Hsu et al. (2009) in referring to quantities that can be estimated directly from data where values for latent variables are unobserved. Theorem 2 shows that tensors derived from the observable form satisfy the conditions of theorem 1.","• Estimating the model. Section 7 gives an algorithm for estimating parameters of the observable representation from training data. Theorem 3 gives a sample complexity result, showing that the estimates converge to the true distribution at a rate of 1/√ M where M is the number of training examples.","The algorithm is strikingly different from the EM algorithm for L-PCFGs, both in its basic form, and in its consistency guarantees. The techniques de-223 veloped in this paper are quite general, and should be relevant to the development of spectral methods for estimation in other models in NLP, for example alignment models for translation, synchronous PCFGs, and so on. The tensor form of the inside-outside algorithm gives a new view of basic calculations in PCFGs, and may itself lead to new models."]},{"title":"2 Related Work","paragraphs":["For work on L-PCFGs using the EM algorithm, see Petrov et al. (2006), Matsuzaki et al. (2005), Pereira and Schabes (1992). Our work builds on methods for learning of HMMs (Hsu et al., 2009; Foster et al., 2012; Jaeger, 2000), but involves several extensions: in particular in the tensor form of the inside-outside algorithm, and observable representations for the tensor form. Balle et al. (2011) consider spectral learning of finite-state transducers; Lugue et al. (2012) considers spectral learning of head automata for dependency parsing. Parikh et al. (2011) consider spectral learning algorithms of tree-structured directed bayes nets."]},{"title":"3 Notation","paragraphs":["Given a matrix A or a vector v, we write A⊤","or v⊤ for the associated transpose. For any integer n ≥ 1, we use [n] to denote the set {1, 2, . . . n}. For any row or column vector y ∈ Rm",", we use diag(y) to refer to the (m × m) matrix with diagonal elements equal to yh for h = 1 . . . m, and off-diagonal elements equal to 0. For any statement Γ, we use [[Γ]] to refer to the indicator function that is 1 if Γ is true, and 0 if Γ is false. For a random variable X, we use E[X] to denote its expected value.","We will make (quite limited) use of tensors: Definition 1 A tensor C ∈ R(m×m×m)","is a set of m3","parameters C","i,j,k for i, j, k ∈ [m]. Given a ten-","sor C, and a vector y ∈ Rm",", we define C(y) to be","the (m × m) matrix with components [C(y)]i,j =∑ k∈[m] Ci,j,kyk. Hence C can be interpreted as a","function C : Rm","→ R(m×m)","that maps a vector","y ∈ Rm","to a matrix C(y) of dimension (m × m). In addition, we define the tensor C∗ ∈ R(m×m×m)","for any tensor C ∈ R(m×m×m)","to have values [C∗]i,j,k = Ck,j,i","Finally, for vectors x, y, z ∈ Rm",", xy⊤","z⊤","is the","tensor D ∈ Rm×m×m","where Dj,k,l = xj ykzl (this","is analogous to the outer product: [xy⊤","]j,k = xj yk)."]},{"title":"4 L-PCFGs: Basic Definitions","paragraphs":["This section gives a definition of the L-PCFG for-malism used in this paper. An L-PCFG is a 5-tuple (N , I, P, m, n) where:","• N is the set of non-terminal symbols in the grammar. I ⊂ N is a finite set of in-terminals. P ⊂ N is a finite set of pre-terminals. We assume that N = I ∪ P, and I ∩ P = ∅. Hence we have partitioned the set of non-terminals into two subsets.","• [m] is the set of possible hidden states.","• [n] is the set of possible words.","• For all a ∈ I, b ∈ N , c ∈ N , h1, h2, h3 ∈ [m], we have a context-free rule a(h1) → b(h2) c(h3).","• For all a ∈ P, h ∈ [m], x ∈ [n], we have a context-free rule a(h) → x.","Hence each in-terminal a ∈ I is always the left-hand-side of a binary rule a → b c; and each pre-terminal a ∈ P is always the left-hand-side of a rule a → x. Assuming that the non-terminals in the grammar can be partitioned this way is relatively benign, and makes the estimation problem cleaner.","We define the set of possible “skeletal rules” as R = {a → b c : a ∈ I, b ∈ N , c ∈ N }. The parameters of the model are as follows:","• For each a → b c ∈ R, and h ∈ [m], we have a parameter q(a → b c|h, a). For each a ∈ P, x ∈ [n], and h ∈ [m], we have a parameter q(a → x|h, a). For each a → b c ∈ R, and h, h′","∈ [m], we have parameters s(h′","|h, a → b c) and t(h′","|h, a → b c).","These definitions give a PCFG, with rule probabilities p(a(h1) → b(h2) c(h3)|a(h1)) = q(a → b c|h1, a) × s(h2|h1, a → b c) × t(h3|h1, a → b c) and p(a(h) → x|a(h)) = q(a → x|h, a).","In addition, for each a ∈ I, for each h ∈ [m], we have a parameter π(a, h) which is the probability of non-terminal a paired with hidden variable h being at the root of the tree.","An L-PCFG defines a distribution over parse trees as follows. A skeletal tree (s-tree) is a sequence of rules r1 . . . rN where each ri is either of the form a → b c or a → x. The rule sequence forms a top-down, left-most derivation under a CFG with skeletal rules. See figure 1 for an example.","A full tree consists of an s-tree r1 . . . rN , together with values h1 . . . hN . Each hi is the value for 224 S1 NP2 D3 the N4 dog VP5 V6 saw P7 him r1 = S → NP VP r2 = NP → D N r3 = D → the r4 = N → dog r5 = VP → V P r6 = V → saw r7 = P → him Figure 1: An s-tree, and its sequence of rules. (For convenience we have numbered the nodes in the tree.) the hidden variable for the left-hand-side of rule ri. Each hi can take any value in [m].","Define ai to be the non-terminal on the left-hand-side of rule ri. For any i ∈ {2 . . . N } define pa(i) to be the index of the rule above node i in the tree. Define L ⊂ [N ] to be the set of nodes in the tree which are the left-child of some parent, and R ⊂ [N ] to be the set of nodes which are the right-child of some parent. The probability mass function (PMF) over full trees is then p(r1 . . . rN , h1 . . . hN ) = π(a1, h1) × N ∏ i=1 q(ri|hi, ai) × ∏ i∈L s(hi|hpa(i), rpa(i)) × ∏ i∈R t(hi|hpa(i), rpa(i)) (1) The PMF over s-trees is p(r1 . . . rN ) =∑ h1...hN p(r1 . . . rN , h1 . . . hN ). In the remainder of this paper, we make use of ma-","trix form of parameters of an L-PCFG, as follows: • For each a → b c ∈ R, we define Qa→b c","∈","Rm×m","to be the matrix with values q(a → b c|h, a)","for h = 1, 2, . . . m on its diagonal, and 0 values for","its off-diagonal elements. Similarly, for each a ∈ P,","x ∈ [n], we define Qa→x","∈ Rm×m","to be the matrix","with values q(a → x|h, a) for h = 1, 2, . . . m on its","diagonal, and 0 values for its off-diagonal elements. • For each a → b c ∈ R, we define Sa→b c","∈","Rm×m","where [Sa→b c","]h′",",h = s(h′","|h, a → b c). • For each a → b c ∈ R, we define T a→b c","∈","Rm×m","where [T a→b c","]h′",",h = t(h′","|h, a → b c). • For each a ∈ I, we define the vector πa","∈ Rm","where [πa","]h = π(a, h)."]},{"title":"5 Tensor Form of the Inside-Outside Algorithm","paragraphs":["Given an L-PCFG, two calculations are central:","Inputs: s-tree r1 . . . rN , L-PCFG (N , I, P, m, n), parameters","• Ca→b c ∈ R(m×m×m)","for all a → b c ∈ R","• c∞","a→x ∈ R(1×m)","for all a ∈ P, x ∈ [n]","• c1","a ∈ R(m×1)","for all a ∈ I.","Algorithm: (calculate the fi","terms bottom-up in the tree)","• For all i ∈ [N] such that ai ∈ P, fi","= c∞","r","i","• For all i ∈ [N] such that ai ∈ I, fi","= fγ","Cr","i","(fβ",") where","β is the index of the left child of node i in the tree, and γ","is the index of the right child.","Return: f1 c1 a 1 = p(r1 . . . rN ) Figure 2: The tensor form for calculation of p(r1 . . . rN ).","1. For a given s-tree r1 . . . rN , calculate p(r1 . . . rN ).","2. For a given input sentence x = x1 . . . xN , calculate the marginal probabilities μ(a, i, j) = ∑ τ∈T (x):(a,i,j)∈τ p(τ ) for each non-terminal a ∈ N , for each (i, j) such that 1 ≤ i ≤ j ≤ N . Here T (x) denotes the set of all possible s-trees for the sentence x, and we write (a, i, j) ∈ τ if non-terminal a spans words xi . . . xj in the parse tree τ .","The marginal probabilities have a number of uses. Perhaps most importantly, for a given sentence x = x1 . . . xN , the parsing algorithm of Goodman (1996) can be used to find","arg max τ∈T (x) ∑ (a,i,j)∈τ μ(a, i, j) This is the parsing algorithm used by Petrov et al. (2006), for example. In addition, we can calculate the probability for an input sentence, p(x) =∑","τ∈T (x) p(τ ), as p(x) =","∑","a∈I μ(a, 1, N ).","Variants of the inside-outside algorithm can be used for problems 1 and 2. This section introduces a novel form of these algorithms, using tensors. This is the first step in deriving the spectral estimation method.","The algorithms are shown in figures 2 and 3. Each algorithm takes the following inputs:","1. A tensor Ca→b c","∈ R(m×m×m)","for each rule","a → b c.","2. A vector c∞ a→x ∈ R(1×m)","for each rule a → x. 225","3. A vector c1 a ∈ R(m×1)","for each a ∈ I.","The following theorem gives conditions under which the algorithms are correct:","Theorem 1 Assume that we have an L-PCFG with","parameters Qa→x",", Qa→b c , T a→b c",", Sa→b c",", πa",", and","that there exist matrices Ga","∈ R(m×m)","for all a ∈","N such that each Ga","is invertible, and such that:","1. For all rules a → b c, Ca→b c","(y) =","Gc","T a→b c","diag(yGb Sa→b c",")Qa→b c","(Ga",")−1","2. For all rules a → x, c∞","a→x = 1⊤ Qa→x","(Ga",")−1","3. For all a ∈ I, c1 a = Ga","πa Then: 1) The algorithm in figure 2 correctly computes p(r1 . . . rN ) under the L-PCFG. 2) The algorithm in figure 3 correctly computes the marginals μ(a, i, j) under the L-PCFG. Proof: See section 9.1."]},{"title":"6 Estimating the Tensor Model","paragraphs":["A crucial result is that it is possible to directly estimate parameters Ca→b c",", c∞","a→x and c1","a that satisfy the conditions in theorem 1, from a training sample consisting of s-trees (i.e., trees where hidden variables are unobserved). We first describe random variables underlying the approach, then describe observable representations based on these random variables. 6.1 Random Variables Underlying the Approach Each s-tree with N rules r1 . . . rN has N nodes. We will use the s-tree in figure 1 as a running example.","Each node has an associated rule: for example, node 2 in the tree in figure 1 has the rule NP → D N. If the rule at a node is of the form a → b c, then there are left and right inside trees below the left child and right child of the rule. For example, for node 2 we have a left inside tree rooted at node 3, and a right inside tree rooted at node 4 (in this case the left and right inside trees both contain only a single rule production, of the form a → x; however in the general case they might be arbitrary subtrees).","In addition, each node has an outside tree. For node 2, the outside tree is","S NP VP V saw P him","Inputs: Sentence x1 . . . xN , L-PCFG (N , I, P, m, n), param-","eters Ca→b c ∈ R(m×m×m)","for all a → b c ∈ R, c∞","a→x ∈","R(1×m)","for all a ∈ P, x ∈ [n], c1","a ∈ R(m×1)","for all a ∈ I.","Data structures:","• Each αa,i,j","∈ R1×m","for a ∈ N , 1 ≤ i ≤ j ≤ N is a row vector of inside terms.","• Each βa,i,j","∈ Rm×1","for a ∈ N , 1 ≤ i ≤ j ≤ N is a column vector of outside terms.","• Each μ(a, i, j) ∈ R for a ∈ N , 1 ≤ i ≤ j ≤ N is a marginal probability.","Algorithm:","(Inside base case) ∀a ∈ P, i ∈ [N], αa,i,i = c∞","a→x","i (Inside recursion) ∀a ∈ I, 1 ≤ i < j ≤ N,","αa,i,j = j−1 ∑ k=i ∑ a→b c","αc,k+1,j","Ca→b c","(αb,i,k",")","(Outside base case) ∀a ∈ I, βa,1,n","= c1","a","(Outside recursion) ∀a ∈ N , 1 ≤ i ≤ j ≤ N,","βa,i,j = i−1 ∑ k=1 ∑ b→c a","Cb→c a (αc,k,i−1",")βb,k,j + N ∑ k=j+1 ∑ b→a c Cb→a c ∗ (αc,j+1,k",")βb,i,k","(Marginals) ∀a ∈ N , 1 ≤ i ≤ j ≤ N,","μ(a, i, j) = αa,i,j βa,i,j","= ∑","h∈[m] αa,i,j h βa,i,j","h Figure 3: The tensor form of the inside-outside algorithm, for calculation of marginal terms μ(a, i, j). The outside tree contains everything in the s-tree r1 . . . rN , excluding the subtree below node i.","Our random variables are defined as follows. First, we select a random internal node, from a random tree, as follows:","• Sample an s-tree r1 . . . rN from the PMF p(r1 . . . rN ). Choose a node i uniformly at random from [N ].","If the rule ri for the node i is of the form a → b c, we define random variables as follows:","• R1 is equal to the rule ri (e.g., NP → D N).","• T1 is the inside tree rooted at node i. T2 is the inside tree rooted at the left child of node i, and T3 is the inside tree rooted at the right child of node i.","• H1, H2, H3 are the hidden variables associated with node i, the left child of node i, and the right child of node i respectively. 226","• A1, A2, A3 are the labels for node i, the left child of node i, and the right child of node i respectively. (E.g., A1 = NP, A2 = D, A3 = N.)","• O is the outside tree at node i.","• B is equal to 1 if node i is at the root of the tree (i.e., i = 1), 0 otherwise.","If the rule ri for the selected node i is of the form a → x, we have random variables R1, T1, H1, A1, O, B as defined above, but H2, H3, T2, T3, A2, and A3 are not defined.","We assume a function ψ that maps outside trees o to feature vectors ψ(o) ∈ Rd′",". For example, the feature vector might track the rule directly above the node in question, the word following the node in question, and so on. We also assume a function φ that maps inside trees t to feature vectors φ(t) ∈ Rd",". As one example, the function φ might be an indicator function tracking the rule production at the root of the inside tree. Later we give formal criteria for what makes good definitions of ψ(o) of φ(t). One requirement is that d′","≥ m and d ≥ m.","In tandem with these definitions, we assume projection matices U a","∈ R(d×m)","and V a","∈ R(d′","×m) for all a ∈ N . We then define additional random variables Y1, Y2, Y3, Z as","Y1 = (U a1",")⊤ φ(T1) Z = (V a1",")⊤","ψ(O)","Y2 = (U a2",")⊤ φ(T2) Y3 = (U a3",")⊤","φ(T3) where ai is the value of the random variable Ai. Note that Y1, Y2, Y3, Z are all in Rm",". 6.2 Observable Representations Given the definitions in the previous section, our representation is based on the following matrix, tensor and vector quantities, defined for all a ∈ N , for all rules of the form a → b c, and for all rules of the form a → x respectively:","Σa = E[Y","1Z⊤ |A1 = a]","Da→b c = E [","[[R1 = a → b c]]Y3Z⊤ Y ⊤ 2 |A1 = a] d∞ a→x = E [","[[R1 = a → x]]Z⊤ |A1 = a ] Assuming access to functions φ and ψ, and projection matrices U a","and V a",", these quantities can be estimated directly from training data consisting of a set of s-trees (see section 7). Our observable representation then consists of:","Ca→b c","(y) = Da→b c","(y)(Σa",")−1","(2)","c∞","a→x = d∞","a→x(Σa",")−1","(3) c1 a = E [[[A1 = a]]Y1|B = 1] (4) We next introduce conditions under which these quantities satisfy the conditions in theorem 1.","The following definition will be important:","Definition 2 For all a ∈ N , we define the matrices","Ia","∈ R(d×m)","and J a","∈ R(d′","×m) as","[Ia ]i,h = E[φi(T1) | H1 = h, A1 = a]","[J a ]i,h = E[ψi(O) | H1 = h, A1 = a]","In addition, for any a ∈ N , we use γa","∈ Rm","to","denote the vector with γa","h = P (H1 = h|A1 = a). The correctness of the representation will rely on the following conditions being satisfied (these are parallel to conditions 1 and 2 in Hsu et al. (2009)): Condition 1 ∀a ∈ N , the matrices Ia","and J a","are of full rank (i.e., they have rank m). For all a ∈ N , for all h ∈ [m], γa","h > 0. Condition 2 ∀a ∈ N , the matrices U a","∈ R(d×m) and V a","∈ R(d′","×m) are such that the matrices Ga","=","(U a",")⊤","Ia","and Ka = (V a",")⊤","J a","are invertible. The following lemma justifies the use of an SVD calculation as one method for finding values for U a and V a","that satisfy condition 2: Lemma 1 Assume that condition 1 holds, and for all a ∈ N define","Ωa = E[φ(T1) (ψ(O))⊤","|A1 = a] (5) Then if U a","is a matrix of the m left singular vec-","tors of Ωa","corresponding to non-zero singular val-","ues, and V a","is a matrix of the m right singular vec-","tors of Ωa","corresponding to non-zero singular val-","ues, then condition 2 is satisfied. Proof sketch: It can be shown that Ωa","=","Ia diag(γa",")(J a",")⊤",". The remainder is similar to the","proof of lemma 2 in Hsu et al. (2009). The matrices Ωa","can be estimated directly from a","training set consisting of s-trees, assuming that we","have access to the functions φ and ψ. We can now state the following theorem: 227","Theorem 2 Assume conditions 1 and 2 are satisfied.","For all a ∈ N , define Ga = (U a",")⊤","Ia",". Then under","the definitions in Eqs. 2-4:","1. For all rules a → b c, Ca→b c","(y) =","Gc","T a→b c","diag(yGb Sa→b c",")Qa→b c","(Ga",")−1","2. For all rules a → x, c∞","a→x = 1⊤","Qa→x","(Ga",")−1",".","3. For all a ∈ N , c1 a = Ga","πa","Proof: The following identities hold (see sec-","tion 9.2):","Da→b c","(y) = (6)","Gc","T a→b c diag(yGb","Sa→b c",")Qa→b c","diag(γa",")(Ka",")⊤","d∞","a→x = 1⊤ Qa→x","diag(γa",")(Ka",")⊤","(7)","Σa","= Ga","diag(γa",")(Ka",")⊤","(8)","c1","a = Ga","πa","(9)","Under conditions 1 and 2, Σa","is invertible, and","(Σa",")−1","= ((Ka",")⊤ )−1","(diag(γa","))−1","(Ga",")−1",". The","identities in the theorem follow immediately."]},{"title":"7 Deriving Empirical Estimates","paragraphs":["Figure 4 shows an algorithm that derives esti-","mates of the quantities in Eqs 2, 3, and 4. As","input, the algorithm takes a sequence of tuples","(r(i,1)",", t(i,1)",", t(i,2)",", t(i,3)",", o(i)",", b(i)",") for i ∈ [M ]. These tuples can be derived from a training set","consisting of s-trees τ1 . . . τM as follows: • ∀i ∈ [M ], choose a single node ji uniformly at","random from the nodes in τi. Define r(i,1)","to be the","rule at node ji. t(i,1)","is the inside tree rooted at node","ji. If r(i,1)","is of the form a → b c, then t(i,2)","is the","inside tree under the left child of node ji, and t(i,3)","is the inside tree under the right child of node ji. If","r(i,1)","is of the form a → x, then t(i,2)","= t(i,3)","=","NULL. o(i)","is the outside tree at node ji. b(i)","is 1 if","node ji is at the root of the tree, 0 otherwise. Under this process, assuming that the s-trees","τ1 . . . τM are i.i.d. draws from the distribution","p(τ ) over s-trees under an L-PCFG, the tuples","(r(i,1)",", t(i,1)",", t(i,2)",", t(i,3)",", o(i)",", b(i)",") are i.i.d. draws","from the joint distribution over the random variables","R1, T1, T2, T3, O, B defined in the previous section. The algorithm first computes estimates of the pro-","jection matrices U a","and V a",": following lemma 1,","this is done by first deriving estimates of Ωa",",","and then taking SVDs of each Ωa",". The matrices","are then used to project inside and outside trees","t(i,1)",", t(i,2) , t(i,3)",", o(i)","down to m-dimensional vec-","tors y(i,1) , y(i,2)",", y(i,3)",", z(i)","; these vectors are used to","derive the estimates of Ca→b c",", c∞","a→x, and c1","a.","We now state a PAC-style theorem for the learning","algorithm. First, for a given L-PCFG, we need a","couple of definitions:","• Λ is the minimum absolute value of any element","of the vectors/matrices/tensors c1","a, d∞","a→x, Da→b c",",","(Σa",")−1",". (Note that Λ is a function of the projec-","tion matrices U a","and V a","as well as the underlying","L-PCFG.)","• For each a ∈ N , σa","is the value of the m’th","largest singular value of Ωa",". Define σ = mina σa",". We then have the following theorem: Theorem 3 Assume that the inputs to the algorithm in figure 4 are i.i.d. draws from the joint distribution over the random variables R1, T1, T2, T3, O, B, under an L-PCFG with distribution p(r1 . . . rN ) over s-trees. Define m to be the number of latent states in the L-PCFG. Assume that the algorithm in figure 4 has projection matrices Û a","and V̂ a","derived as left and right singular vectors of Ωa",", as defined in Eq. 5. Assume that the L-PCFG, together with Û a and V̂ a",", has coefficients Λ > 0 and σ > 0. In addi-tion, assume that all elements in c1","a, d∞","a→x, Da→b c",", and Σa","are in [−1, +1]. For any s-tree r1 . . . rN define p̂(r1 . . . rN ) to be the value calculated by the algorithm in figure 3 with inputs ĉ1","a, ĉ∞","a→x, Ĉa→b c derived from the algorithm in figure 4. Define R to be the total number of rules in the grammar of the form a → b c or a → x. Define Ma to be the number of training examples in the input to the algorithm in figure 4 where ri,1","has non-terminal a on its left-hand-side. Under these assumptions, if for all a Ma ≥ 128m2 ( 2N+1√ 1 + ε − 1) 2","Λ2 σ4 log (","2mR δ ) Then 1 − ε ≤ ∣ ∣ ∣ ∣ p̂(r1 . . . rN ) p(r1 . . . rN ) ∣ ∣ ∣ ∣ ≤ 1 + ε","A similar theorem (omitted for space) states that 1 − ε ≤ ∣ ∣ ∣ μ̂(a,i,j) μ(a,i,j) ∣ ∣ ∣ ≤ 1 + ε for the marginals.","The condition that Û a","and V̂ a","are derived from","Ωa",", as opposed to the sample estimate Ω̂a",", follows","Foster et al. (2012). As these authors note, similar","techniques to those of Hsu et al. (2009) should be 228 applicable in deriving results for the case where Ω̂a is used in place of Ωa",".","Proof sketch: The proof is similar to that of Foster et al. (2012). The basic idea is to first show that under the assumptions of the theorem, the estimates ĉ1 a, d̂∞","a→x, D̂a→b c",", Σ̂a","are all close to the underlying values being estimated. The second step is to show that this ensures that","p̂(r1...rN′ )","p(r1...rN′ ) is close to 1. The method described of selecting a single tuple (r(i,1)",", t(i,1)",", t(i,2)",", t(i,3)",", o(i)",", b(i)",") for each s-tree ensures that the samples are i.i.d., and simplifies the analysis underlying theorem 3. In practice, an implementation should most likely use all nodes in all trees in training data; by Rao-Blackwellization we know such an algorithm would be better than the one presented, but the analysis of how much better would be challenging. It would almost certainly lead to a faster rate of convergence of p̂ to p."]},{"title":"8 Discussion","paragraphs":["There are several potential applications of the method. The most obvious is parsing with L-PCFGs.1","The approach should be applicable in other cases where EM has traditionally been used, for example in semi-supervised learning. Latent-variable HMMs for sequence labeling can be derived as special case of our approach, by converting tagged sequences to right-branching skeletal trees.","The sample complexity of the method depends on the minimum singular values of Ωa","; these singular values are a measure of how well correlated ψ and φ are with the unobserved hidden variable H1. Experimental work is required to find a good choice of values for ψ and φ for parsing."]},{"title":"9 Proofs","paragraphs":["This section gives proofs of theorems 1 and 2. Due to space limitations we cannot give full proofs; in-stead we provide proofs of some key lemmas. A long version of this paper will give the full proofs. 9.1 Proof of Theorem 1 First, the following lemma leads directly to the correctness of the algorithm in figure 2:","1","Parameters can be estimated using the algorithm in figure 4; for a test sentence x1 . . . xN we can first use the algorithm in figure 3 to calculate marginals μ(a, i, j), then use the algorithm of Goodman (1996) to find arg maxτ∈T (x)","∑ (a,i,j)∈τ μ(a, i, j).","Inputs: Training examples (r(i,1) , t(i,1)",", t(i,2)",", t(i,3)",", o(i)",", b(i)",")","for i ∈ {1 . . . M}, where r(i,1) is a context free rule; t(i,1)",",","t(i,2)","and t(i,3)","are inside trees; o(i)","is an outside tree; and","b(i)","= 1 if the rule is at the root of tree, 0 otherwise. A function","φ that maps inside trees t to feature-vectors φ(t) ∈ Rd",". A func-","tion ψ that maps outside trees o to feature-vectors ψ(o) ∈ Rd′ .","Algorithm:","Define ai to be the non-terminal on the left-hand side of rule","r(i,1) . If r(i,1)","is of the form a → b c, define bi to be the non-","terminal for the left-child of r(i,1)",", and ci to be the non-terminal","for the right-child.","(Step 0: Singular Value Decompositions) • Use the algorithm in figure 5 to calculate matrices Ûa","∈ R(d×m)","and V̂ a","∈ R(d′","×m) for each a ∈ N .","(Step 1: Projection)","• For all i ∈ [M], compute y(i,1) = ( Ûa","i",")⊤","φ(t(i,1)",").","• For all i ∈ [M] such that r(i,1)","is of the form","a → b c, compute y(i,2)","= ( Ûb i )⊤","φ(t(i,2)",") and y(i,3)","=","( Ûc","i",")⊤","φ(t(i,3)",").","• For all i ∈ [M], compute z(i) = ( V̂ a","i",")⊤","ψ(o(i)","). (Step 2: Calculate Correlations) • For each a ∈ N , define δa = 1/","∑M","i=1[[ai = a]]","• For each rule a → b c, compute D̂a→b c","= δa ×","∑M","i=1[[r(i,1)","= a → b c]]y(i,3)","(z(i)",")⊤","(y(i,2)",")⊤","• For each rule a → x, compute d̂∞","a→x = δa ×","∑M","i=1[[r(i,1)","= a → x]](z(i)",")⊤","• For each a ∈ N , compute Σ̂a","= δa ×","∑M","i=1[[ai = a]]y(i,1) (z(i)",")⊤","(Step 3: Compute Final Parameters)","• For all a → b c, Ĉa→b c (y) = D̂a→b c","(y)( Σ̂a",")−1","• For all a → x, ĉ∞","a→x = d̂∞ a→x( Σ̂a",")−1","• For all a ∈ I, ĉ1 a =","∑","M","i=1[[a i=a and b(i)","=1]]y(i,1) ∑ M i=1[[b(i)","=1]] Figure 4: The spectral learning algorithm. Inputs: Identical to algorithm in figure 4. Algorithm: • For each a ∈ N , compute Ω̂a","∈ R(d′","×d) as","Ω̂a =","∑M","i=1[[ai = a]]φ(t(i,1)",")(ψ(o(i)","))⊤ ∑M i=1[[ai = a]]","and calculate a singular value decomposition of Ω̂a",".","• For each a ∈ N , define Ûa","∈ Rm×d","to be a matrix of the left","singular vectors of Ω̂a","corresponding to the m largest singular","values. Define V̂ a ∈ Rm×d′","to be a matrix of the right singular","vectors of Ω̂a corresponding to the m largest singular values. Figure 5: Singular value decompositions. 229 Lemma 2 Assume that conditions 1-3 of theorem 1 are satisfied, and that the input to the algorithm in figure 2 is an s-tree r1 . . . rN . Define ai for i ∈ [N ] to be the non-terminal on the left-hand-side of rule ri, and ti for i ∈ [N ] to be the s-tree with rule ri at its root. Finally, for all i ∈ [N ], define the row vector bi","∈ R(1×m)","to have components bi h = P (Ti = ti|Hi = h, Ai = ai)","for h ∈ [m]. Then for all i ∈ [N ], f i","= bi","(G(ai)",")−1",".","It follows immediately that","f 1","c1","a1 = b1 (G(a1)",")−1","Ga1","π a1 = p(r1 . . . rN ) This lemma shows a direct link between the vec-","tors f i","calculated in the algorithm, and the terms bi","h,","which are terms calculated by the conventional in-","side algorithm: each f i","is a linear transformation","(through Gai",") of the corresponding vector bi",".","Proof: The proof is by induction. First consider the base case. For any leaf—i.e., for","any i such that ai ∈ P—we have bi","h = q(ri|h, ai),","and it is easily verified that f i","= bi","(G(ai)",")−1",". The inductive case is as follows. For all i ∈ [N ]","such that ai ∈ I, by the definition in the algorithm,","f i","= f γ","Cri","(f β )","= f γ","Gaγ T ri","diag(f β","Gaβ","Sri",")Qri","(Gai",")−1","Assuming by induction that f γ","= bγ","(G(aγ )",")−1","and","f β","= bβ","(G(aβ) )−1 , this simplifies to","f i","= κr","diag(κl )Qri","(Gai",")−1","(10)","where κr","= bγ","T ri",", and κl","= bβ","Sri",". κr","is a row","vector with components κr","h =","∑","h′","∈[m] bγ","h′T ri","h′",",h =","∑ h′ ∈[m] b γ h′t(h′","|h, r","i). Similarly, κl","is a row vector","with components equal to κl","h =","∑ h′ ∈[m] b β h′Sri h′",",h =","∑ h′ ∈[m] b β h′s(h′","|h, r","i). It can then be verified that","κr","diag(κl )Qri","is a row vector with components","equal to κr hκl","hq(ri|h, ai).","But bi h = q(ri|h, ai)×","( ∑ h′ ∈[m] b γ h′t(h′","|h, r i)) ×","( ∑ h′ ∈[m] b β h′s(h′","|h, r i))","= q(ri|h, ai)κr","hκl","h, hence","κr","diag(κl )Qri","= bi","and the inductive case follows","immediately from Eq. 10.","Next, we give a similar lemma, which implies the","correctness of the algorithm in figure 3:","Lemma 3 Assume that conditions 1-3 of theorem 1","are satisfied, and that the input to the algorithm in","figure 3 is a sentence x1 . . . xN . For any a ∈ N , for","any 1 ≤ i ≤ j ≤ N , define ᾱa,i,j","∈ R(1×m)","to have","components ᾱa,i,j","h = p(xi . . . xj|h, a) for h ∈ [m].","In addition, define β̄a,i,j","∈ R(m×1)","to have compo-","nents β̄a,i,j h = p(x1 . . . xi−1, a(h), xj+1 . . . xN ) for","h ∈ [m]. Then for all i ∈ [N ], αa,i,j","= ᾱa,i,j","(Ga",")−1","and βa,i,j = Ga β̄a,i,j",". It follows that for all (a, i, j),","μ(a, i, j) = ᾱa,i,j","(Ga )−1","Ga β̄a,i,j","= ᾱa,i,j β̄a,i,j = ∑ h ᾱa,i,j h β̄a,i,j h = ∑ τ∈T (x):(a,i,j)∈τ p(τ ) Thus the vectors αa,i,j","and βa,i,j","are linearly re-","lated to the vectors ᾱa,i,j","and β̄a,i,j",", which are the","inside and outside terms calculated by the conven-","tional form of the inside-outside algorithm. The proof is by induction, and is similar to the","proof of lemma 2; for reasons of space it is omitted. 9.2 Proof of the Identity in Eq. 6 We now prove the identity in Eq. 6, used in the proof of theorem 2. For reasons of space, we do not give the proofs of identities 7-9: the proofs are similar.","The following identities can be verified:","P (R1 = a → b c|H1 = h, A1 = a) = q(a → b c|h, a) E [Y3,j|H1 = h, R1 = a → b c] = Ea→b c","j,h E [Zk|H1 = h, R1 = a → b c] = Ka","k,h E [Y2,l|H1 = h, R1 = a → b c] = F a→b c","l,h","where Ea→b c","= Gc","T a→b c",", F a→b c","= Gb","Sa→b c",".","Y3, Z and Y2 are independent when conditioned","on H1, R1 (this follows from the independence as-","sumptions in the L-PCFG), hence","E [[[R1 = a → b c]]Y3,j ZkY2,l | H1 = h, A1 = a]","= q(a → b c|h, a)Ea→b c j,h Ka","k,hF a→b c","l,h","Hence (recall that γa h = P (H1 = h|A1 = a)),","Da→b c j,k,l = E [[[R1 = a → b c]]Y3,jZkY2,l | A1 = a] = ∑ h γa hE [[[R1 = a → b c]]Y3,j ZkY2,l | H1 = h, A1 = a] = ∑ h","γa","hq(a → b c|h, a)Ea→b c j,h Ka","k,hF a→b c","l,h (11) from which Eq. 6 follows. 230 Acknowledgements: Columbia University gratefully acknowledges the support of the Defense Advanced Research Projects Agency (DARPA) Machine Reading Program under Air Force Research Laboratory (AFRL) prime contract no. FA8750-09-C-0181. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the view of DARPA, AFRL, or the US government. Shay Cohen was supported by the National Science Foundation under Grant #1136996 to the Computing Research Association for the CIFellows Project. Dean Foster was supported by National Science Foundation grant 1106743."]},{"title":"References","paragraphs":["B. Balle, A. Quattoni, and X. Carreras. 2011. A spectral learning algorithm for finite state transducers. In Proceedings of ECML.","S. Dasgupta. 1999. Learning mixtures of Gaussians. In Proceedings of FOCS.","Dean P. Foster, Jordan Rodu, and Lyle H. Ungar. 2012. Spectral dimensionality reduction for hmms. arXiv:1203.6130v1.","J. Goodman. 1996. Parsing algorithms and metrics. In Proceedings of the 34th annual meeting on Association for Computational Linguistics, pages 177–183. Association for Computational Linguistics.","D. Hsu, S. M. Kakade, and T. Zhang. 2009. A spectral algorithm for learning hidden Markov models. In Proceedings of COLT.","H. Jaeger. 2000. Observable operator models for discrete stochastic time series. Neural Computation, 12(6).","F. M. Lugue, A. Quattoni, B. Balle, and X. Carreras. 2012. Spectral learning for non-deterministic dependency parsing. In Proceedings of EACL.","T. Matsuzaki, Y. Miyao, and J. Tsujii. 2005. Probabilistic CFG with latent annotations. In Proceedings of the 43rd Annual Meeting on Association for Computational Linguistics, pages 75–82. Association for Computational Linguistics.","A. Parikh, L. Song, and E. P. Xing. 2011. A spectral algorithm for latent tree graphical models. In Proceedings of The 28th International Conference on Machine Learningy (ICML 2011).","F. Pereira and Y. Schabes. 1992. Inside-outside reestimation from partially bracketed corpora. In Proceedings of the 30th Annual Meeting of the Association for Computational Linguistics, pages 128–135, Newark, Delaware, USA, June. Association for Computational Linguistics.","S. Petrov, L. Barrett, R. Thibaux, and D. Klein. 2006. Learning accurate, compact, and interpretable tree an-notation. In Proceedings of the 21st International Conference on Computational Linguistics and 44th Annual Meeting of the Association for Computational Linguistics, pages 433–440, Sydney, Australia, July. Association for Computational Linguistics.","S. A. Terwijn. 2002. On the learnability of hidden markov models. In Grammatical Inference: Algorithms and Applications (Amsterdam, 2002), volume 2484 of Lecture Notes in Artificial Intelligence, pages 261–268, Berlin. Springer.","S. Vempala and G. Wang. 2004. A spectral algorithm for learning mixtures of distributions. Journal of Computer and System Sciences, 68(4):841–860. 231"]}],"references":[{"authors":[{"first":"B.","last":"Balle"},{"first":"A.","last":"Quattoni"},{"first":"X.","last":"Carreras"}],"year":"2011","title":"A spectral learning algorithm for finite state transducers"},{"authors":[{"first":"S.","last":"Dasgupta"}],"year":"1999","title":"Learning mixtures of Gaussians"},{"authors":[{"first":"Dean","middle":"P.","last":"Foster"},{"first":"Jordan","last":"Rodu"},{"first":"Lyle","middle":"H.","last":"Ungar"}],"year":"2012","title":"Spectral dimensionality reduction for hmms"},{"authors":[{"first":"J.","last":"Goodman"}],"year":"1996","title":"Parsing algorithms and metrics"},{"authors":[{"first":"D.","last":"Hsu"},{"first":"S.","middle":"M.","last":"Kakade"},{"first":"T.","last":"Zhang"}],"year":"2009","title":"A spectral algorithm for learning hidden Markov models"},{"authors":[{"first":"H.","last":"Jaeger"}],"year":"2000","title":"Observable operator models for discrete stochastic time series"},{"authors":[{"first":"F.","middle":"M.","last":"Lugue"},{"first":"A.","last":"Quattoni"},{"first":"B.","last":"Balle"},{"first":"X.","last":"Carreras"}],"year":"2012","title":"Spectral learning for non-deterministic dependency parsing"},{"authors":[{"first":"T.","last":"Matsuzaki"},{"first":"Y.","last":"Miyao"},{"first":"J.","last":"Tsujii"}],"year":"2005","title":"Probabilistic CFG with latent annotations"},{"authors":[{"first":"A.","last":"Parikh"},{"first":"L.","last":"Song"},{"first":"E.","middle":"P.","last":"Xing"}],"year":"2011","title":"A spectral algorithm for latent tree graphical models"},{"authors":[{"first":"F.","last":"Pereira"},{"first":"Y.","last":"Schabes"}],"year":"1992","title":"Inside-outside reestimation from partially bracketed corpora"},{"authors":[{"first":"S.","last":"Petrov"},{"first":"L.","last":"Barrett"},{"first":"R.","last":"Thibaux"},{"first":"D.","last":"Klein"}],"year":"2006","title":"Learning accurate, compact, and interpretable tree an-notation"},{"authors":[{"first":"S.","middle":"A.","last":"Terwijn"}],"year":"2002","title":"On the learnability of hidden markov models"},{"authors":[{"first":"S.","last":"Vempala"},{"first":"G.","last":"Wang"}],"year":"2004","title":"A spectral algorithm for learning mixtures of distributions"}],"cites":[{"authors":[{"last":"Petrov"},{"last":"al."}],"year":"2006","style":0,"reference":{"authors":[{"first":"S.","last":"Petrov"},{"first":"L.","last":"Barrett"},{"first":"R.","last":"Thibaux"},{"first":"D.","last":"Klein"}],"year":"2006","title":"Learning accurate, compact, and interpretable tree an-notation"}},{"authors":[{"last":"Dasgupta"}],"year":"1999","style":0,"reference":{"authors":[{"first":"S.","last":"Dasgupta"}],"year":"1999","title":"Learning mixtures of Gaussians"}},{"authors":[{"last":"Vempala"},{"last":"Wang"}],"year":"2004","style":0,"reference":{"authors":[{"first":"S.","last":"Vempala"},{"first":"G.","last":"Wang"}],"year":"2004","title":"A spectral algorithm for learning mixtures of distributions"}},{"authors":[{"last":"Hsu"},{"last":"al."}],"year":"2009","style":0,"reference":{"authors":[{"first":"D.","last":"Hsu"},{"first":"S.","middle":"M.","last":"Kakade"},{"first":"T.","last":"Zhang"}],"year":"2009","title":"A spectral algorithm for learning hidden Markov models"}},{"authors":[{"last":"Terwijn"}],"year":"2002","style":0,"reference":{"authors":[{"first":"S.","middle":"A.","last":"Terwijn"}],"year":"2002","title":"On the learnability of hidden markov models"}},{"authors":[{"last":"Hsu"},{"last":"al."}],"year":"2009","style":0,"reference":{"authors":[{"first":"D.","last":"Hsu"},{"first":"S.","middle":"M.","last":"Kakade"},{"first":"T.","last":"Zhang"}],"year":"2009","title":"A spectral algorithm for learning hidden Markov models"}},{"authors":[{"last":"Petrov"},{"last":"al."}],"year":"2006","style":0,"reference":{"authors":[{"first":"S.","last":"Petrov"},{"first":"L.","last":"Barrett"},{"first":"R.","last":"Thibaux"},{"first":"D.","last":"Klein"}],"year":"2006","title":"Learning accurate, compact, and interpretable tree an-notation"}},{"authors":[{"last":"Matsuzaki"},{"last":"al."}],"year":"2005","style":0,"reference":{"authors":[{"first":"T.","last":"Matsuzaki"},{"first":"Y.","last":"Miyao"},{"first":"J.","last":"Tsujii"}],"year":"2005","title":"Probabilistic CFG with latent annotations"}},{"authors":[{"last":"Hsu"},{"last":"al."}],"year":"2009","style":0,"reference":{"authors":[{"first":"D.","last":"Hsu"},{"first":"S.","middle":"M.","last":"Kakade"},{"first":"T.","last":"Zhang"}],"year":"2009","title":"A spectral algorithm for learning hidden Markov models"}},{"authors":[{"last":"Hsu"},{"last":"al."}],"year":"2009","style":0,"reference":{"authors":[{"first":"D.","last":"Hsu"},{"first":"S.","middle":"M.","last":"Kakade"},{"first":"T.","last":"Zhang"}],"year":"2009","title":"A spectral algorithm for learning hidden Markov models"}},{"authors":[{"last":"Petrov"},{"last":"al."}],"year":"2006","style":0,"reference":{"authors":[{"first":"S.","last":"Petrov"},{"first":"L.","last":"Barrett"},{"first":"R.","last":"Thibaux"},{"first":"D.","last":"Klein"}],"year":"2006","title":"Learning accurate, compact, and interpretable tree an-notation"}},{"authors":[{"last":"Matsuzaki"},{"last":"al."}],"year":"2005","style":0,"reference":{"authors":[{"first":"T.","last":"Matsuzaki"},{"first":"Y.","last":"Miyao"},{"first":"J.","last":"Tsujii"}],"year":"2005","title":"Probabilistic CFG with latent annotations"}},{"authors":[{"last":"Pereira"},{"last":"Schabes"}],"year":"1992","style":0,"reference":{"authors":[{"first":"F.","last":"Pereira"},{"first":"Y.","last":"Schabes"}],"year":"1992","title":"Inside-outside reestimation from partially bracketed corpora"}},{"authors":[{"last":"Hsu"},{"last":"al."}],"year":"2009","style":0,"reference":{"authors":[{"first":"D.","last":"Hsu"},{"first":"S.","middle":"M.","last":"Kakade"},{"first":"T.","last":"Zhang"}],"year":"2009","title":"A spectral algorithm for learning hidden Markov models"}},{"authors":[{"last":"Foster"},{"last":"al."}],"year":"2012","style":0,"reference":{"authors":[{"first":"Dean","middle":"P.","last":"Foster"},{"first":"Jordan","last":"Rodu"},{"first":"Lyle","middle":"H.","last":"Ungar"}],"year":"2012","title":"Spectral dimensionality reduction for hmms"}},{"authors":[{"last":"Jaeger"}],"year":"2000","style":0,"reference":{"authors":[{"first":"H.","last":"Jaeger"}],"year":"2000","title":"Observable operator models for discrete stochastic time series"}},{"authors":[{"last":"Balle"},{"last":"al."}],"year":"2011","style":0,"reference":{"authors":[{"first":"B.","last":"Balle"},{"first":"A.","last":"Quattoni"},{"first":"X.","last":"Carreras"}],"year":"2011","title":"A spectral learning algorithm for finite state transducers"}},{"authors":[{"last":"Lugue"},{"last":"al."}],"year":"2012","style":0,"reference":{"authors":[{"first":"F.","middle":"M.","last":"Lugue"},{"first":"A.","last":"Quattoni"},{"first":"B.","last":"Balle"},{"first":"X.","last":"Carreras"}],"year":"2012","title":"Spectral learning for non-deterministic dependency parsing"}},{"authors":[{"last":"Parikh"},{"last":"al."}],"year":"2011","style":0,"reference":{"authors":[{"first":"A.","last":"Parikh"},{"first":"L.","last":"Song"},{"first":"E.","middle":"P.","last":"Xing"}],"year":"2011","title":"A spectral algorithm for latent tree graphical models"}},{"authors":[{"last":"Goodman"}],"year":"1996","style":0,"reference":{"authors":[{"first":"J.","last":"Goodman"}],"year":"1996","title":"Parsing algorithms and metrics"}},{"authors":[{"last":"Petrov"},{"last":"al."}],"year":"2006","style":0,"reference":{"authors":[{"first":"S.","last":"Petrov"},{"first":"L.","last":"Barrett"},{"first":"R.","last":"Thibaux"},{"first":"D.","last":"Klein"}],"year":"2006","title":"Learning accurate, compact, and interpretable tree an-notation"}},{"authors":[{"last":"Hsu"},{"last":"al."}],"year":"2009","style":0,"reference":{"authors":[{"first":"D.","last":"Hsu"},{"first":"S.","middle":"M.","last":"Kakade"},{"first":"T.","last":"Zhang"}],"year":"2009","title":"A spectral algorithm for learning hidden Markov models"}},{"authors":[{"last":"Hsu"},{"last":"al."}],"year":"2009","style":0,"reference":{"authors":[{"first":"D.","last":"Hsu"},{"first":"S.","middle":"M.","last":"Kakade"},{"first":"T.","last":"Zhang"}],"year":"2009","title":"A spectral algorithm for learning hidden Markov models"}},{"authors":[{"last":"Foster"},{"last":"al."}],"year":"2012","style":0,"reference":{"authors":[{"first":"Dean","middle":"P.","last":"Foster"},{"first":"Jordan","last":"Rodu"},{"first":"Lyle","middle":"H.","last":"Ungar"}],"year":"2012","title":"Spectral dimensionality reduction for hmms"}},{"authors":[{"last":"Hsu"},{"last":"al."}],"year":"2009","style":0,"reference":{"authors":[{"first":"D.","last":"Hsu"},{"first":"S.","middle":"M.","last":"Kakade"},{"first":"T.","last":"Zhang"}],"year":"2009","title":"A spectral algorithm for learning hidden Markov models"}},{"authors":[{"last":"Foster"},{"last":"al."}],"year":"2012","style":0,"reference":{"authors":[{"first":"Dean","middle":"P.","last":"Foster"},{"first":"Jordan","last":"Rodu"},{"first":"Lyle","middle":"H.","last":"Ungar"}],"year":"2012","title":"Spectral dimensionality reduction for hmms"}},{"authors":[{"last":"Goodman"}],"year":"1996","style":0,"reference":{"authors":[{"first":"J.","last":"Goodman"}],"year":"1996","title":"Parsing algorithms and metrics"}}]}
