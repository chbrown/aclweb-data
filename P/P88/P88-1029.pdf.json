{"sections":[{"title":"Conditional Descriptions in Functional Unification Grammar Robert T. Kasper USC/Information Sciences Institute 4676 Admiralty Way, Suite 1001 Marina del Rey, CA 90292 U.S.A. Abstract","paragraphs":["A grammatical description often applies to a linguistic object only when that object has certain features. Such conditional descriptions can be indirectly modeled in Kay's Functional Unification Grammar (FUG) using functional descriptions that are embedded within disjunctive alternatives. An extension to FUG is proposed that allows for a direct representation of conditional descriptions. This extension has been used to model the input conditions on the systems of systemic grammar. Conditional descriptions are formally defined in terms of logical implication and negation. This formal definition enables the use of conditional descriptions as a general notational extension to any of the unification-based gram° mar representation systems currently used in computational linguistics."]},{"title":"1 Introduction","paragraphs":["Functional Unification Grammar [Kay79] (FUG) and other grammatical formalisms that use feature structures and unification provide a general basis for the declarative representation of natural language grammars. In order to utilize some of the computational tools available with unification grammars, we have developed a mapping from"]},{"title":"sVstelnic ¢ram-","paragraphs":["mars [Hall76] into FUG notation. This mapping has been used as the first step in creating a general parsing method for systemic grammars [Kas87a]. The experience of translating systemic grammars into FUG has shown several ways in which the notational resources of FUG may be improved. In particular, FUG has limited notational resources for expressing conditional information. In this paper we describe how FUG has been enhanced by the addition of conditional descriptions, building on research that has already been reported [Kas87a,Kas86,Kas87b].","Conditional information is stated explicitly in systemic grammars by the input conditions of systems that specify when a system must be used. Consider, for example, the two systems (MoodType and Indicatlve'l~ype) x shown in Figure 1. The input condition for the MoodType system is the feature","IThis example is extracted from Nigel [Mann83], a large systemic grammar of English that has been developed in text generation research at USC/ISI. C/auae, and the input condition for the IndicatlveType system ls the feature Indicative. Because the features of a systemic grammar are normally introduced by a unique system, these input conditions actually express a bidirectional type of logical implication:","I. If a constituent has the feature(s) specified by a system's input condition, then exactly one of the alternatives described by that system must also be yard for the constituent;","2. If a constituent has one of the feature alternatives described by a system, then it must also have the feature(s) specified by that system's input condition. Thus the input condition of the Irtd/cative~pe system expresses the following implications: 1. If a clause ha~s the feature"]},{"title":"Indic,~tive,","paragraphs":["then it must also have exactly one of the alternatives from the Zndica-"]},{"title":"tive23,/pe","paragraphs":["system (either"]},{"title":"Declarative","paragraphs":["or"]},{"title":"Interrogative).","paragraphs":["2. If a clause has one of the feature alternatives described by the"]},{"title":"Indicativs~3ype","paragraphs":["system (either"]},{"title":"Declarative","paragraphs":["or/n-"]},{"title":"terrooaties),","paragraphs":["then it must also have the feature"]},{"title":"Indiea- ties.","paragraphs":["While it is theoretically correct to regard the two directions of implication as exact converses of each other, there is a subtle difference between them. The consequent of the first type of implication is the description of the entire system, including systemic features and their realizations. 2 The antecedent of the second type of implication can be safely abbreviated by the systemic features without their realizations, because the presence of a systemic feature implies that its realizations also hold. We will return to this distinction when we provide a formal definition of conditional descriptions in Section 2.","For simple input conditions, the first type of implication can be expressed in FUG, as it was originally formulated by Kay [Kay79], by embedding the description of one system inside the description of another. For example, we can capture this implication for the IndicativeType system by embedding it within the description of the Indicative alternative of the","2A realization is a statement of structural properties that are required by a feature, such as the statement that SUBJECT precedes FINITE for the feature declarative. 233 RANK"]},{"title":"~","paragraphs":["-Clause"]},{"title":"MOOD","paragraphs":["TYPE"]},{"title":"~","paragraphs":["Imperative NONFINITIVE!Stem","LIn INDICATIVE dlcatlve TYPE SUBJECT:Nominative","Dseclarative UBJECT ̂FINITE Llnterrogatlve Figure 1: The MoodType and IndicativeType Systems","Rank = Clause MoodType = Imperative NONFI~ITIVE---- [ Form = Stem ] J MoodType -- Indicative ] SUBJECT ----\" [ Case = Nominative ]"]},{"title":"L","paragraphs":["f F IndicatlveType = Declarative 1 ~ pattern = (... SUBJECT FINITE...) j"]},{"title":"J","paragraphs":["L ~"]},{"title":"IndicativeType -----","paragraphs":["Interrogative"]},{"title":"]","paragraphs":[". 3 IndicatlveType ~ [ MoodType -- Indicative ] \" Figure 2: The MoodType and IndlcativeType Systems in FUG MoodType system, as shown in Figure 2. Note that the second type of implication expressed by systemic input conditions has not been expressed by embedding one functional description inside another. To express the second type of lmplicatlon, we have used a different notational device, called a feature existence condition; it will be defined in Section 2.4.","Not all systems have simple input conditions consisting of single features. Those input conditious which are complex boolea~u expressions over features cannot be expressed directly by embedding. Consider the BenefactiveVolce s system shown in Figure 3 as an example. Its input condition is the conjunction of two features, Agentive and Benefactive.","One way to express a system with a complex input condition in FUG is to use a disjunction with two alternatives, as shown in Figure 4. The first alternative corresponds to what happens when the Benef~ctiveVoice system is entered; the second alternative corresponds to what happens when the BenefactlveVoice system is not entered. The first alternative also includes the features of the input condition. The second alternative includes the features of the negated input condition. Notice that the input condition and its negation must both be stated explicltly, unlike in systemic notation. If the negation of the input condition was not included in the second alternative, it would be possible to use this alternative","3The BenefactivcVoice system iJ also extracted from the Nigel grammar [Mann83]. It describes the active and passive voice op-tions that are possible in clauses that have both an agent and a beneficiary. The active/passive distinction is not primitive in systemic grammars of English. Instead, it is decomposed into several cases depending on which participant roles are present in the clause. In this case the subject of a passive clause may be conflated with either beneficiary or medium. even when the input condition for the system holds. Thus the description of the system would not always be used when it should be. Note that this method of encoding systemic input conditions presupposes an adequate treatment of negated features.\" A formal definition of negation will be developed in Section 2.3.","While it is formally possible to encode complex input conditione by disjunction and ne~tion, such encoding IS not altogether satisfactory: It should not be necessary to state the negated input condition explicitly, since it can always be derived automatically from the unne&-~ted condition. It is also rather inefficient to mix the features of the input condition with the other features of the system. The features of the input condition contain exactly the information that is needed to choose between the two alternatives of the disjunction (Le., to choose whether the system is entered or not). It would be more efficient and less verbose to have a notation in which the features of the input condition are distlnguished from the other features of the system, and in which the negation of the input condition does not need to be stated explicitly. Therefore, we have developed an extension to FUG that uses a conditional operator (-~), as illustrated by the encoding of the BenefactiveVoice system shown in Figure 5. A description corresponding to the input condition appears to the left of the --~ symbol, and the description to be included when the input condition is satisfied appears to its right. A formal definition of what it means for a description to be satisfied will be given in Section 2.1.","4Some negations of atomic features can be replaced by a finite disjunction of other pouible values for that feature, but this technique only works effectively when the set of possible values is small and can be enumerated."]},{"title":"234 Agentive","paragraphs":["-"]},{"title":"Benefactive","paragraphs":["- BENEFACTIVE VOICE"]},{"title":"f 'Benefact]veActive AGENT / SUBJECT lv[EDIUM / DIRECTCOMP IvfedloPazslve MEDIUM / SUBJECT -BenePsssive BENEFICIARY / SUBJECT MEDIUM / DIRECTCOMP Figure'3: The BenefactiveVoice System. Rank = Clause Agentivity = Agentive Benefaction = Benefacitve ' BenefactiveVoice = BenefactiveActive ]","paragraphs":["AGENT = <SUBJECT> | MEDIUM = <DIRECTCOIqP> ]"]},{"title":"BenefactlveVoice = MedioPassive ]","paragraphs":[", MEDIUM = <SUBJECT>"]},{"title":"BenefactlveVolce = BenePassive |","paragraphs":["BENEFICIARY = <SUBJECT> | , MEDIUM = <DIRECTCOMP>"]},{"title":"J 'Agentivity","paragraphs":["= NOT AEentive ] ~ ] '"]},{"title":"Benefaction = NOT Benefactive ] S / BenefactlveVolce = NONE J Figure 4: BenefactiveVoice system in FUG, using disjunction and negation. Rank = Clause Agentivity = Agentlve ] BenefactiveVoice = lvfedioPasslve","paragraphs":["---k"]},{"title":"Benefaction = Benefactive MEDIUM = <SUBJECT> BenefactlveVoice = BenePessive BENEFICIARY = <SUBJECT> MEDIUM = <DIRECTCOIVIP> 3 BenefactiveVolce --, [ Agentivity = Agentlve ] Benefaction = Benefactlve BenefactiveVolce = BenefactiveActive ] ]","paragraphs":["AGENT = <SUBJECT> MEDIUM = <DIRECTCOMP>"]},{"title":"Figure 5: BenefactiveVoice system in extended FUG, using two conditional descriptions. Note: In systemic notation curly braces represent conjunction and square braces represent disjunction, while in FUG curly braces represent disjunction and square braces represent conjunction.","paragraphs":["235 Note: A and L are NIL l:~"]},{"title":"~<p~ > ..... <p. >] ~ ̂~ or [~... ~.]","paragraphs":["~bz V~b~ or {~bz...~b.} denoting no information; where a E A, to describe atomic values; where l E L and ~b E FDL, to describe structures in which the feature labeled by I has a value described by ~; where each p; E L', to describe an equivalence class of paths sharing a common value in a feature structure; where ~i E FDL, denoting conjunction; where ~; E FDL, denoting disjunction. sets of symbols which are used to denote atomic values and feature labels, respectively. Figure 6: Syntax of FDL Formulas."]},{"title":"2 Definitions","paragraphs":["The feature description logic (FDL) of Kasper and Rounds [Kas86] provides a coherent framework to give a precise interpretation for conditional descriptions. As in previous work, we carefully observe the distinction between feature structures and their descriptions. Feature structures are represented by directed graphs (DGs), and descriptions of feature structures are represented by logical formulas. The syntax for formulas of FDL is given in Figure 6. We define several new types of formulas for conditional descriptions and negations, but the domain of feature structures remains DGs, as before."]},{"title":"2.1 Satisfaction and Compatibility","paragraphs":["In order to understand how conditional descriptions are used, it is important to recognize two relations that may hold between a particular feature structure and a description: satisfaction and compatibility. Satisfaction implies compatibility, so there are three possible states that a particular structure may have with respect to a description: the structure may fully 8ati~/X/the description, the structure may be i.eompat. isle with the description, or the structure may be ¢ompatiMe with (but not satisfy) the description. To define these terms more precisely, consider the state of an arbitra~ 7 structure, /~, with respect to an atomic feature description, f : e:","satisfies f : e if f occurs in A with value e;","is incompatible with f : e if j' occurs in g with value","z, for some z ~ ~; /~ is (merely) compatible with f : e if f does not occur","inA.","Because feature structures are used to represent partial information, it is possible for a structure that is merely compatible wlth a description to be extended (i.e., by adding a value for some previously nonexistent feature) so that it either satisfies or becomes incompatible with the description. Consider, for example, the structure (~z) shown in Figure 7, and the three descriptions:"]},{"title":"aubj : (perao.","paragraphs":[": 3 A .umber :"]},{"title":"ai.g)","paragraphs":["(I) subj : (perao. : 1 A .umber : .i.g) (2) 8=by: (case : .ore ̂.t,,nbe. : si.g) (3)"]},{"title":"subj","paragraphs":["~nder stag neut Figure 7: Example feature structure (AZ)- Description (I) is satisfied by Az, because z is fully iustantiated with all the required feature values. Description (2) is i,eompatible with Az, because Az has a different value for the feature aubj : person. Description (3) is merely compatible with Az (but not satisfied by Az), because Az has no value for the feature aubj : e~se.","In the following definitions, the notation A ~ ~5 means that the structure A satisfies the description ~, and the notation A ~ ~ means that the structure A is compatible toith the description ~.","Logical combinations of feature descriptions are evaluated with their usual semantics to determine whether they are satisfied by a structure. Thus, a conjunction is satisfied only when every conjunct is satisfied, and a disjunction is satlsfied if any disjunct is satisfied. The formal semantics of the satisfaction relation has been specified in our previous work describing FDL [Kas86]. The semantics of the compatibility relation is given by the following conditions:","I. ~ -- NIL always;","2. A .~ • ¢=¢. /~ is the atomic structure ~;","3. A ~ [< Pz >,-.-,< P. >] ~=~ all DGs in the","set {~q/ < Pz > ..... 4/ < p. >} can be unified (any","member of this set may be undefined; such members","are equivalent to null DGs);","4. /~ ~ I : ~ ¢=~ /~/! is undefined or ~/1 ~ ~;","5. A~~V~ ¢=~ ~~~or~~~0;","6. ~ N ~bA~, ¢ffiffi~ .~, canonical form of~bA~. Unlike satisfaction, the semantics of compatibility cannot be defined by simple induction over conjunctive formulas, because of a subtle interaction between path equivalences and 236 nonexistent features. For example, consider whether"]},{"title":"A,,","paragraphs":["shown LU Figure 7, is compatible with the description: nurnber: pl A |< ~*~mber >, <"]},{"title":"aubj","paragraphs":["number >]. A, is compatible with r~urnber : pl, and d, k also compatible with ~< nurnber >,< subj n~mber >l, but #~, is not compatible with the conjunction of these two descriptions, because it requires aub] : r~mber : pl and ,~, has si~,g as the value of that feature.","Thus, in order to determine whether a structure is compatible wlth a conjunctive description, it is generally necessary to unify all conjuncts, putting the description into the canonical form described in [Kas87c]. This canonical form (i.e. the feature.description data structure) contains definite and indefinite components. The definite component contains no disjunction, and is represented by a DG structure that satisfies all non-disjunctive parts of a description. The indefinite component is a list of disjunctions. A structure is compatible with a description in canonical form if and only if it is unifiable with the definite component and it is compa!;ible wlth each disjunction of the indefinite component."]},{"title":"2.2 Conditional Description","paragraphs":["We augment FDL with a new type of formula to represent conditional descriptions, using the notation, n -. ~, and the standard interpretation given for material implication: AI = ~ -~ p ~ AI =~av#. C4) This Luterpretatlon of conditionals presupposes an interpretation of negation over feature descriptions, which is given below. To simpLify the interpretation of negations, we exclude formulas contaiuing path equivalences and path values from the antecedents of conditlonak."]},{"title":"2.3 Negation","paragraphs":["We use the classical interpretation of negation, where /~ ~ -~b ¢=~ /~ ~: #. Negated descriptions are defined for the following types of formulas: 1. A~-~ ¢=~ A is not the atom ~; 2. A ~ -~(l : ~) ~ Jl ~= l : \"-~ or .~/!"]},{"title":"is","paragraphs":["not defined;"]},{"title":"3. ,~ ~ -~(~ v ,/,) ~:~ A ~ -,~ ̂-,,p; 4. ,~ M -,(~ ̂,p) ~ ,~ M -,~ v -,,p.","paragraphs":["Note that we have not defined negation for formulas contain-ing path equivalences or path values. Thls restriction makes it possible to reduce all occurrences of negation to a boolean combLuatlon of a fiuite number of negative constraints on atomic values. While the classical interpretation of negation is not strictly monotonic with respect to the normal subsumptlon ordering on feature structures, the restricted type of negation proposed here does not suffer from the inefficiencies and order-dependent uuificaticn properties of general negation or intuiticnistic negation [Mosh87,Per87]. The reason for this is that we have restricted negation so that all negative information can be specified as local constraLuts on single atomic feature values. Thus, these constraints only come into play when specific atomic values are proposed for a feature, and they can be checked as efficiently as positive atomic value constraints."]},{"title":"2.4 Feature Existence Conditions","paragraphs":["A special type of conditional description k needed when the antecedent of a conditional is an existence predicate for a particular feature, and not a regular feature description. We call this type of conditional a [eature ezistence condition, and use the notation: B/ -+ ~, where A ~ 3[ 4==~ A/[ is defined. Thk use of B/is essentially equivalent to the use of f = ANY in Kay's FUG, where ANY lsa place-holder for any substantive (i.e., non-NIL) value.","The primary effect of a feature existence condition, such as 3f --, ~, is that the consequent is asserted whenever a substantive value is introduced for a feature labeled by f. The treatment of feature existence conditions differs slightly from other conditional descriptions in the way that an uusatisfiable consequent is handled. In order to negate the antecedent of 3f --~ #, we need to state that f may never have any substantive value. This is accomplished by unifying a special atomic value, such as"]},{"title":"NONE,","paragraphs":["with the value of f. This special atomic value is incompatible with any other real value that might be proposed as a value for f.","Feature existence conditions are needed to model the second type of implication expressed by systemic input conditions - namely, when a constituent has one of the feature alternatives described by a system, it must also have the feature(s) specified by that system's input condition. Generally, a system named f with input condition a and alternatives described by/~, can be represented by two conditional descriptlons: 1. a .--. p;","2. Bf -* a. For example, recall the BenfactiveVoice system, which is represented by the two conditionals shown in Figure 5.","It is important to note that feature existence conditions are used for systems with simple input conditions as well as for those with complex input conditions. The use of feature existence conditions is essential in both cases to encode the bidirectional dependency between systems that is implicit in a systemic network."]},{"title":"3 Unification with Conditional Descriptions","paragraphs":["The unification operation, which is commonly used to cornblue feature structures (i.e., non-disjunctive, non-conditional DGs), can be generalised to define an operation for combLuLug the information of two feature descriptions (i.e., formulas of FDL). In FDL, the unification of two descriptions is equivalent to their logical conjunction, as discussed in [Kas87b]. We 237 have shown in previous work [Kas87c] how unification can be accomplished for disjunctive descriptions without expanding to disjunctive normal form.","This unification method factors descriptions into a canonical form conslstlng of definite and indefinite components. The definite component contains no dlsjunctlon, and is represented by a DG structure that satisfies all non-disjunctive parts of a description. The indefinite component of a description k a list of disjunctions. When two descriptions are unified, the first step is to unlfy their definite components. Then the indefinite components of each description are checked for compatlbility with the resulting definite component. Dlsjuncts are eliminated from the description when they are inconsistent with deflnlte information. When only one alternative of a disjunction remains, it is unified with the definite component of the description.","This section details how thls unification method can be extended to handle conditional descriptions. Conditionals may be regarded as another type of indefinite information in the description of a feature structure. They are indefinite ]n the sense that they impose constraints that can be satisfied by several alternatives, depending on the values of features already present in a structure."]},{"title":"3.1 How to Satisfy a Conditional Description","paragraphs":["The constraints imposed on a feature structure by a conditional description can usually be determined most emclently by first examining the antecedent of the conditional, because it generally cont~nl a smaller amount of information than the consequent. F, xamining the antecedent k often sufficient to determine whether the consequent is to be included or discarded.","Given a conditional description, C ---- ~ -+ ~, we can define the coustralnts that it imposes on a feature structure (A) as follows. When: ~ ct, then A ~ ~;6","~ or, then ¢ imposes no further constraint on A, and can therefore be elhnJnated;","A ~, c~, then check whether ~ ls compatible wlth A. If compatible, then C must be retained in the description of ~. If incompatible, then ~ ~ -~a (and ¢ can be elimio nated). These constraints follow directly from the interpretation (4) that we have given for conditional descriptions. These constraiuts are logically equivalent to those that would be imposed on A by the disjunction -~ V ~, as required. However, the constraints of the conditional can often be imposed more ef~ciently than those of the equivalent dJsjunctlon, because examlnlng the antecedent of the conditional carries the same cost as examining only one of the dkjuncts. When the constraints of a disjunction are imposed, both of the disjuncts must be examined in all cases. 6Read this constraint as: Umake sure that .4 satisfies ~.t"]},{"title":"3.2 Extending the Unification Algorithm","paragraphs":["The unification algorithm for dlsjunctlve feature descriptions [Kas87c] can be extended to handle conditionals by recognizing two types of indefinite ~uformatlon in a description: disjunctions and conditionals. The extended feature-descriptlon data structure has the components: definite: a DG structure; disjunctions: a llst of disjunctions; conditionals, a list of conditional descriptions. The part of the unification algorithm that checks the compatibility of indefinite components of a description with its definite component is defined by the function CHECK-INDEF, shown in Figure 8. Thk algorithm checks the disjunctions of a description before conditionals, but an equally correct version of thk algorithm might check conditionals before disjunctions. In our application of parsing with a systemic grammar it is generally more et~cient to check disjunctions first, but • other applications might be made more efBclent by varylng this order."]},{"title":"4 Potential Refinements","paragraphs":["Several topics merit further investlgatlon regarding conditional descrlptions. The implementation we describe has the constraints of conditionals and dkjunctions imposed in an arbitrary order. Chang|ng the order has no effect on the final result, but it is likely that the el~clency of unification could be improved by ordering the conditionals of a grammar in a deliberate way. Another way to improve the efficiency of unification with condltiona~ would involve indexing them by the features that they contain. Then a conditional would not need to be checked against a structure until some feature value of the structure might determine the manner in which it k eat|s fled. The amount of efficiency gained by such techniques clearly depends largely on the nature of the particular grammar being used in an appllcatlon.","A slightly different type of conditional might be used as a way to speed up unification with binary disjunctive descriptions. If it k known that the values of a relatively small number of features can be used to discrimlnate between two alternative descriptions, then those features can be factored into a separate condition in a description such as IF cor, ditioa THEN alt~ ELSE air2. When the condition is satisfied by a structure, then altl is selected. When the condition is incompatible with a structure, then air2 is selected. Otherwise both alternatives must remain under consideration. As it often requires a consider-able amount of time to check which alternatives of a dkjunc-tion are applicable, this technlque might offer a significant improvement in an application where large dlsjunctlve descriptions are used.","Remember that we have restricted conditionals by requiring that their antecedents do not contain path equivalences. 238"]},{"title":"Function","paragraphs":["CHECK-INDEF (desc) Returns feature-description:","where desc is a featur~description. Let P = desc.deflnite (a DG). Let disjunctions = desc.disjunctions. Let conditionals = desc.conditionals. Let unchecked-parts ---- true.","While unchecked-parts, do: unchecked-parts := false. Cheek eomp~h'~/ty oj' d/~nct/onm ~ P (omited, see [Kas87c]).","O~ek eomp~'t~U of ¢o~o~b ~ P:","Let new-conditionals ---- ~.","For each ~, --./9 in conditionals:","test whether D satisfies or is compatible with ,-: SATISFIES: 9 := UNIFY-DGS (9, ~.deflnite),","disjunctions := disjunctions U ~.dlsjunctions,","unchecked-parts := true; COMPATIBLE: If ~) is compatible with ~,","then new-conditionals := new-conditionals U {a --, ~},","else let neg-ante = -~e.","D := UNIFY-DGS (P, neg-ante.deflnite),","disjunctions :---- disjunctions u neg-ante.disjunctions,","unchecked-parts := true; INCOMPATIBLE: t~ eoad~/on,d imposem no ]urO~ee coaa~v~/nt.","end (for loop).","conditionals :---- new-conditionals.","end (while loop). Let nd ---- make feature-description with:","nd.deflnite -~ P, nd.disjunctions = disjunctions, nd.conditionals ---- conditionals. Return (nd). Figure 8: CHECK-INDEF: Algorithm for checking compatibility of indefinite parts of a feature-description with its definite component. This restriction has been acceptable in our use of conditional descriptions to model systemic grammars. It k unclear whether a treatment of conditional descriptions without thls restriction will be needed in other applications. If this restriction is lifted, then further work will be necessary to define the behavior of negation over path equivalences, and to handle such negations in a reasonably e~cient manner."]},{"title":"5 Summary","paragraphs":["We have shown how the notational resources of FUG can be extended to include descriptions of conditional information about feature structures. Conditional descriptions have been given a precise logical definition in terms of the feature description logic of Kasper and Rounds, and we have shown how a unification method for feature descriptions can be extended to use conditional descriptions. We have implemented this unification method and tested it in a parser for systemic grammars, using several hundred conditional descriptions. The definition of conditional descriptions and the unification method should be generaily applicable as an extension to other unificatlon-based grammar frameworks, as well as to FUG and the modeling of systemic grammars. In fact, the implementation described has been carried out by extending PATI~II [Shie84], a general representational framework for unificatlon-based grammars.","While it is theoretically possible to represent the information of conditional descriptions indirectly using notational devices already present in Kay's FUG, there are practical advantages to representing conditional descriptions directly. The indirect encoding of conditional descriptions by dlsjunc-tions and negations entails approximately doubling the size of a description, adding many explicit nonexistence constraints on features"]},{"title":"(NONE","paragraphs":["values), and slowing the unification process. In our experiments, unification wlth conditional descriptions requires approximately 50~ of the time required by unification with an indirect encoding of the same descriptions. By adding conditional descriptions as a notational resource to FUG, we have not changed the theoretical limits of what FUG can do, but we have developed a representation that is more perspicuous, less verbose, and computationaily more e/~clent. Acknowledgements I would like to thank Bill Rounds for suggesting that it might be worthwhile to clarify ideas about conditional descriptions 239 that were only partially formulated in my dissertation at the /Per87] University of Michigan. Helpful comments on earlier versions of this paper were provided by Bill Mann, Ed Hovy and John Bateman.","This research was sponsored by the United States Air [Shie84] Force Office of Scientific Research under contract F49620-87-C-0005; the opinions expressed here are solely those of the author."]},{"title":"References","paragraphs":["/Hall76] Gunther R. Kress, editor."]},{"title":"IIallidap:","paragraphs":["System"]},{"title":"and Function in Language.","paragraphs":["Oxford University Press, London, England, 1976.","[Kas87a I Robert T. Kasper. Systemic Grammar and Functional Unification Grammar. In J. Benson and W. Greaves, editors,"]},{"title":"SVstemic Functional Approaches to Discourse,","paragraphs":["Norwood, New Jersey: Ablex (in press). Also available as USC/information Sciences Institute, Technical Report RS-87-179, May 1987.","[Kas86] Robert.T. Kasper and William C. Rounds. A Logical Semantics for Feature Structures. In"]},{"title":"Proceed- ings of the","paragraphs":["24 ta"]},{"title":"Annual Meeting of the Association for Computational Linguistics,","paragraphs":["Columbia Unlverslty, New York, 1~/', June 10-13, 1986.","[Kas87b] Robert T. Kasper."]},{"title":"Feature Structures: A Lo~cal 7'heorv ~dth Application to Language Analpds. Phi)","paragraphs":["dlssertation, University of Mlchlgan, 1987.","[Kas87c] Robert T. Kasper. A Unification Method for DISjunctive Feature Descriptions. In Proceed/ng8 o/the 25 ta"]},{"title":"Annual Meeting of the Association for Compu- tational Linguistica,","paragraphs":["Stanford University, Stanford, CA, July 6-9, 1987.","/Kay79] Martin Kay. Functional Grammar. In"]},{"title":"Proceeding8 o/the Fifth Annual Meeting of the Bsrkclsp Lingui~- tica Societp,","paragraphs":["Berkeley Linguistics Society, Berkeley, Ca2ifornia, February 17-19, 1979.","[Mmm83] Wi]fiam C. Mann and Christian Matthiemen. Nigel: A Systemic Grammar for Text Generation. USC / Information Sciences Institute, RR-83-105. Also appears in R. Benson and J. Greaves, editors,"]},{"title":"Spatemie Perapectivs~ on Diacourss: Selected Pa- per, Paper8 from the Ninth International Spstsmics WorkJhop,","paragraphs":["Ablex, London, England, 1985.","[Mosh87] ~ Drew Moshier and William C. Rounds. A Logic for Partially Specified Data Structures. In"]},{"title":"Proceed- ing8 of the ACM Spmposium on PrinciplcJ of Pro- graraming Languages,","paragraphs":["1987. Fernando C.N. Perelra. Grammars and Logics of Partial Information. In"]},{"title":"Proceedings of the","paragraphs":["Inter-"]},{"title":"national Conference on Logic Programming,","paragraphs":["Melbourne, AustraLia, May 1987. Stuart M. Shieber. The design of a computer language for lingu]stic information. In"]},{"title":"Proceedings of the Tenth International Conference on Computa- tional Linguistics: COLING 84,","paragraphs":["Stanford Unlversity, Stanford, California, July 2-7, 1984. 240"]}]}
