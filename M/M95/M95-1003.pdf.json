{"sections":[{"title":"FOUR SCORERS AND SEVEN YEARS AGO : The Scoring Method for MUC- 6 Nancy Chinchor, Ph .D. Science Applications International Corporatio n 10260 Campus Point Drive, MIS A2- F San Diego, CA 9212 1 chinchor@gso .saic .co m (619) 458-261 4 Gary Dungca Science Applications International Corporatio n 10260 Campus Point Drive, M/S A2- F San Diego, CA 9212 1 dungca@gso .saic .com (619) 458-4907 INTRODUCTIO N","paragraphs":["The MUC-6 scoring method is based on a two-step process of mapping an item generated by a system under evaluation (the \"response\") to the corresponding item in the human-generated answer key and then scoring th e mapped items . The resulting scores are used for decision-making over the entire evaluation cycle, includin g refinement of the task definition based on interannotator comparisons, technology development using training data , validating answer keys, and benchmarking both system and human capabilities on the test data .","To further understand the scoring method, we will look at the features and algorithms embodied in each o f the scorers, showing their basic similarity and discussing the differences from task to task . We will show how critical the mapping algorithm is in scoring and the problems inherent in deciding what the best mapping should be . We will also discuss the result of translating the emacslisp scorers into C, including the increased accuracy of the mapping a s well as the increased speed and improved memory management . The positive effects on consumer capability will b e shown and future enhancements will be briefly outlined."]},{"title":"MODULAR STRUCTURE OF THE SCORER S The Basic Score r","paragraphs":["The basic design of the scorers is shown in Figure 1 . All four of the scorers follow this basic design : sectionize, parse, map, score, and report."]},{"title":"Sectionize","paragraphs":["The input data consists of three files : one file contains the set of source text articles used in the task ; one fil e contains the set of human-generated answer keys derived from the source articles ; and one file contains the system - generated responses, also derived from the source articles . The key and response files are composed either o f annotated text articles (as in the case of the Named Entity and Coreference text annotation tasks), or of relevant dat a extracted from those articles (as in the case of the Template Element and Scenario Template tasks) . These articles are distinguishable by unique identifiers called document numbers . The scorer sectionizes the data files by creatin g groups based on these document numbers ; each group consists of one each of the three types of input data ."]},{"title":"33 A 0 cu -~","paragraphs":["- ~ - ~ 34 Parse","The scorer parses the data from the input data files and creates structured internal representations of th e information . The structures may represent varying levels of data abstraction, but must be consistent with the levels o f abstraction in the input files . For example, singular pieces of textual data, also known as slot fills, may be combine d with others to comprise a larger, cohesive body, or object, of information . Objects may also contain pointers to othe r objects, forming a hierarchical structure . Map","Mapping is the process by which the scorer aligns answer key objects with a system's response objects . The broad purpose of this alignment is to pair objects that are similar in their slot content, thus optimizing the system' s scores . However, because objects are generally composed of multiple slots, and because objects of the same typ e often have data in common, this notion of similarity between a key and a response object can be complicated. A key object may be similar to more than one response object . Likewise, a response object may be similar to more than on e key object . Also, no one particular slot identifies an object ; after several trials of different weightings over the las t few years, it was decided that each slot should be given equal emphasis when considering an object's mapping, and that the threshold should be set so that getting one slot fill in an object correct is enough for the object to b e considered as a candidate for mapping .","The object pairs that can be considered candidates for mapping are then scored and rank-ordered accordin g to some pre-determined metric . The ordering of identically ranked object-pairs is arbitrary . The scorer then proceeds , in rank order, to align key objects with response objects to generate the final mappings .","In the event that an object has multiple candidate mappings -- a key can be possibly mapped to any o f several responses, and a response can be possibly mapped to any of several keys -- that object is eventually mapped t o the best remaining unmapped partner. As a consequence of this rank-ordered approach, the best ranked pairing fo r any particular key object may not, in fact, result in final alignment. Another key object may have already had a bette r rank-ordered pairing with the same response object, or the arbitrary order of like-ranked pairs may have preclude d this alignment . The same may be said of a response object being compared to different answer key objects .","Another consequence of this approach is manifested in the score results : an object slot may be discredite d because its content does not match the corresponding slot content of the finally aligned object, although it does matc h with the corresponding slot of an alternate object . This can give rise to an argument for giving credit, since matching data does exist in the overall response . However, focus must be maintained at the object level, resulting in assignin g higher value to the cumulative score of all other matched slots in the object at the expense of a few mismatched slots . To either ignore the levels of abstraction or to require a switch of the alignments would likely yield a poorer score . Optimal mapping for a hierarchical template or for relational level objects is an unsolved problem in compute r science . Tree-matching techniques need to be developed for this class of problems, which appear often in artificia l intelligence .","Finally, after all rank-ordered pairs have been considered, the mapper forces pairings, or \"connections\", o n the remaining unmapped objects . The purpose of connections is that without them the slot fills of an unmapped ke y will be scored as missing, and the slot fills for an unmapped response will be scored as spurious . However, if the two objects were connected, then the slots for which both the key and the response provided data will be scored a s incorrect, thus reducing the scoring penalty from two (missing and spurious) to one (incorrect) . After connection, any remaining objects will either be all keys or all responses, i .e ., all missing or all spurious . Score","Mapped object-pairs are scored against each other by comparing their slot fills . Slot fills are either text strings, or pointers to other objects, and every slot has a set of fills that may consist of zero, one, or multiple fills .","Response text strings are considered matched if they are identical to the key, or are identical after ignorin g certain text elements that are considered non-substantive. These elements include a set of premodifiers (e .g ., \"the\" , 35 \"an\", \"a\"), a set of postmodifiers (e .g ., period, question mark, double quote), and a set of corporate-designators (e .g. , \"COMPANY\", \"CO\", \"INC\", \"LTD\") .","Object pointers are considered matched if the objects to which they refer are mapped to each other. Otherwise, the pointers are considered unmatched . The scores for a particular slot fill are tallied as follows : possible - the number of fills provided in the key . actual - \\t the number of fills provided in the response . correct - \\t the number of matches found between the key and the response fills . incorrect - if the slot contains the same number of fills in the key and the response, thi s number is the number of non-matching fills in the response ; if the slot contains differen t numbers of fills in the key and the response, a parallel process to mapping occurs whic h results in this number being the minimum between the number of non-correct fills in th e key and the number of non-correct fills in the response . If the minimum were not taken , the systems would be unfairly over-penalized for mismatched fills . They would be given both missing and spurious scores for all mismatching fills instead of one incorrect for eac h mismatched fill in the response with a correlate in the key . The reasoning behind thi s parallels the notion of \"connection\" in the case of unmapped objects . missing - \\t the number of possible fills for which there was no response. spurious - the number of actual fills for which no key was given .","In the event that alternative sets of fills are provided by the key, then the response set of fills is scored agains t each of the alternate sets in the key . The best key set is selected according to a pre-determined metric and the tallie s for the remaining key sets are ignored .","If a slot fill in the key is marked as optional, then the scorer treats it in one of two ways : 1) if the response provides a slot fill, then it is scored as a normal slot fill ; 2) if the response provides no slot fill, then the content of th e key is ignored, and the response is not penalized for missing the fill .","During the scoring phase, the scoring tallies for all slot fills are totaled for all similar slot fills for all similar object types within the document, as well as for all similar slot fills for all similar object types across all th e documents ."]},{"title":"Report","paragraphs":["After scoring is completed, the scorer provides a slot-by-slot score report for each document, and an overal l summary score report and performance analysis for the set of all documents . For every document, the report display s the score results categorized by object type, and subcategorized within each object type by slot . A total slot score i s also given for each document .","The overall summary score report displays the same object and slot-by-slot scores as the individua l document score reports, but the numbers displayed are the totals across all documents . Similarly, the total slot score i s the total of all the slots for all the objects across all the documents .","In addition to the scoring categories described above in the scoring section, the following metrics are als o displayed in all of the score reports : recall - \\t the number of correct divided by the number of possible . precision - the number of correct divided by the number of actual . 36","These are the basic metrics calculated for all tasks . Additional metrics are calculated for Named Entity , Template Element, and Scenario Template . See the Appendix entitled \"MUC-6 Test Scores\" for information on thes e metrics, which included Error-per-response-fill, Undergeneration, Overgeneration, Substitution, and Text Filtering ."]},{"title":"Portability of the Score r","paragraphs":["The scorers are all driven by data in external files which allows the scoring software to be adapted to othe r similarly structured database objects without a change in code. This capability allows for flexibility from domain to domain and language to language . However, there are limits in terms of the formal structure of the database object s that we can handle and the available alphabets . The definition of the database objects is contained in the slo t configuration file . The BNF of the database objects is manually translated into the form required by the software for the slot configuration file ; this process could be automated in the future . Any legitimate BNF can be handled . Th e emacslisp version of the scoring software can handle any alphabets that the emacs text interface can handle . The C version will shortly be able to at least batch process extended alphabets and 2-byte character sets . An interface to the C versions of the scorers has not been completed for any language, but, when it is, it will be extended to cover non - English alphabets .","The configuration file contains scoring options that are allowed to be set by the user . Most of them hav e defaults, but certain ones require user designation, such as the filename of the messages, keys, and responses . Th e sizable number of options are all listed in the users' manual . The one that most concerns us here is the scoring option that allows key-to-response scoring and key-to-key scoring . During the definition of the task and when final answe r keys have been made, key-to-key scoring is used to compare not only the slot-fill data itself between two versions o f an answer key (usually versions produced by different annotators), but also some slot attributes that may be entere d only in an answer key (alternate slot fills, optional objects and slot fills, and minimal strings) . So key-to-key scoring is based on a broader range of comparisons than key-to-response scoring and is therefore a different and mor e difficult test . Key-to-response scores obtained in an interannotator test are probably a truer measure of human performance than key-to-key scoring provides . It is important to remember that essentially equal answer keys ar e being compared as key and response, and the decision as to which key is the key and which the response is arbitrary and affects the humans' scores ."]},{"title":"ADAPTATION OF PREVIOUS MUC SCORING TECHNOLOGY TO MUC-6 TASK S","paragraphs":["To keep costs down, SAIC reuses scoring code from past evaluations as much as possible while respondin g to changing consumer needs and the experience of past evaluations . In this evaluation, we wrote four scorers, one fo r each task. The scorer for Scenario Template was much the same as in the past except for improvements in mappin g and performance (speed and memory usage) due to the translation into C . Scenario Template contains scores fo r relevancy judgments in the line labeled \"Text Filtering\" and the information retrieval metrics of recall and precisio n are used . The Template Element scorer was a low-cost adaptation of the Scenario Template scorer and does not include relevancy judgments because almost all articles contain these low-level objects .","The scorers for the Named Entity and Coreference tasks diverged from the usual approach because of th e format of the input and the special needs for mapping and scoring . The format is SGML tagged texts . The format required a different parser than the templates or the low-level template objects . However, Named Entity input could still be internally represented as a low-level template (no pointers) object with slot fills . The score report reflects th e difference in how we wanted to analyze the scores according to object type, subcategories, and placement in th e document . To support this breakdown in the score report, the Named Entity scorer had to keep additional tallies . However, the mapping function was much simplified because the tags were anchored in the text and the text had to b e overlapping in order for the items to be candidates for mapping .","The input for the Coreference task was close in format to the Named Entity input and had the easier mappin g conditions as well, but the scoring was based on linkages rather than slot fills . The algorithm for scoring the linkages could be a simple counting process of the subsequent noun phrases in the coreference chain, but that would b e computationally too expensive . The implemented algorithm for scoring the linkages was discovered by participants a t MITRE Corporation [1] . It is elegant in its way of determining the minimal number of changes in the linkage s 37 required to make the response the same as the key to calculate recall and to make the key the same as the response t o calculate precision . It defines recall and precision in a geometric way . Also, it is computationally inexpensive whil e being provably equivalent to counting subsequent noun phrases in the chain ."]},{"title":"Translation from emacslisp into C","paragraphs":["The semi-automated scoring program was originally developed for MUC-3 in emacslisp by General Electri c using SAIC specifications . SAIC then took over the maintenance of that software for MUC-4 . Emacslisp suited ou r needs at the time, which included rapid prototyping, a familiar text interface, and a portable lisp available to al l participating and evaluating sites at no cost.","Over the years we have moved to complete automation of the scoring and have tried out several differen t approaches to mapping . As time passed, the limitations of emacslisp began to outweigh the its convenience . In MUC-5 the number of documents that we wanted to use in a data set caused a \"memory exhausted\" message during loadin g of the scorer. We were forced to divide the development and test articles and their answer keys into subsets making the scoring process even longer. Emacslisp does not allow applications programmers to manage memory usage, but C does . Also, even in batch mode the scoring took hours for each site . We knew that by translating to C we could get a sizable gain in speed .","After completing the translation of the scorer into C, we benchmarked 100 articles on a SPARC-20 and found that it took 10 seconds of elapsed time . We have not experienced and do not anticipate a memory problem wit h larger data sets because C's memory management capabilities have been taken advantage of in the coding . During the translation, we also implemented a new mapping algorithm that is more accurate than the lisp version . This change to C also allows us to implement all of the old features and add features that were put on hold because of the limitation s of emacslisp . Also, we can actively pursue other more effective mapping algorithms that require more memor y without very much speed impact . The speed of the C version is critical during system development, especially fo r those evaluation participants that use training in any part of their system . The diagnostics are produced faster as well . Overall, the scorer has become a much more useful tool for all consumers .","The status to date is that the Scenario Template and Template Element scorers are completely in C and ca n be run in batch mode only . The official scores were determined by the C version of each because of the more accurat e mapping . The interfaces do not as yet exist, but are planned . The batch mode of the Named Entity scorer is almos t completely translated into C . The Coreference scorer is still in emacslisp . The lisp versions of Named Entity an d Coreference were used for the MUC-6 scoring . The scores will not change in these when converted to C becaus e mapping candidacy is based on overlapping offsets . The official results would thus have stayed the same . The Coreference scorer will probably stay in emacslisp while the task definition is evolving in order to facilitate rapid prototyping ."]},{"title":"FUTURE ENHANCEMENTS","paragraphs":["We are planning to extend the scorer to handle non-English alphabets . We will begin with the Named Entit y scorer, but because there is so much in common with the Scenario Template and Template Element scorers, these wil l be easier to modify. We are completing the Named Entity translation into C and expect to do the same wit h Coreference at a later date . We plan to develop a Graphical User Interface to all of the C scorers so that all of th e useful emacslisp features translated and so that we can provide more features without noticeable impact on th e performance ."]},{"title":"REFERENCES","paragraphs":["[1] Vilain, M., Burger, J ., Aberdeen, J ., Connolly, D ., and L . Hirschman (1995) \"A Model-Theoretic Coreferenc e Scoring Scheme\" Technical Report MITRE . 38"]}]}