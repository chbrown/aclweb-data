{"sections":[{"title":"A Strategy for Dynamic Interpretation: a Fragment and an Implementation","paragraphs":["Olivier Bouchez 1,2, Jan van Eijck 2,3 and Olivier Istace 1,2"]},{"title":"EMAIL: obo@info.fundp.ac.be, jve@cwi.nl, ois@info.fundp.ac.be lInstitut d' Informatique, FUNDP, 61 Rue de Bruxelles, 5000 Narnur, Belgium, 2CWI, P.O. Box 4079, 1009 AB Amsterdam, The Netherlands 3OTS, Trans 10, 3512 JK Utrecht, The Netherlands","paragraphs":["Abstract The strategy for natural language interpretation presented in this paper implements the dynamics of context change by translat-ing natural language texts into a meaning representation language consisting of (descriptions of) programs, in the spirit of dynamic predicate logic (DPL) [5]. The difference with DPL is that the usual DPL semantics is replaced by an error state semantics [2]. This allows for the treatment of unbound anaphors, as in DPL, but also of presuppositions and presupposition projection. The use of this dynamic interpretation strategy is demonstrated in an implementation of a small fragment of natural language which handles unbound pronoun antecedent links, where it is assumed that the intended links are indicated in the input string, and uniqueness presuppositions of definite descriptions. The implementation consists of a syntax module which outputs parse trees, a semantic module mapping parse trees to DPL representations, a representation processor which determines truth conditions, falsity conditions and presupposition failure conditions, and an evaluator of these conditions in a database model. The implementation uses the logic programming language GSdel [6], an experimental successor of Prolog, with similar functionality and expressiveness, but with an improved declarative semantics.","1 The Idea of Dynamic Interpretation Recent developments in Natural Language semantics have witnessed a shift away from static representation languages towards representation languages with a dynamic flavour. Such representation languages can be viewed as definitions of very simple imperative programming languages.","To see how the imperative style comes in, consider the treatment of indefinite descriptions (or: existential phrases). Existential quantifiers are viewed dynamically as random assignment statements followed by tests. The translation of the natural language phrase 'a man' becomes something like:","x := ?; man(x)","The first part of this statement can be viewed as a random assignment to register x, the second part as a test on the value ofx. This sequence of instructions is performed against the background of a database, i.e., a model of first order logic. The sequence succeeds if the database contains (representations of) men, and it can succeed in as many ways as there are men available in the database.","The motivating examples for the shift from static to dynamic representation have to do with pronoun binding. The translation of phrases like 'a man' in terms of assignments of values to registers makes it possible to treat binding of pronouns across sentence boundaries (the next sentence can start with 'He' to pick up the reference to 'a man'). The nice thing about the treatment in terms of assignment is that the scope of the existential quantification is not closed off at the end of a sentence, as used to be the case for NL systems that employ static representation (in terms of the existential quantifiers of predicate logic, with their irritating closing brackets). 61","Recently, it has become clear that dynamic representation has some other interesting features:","• It becomes possible to give an account of pre-","supposition failure phenomena in terms of the","definition of an error state semantics for the dy-","namic representation language [3; 2]. Presuppo-","sition failure occurs for example if one tries to","interpret \"John's wife is unhappy\" in a situation","where John is not married.","• A more natural treatment of tense becomes pos-","sible. A sequence of sentences in the past tense","like \"A man walked in. He sat down. He or-","dered a drink\" etc, is represented using subse-","quent assignments of values (time intervals) to","a dedicated time register t [10]. The dynamic representation language can be analysed with tools that were originally designed for analysing imperative programming languages, namely the tools for precondition reasoning from Itoare logic or dynamic logic [11]. Precondition reasoning for dynamic predicate logic with standard semantics was introduced in [4]. Precondition reasoning gives the truth conditions of DPL representations in the form of formulas of first order logic (FOL). When applied to the error state semantics of DPL, precondition reasoning can also be used to find the presupposition failure conditions of DPL representations as FOL formulas.","We provide an integrated treatment of syntax and semantics of a small fragment of natural language and test this by implementing it. The syntax of our toy grammar is a version of categorial grammar with feature unification. The semantics uses DPL representations, with an error state semantics which is reflected in the rules for precondition reasoning implemented in the precondition module. This module generates predicate logical formulas expressing the weakest preconditions of success, failure or error of the DPL representations.","In detail, our interpretation strategy consists of the following steps: 1. Parsing a sentence or text and building a repre-","sentation tree of its structure. 2. Translating the parse tree into a DPL program. 3. Using precondition reasoning to compute pre-","conditions as formulas of FOL. 4. Simplifying the preconditions using a simplifier","for FOL formulas. 5. Evaluating the resulting formulas in a database","model. The current implementation produces for an input text within the grammar fragment: a LaTeX form report containing the sentence, the parse tree, the DPL translation, the precondition of success, the precondition of failure and the precondition of error, all in simplified form, and the result of evaluation in the database. 2 Dynamic Predicate Logic 2.1 Informal discussion DPL meaning representations for natural language sentences can be viewed as procedures or programs with a relational semantics. The programs that represent the meanings are interpreted as relations between input states and output states. A state is a mapping from variables to values in a model (in our simple set-up all variables are of the same type). The representation for an example sentence such as \"John saw a man\" is a program which associates John with a variable z, a man with a variable y, and first checks whether the value of x equals John, next puts a value in y which satisfies the predicate of being a man, and finally checks whether the values of z and y are such that the first saw the second.","Thus, the representation of \"John saw a man\" is a program which relates input states where z is mapped to John to output states where z is mapped to John and y is mapped to some man seen by John. If the evaluation takes place in a model where John saw several men, then there are several possible output states. If the evaluation takes place in a model where John saw no men at all, then there is no output. A program that yields no output for a given input fails for that input. A program yielding at least one output for a given input succeeds for that input. A program which yields at most one output for a given input is deterministic for that input. A program which yields more than one output for a given input is indeterministic for that input. The example \"John saw a man\" shows that indefinite descriptions may give rise to indeterministic programs. Deterministic programs that do not change their input are called test programs. If a test program succeeds, its output equals its input. The sentence \"John saw him\" would give rise to a test program. Assuming that the variable z, y are used for the subject and object of the sentence, respectively, the program will succeed for any input with x mapped to John and ~/ mapped to some male individual seen by John. In this case success means that the output state equals the input state. The program will fail for any other input.","All basic programs of DPL are tests; they do not change their input, and they succeed if the values of terms are in a specified relation and fail otherwise.","Indeterminism in DPL arises from assignment programs. The assignment program for an indefinite description a man will assign a new value to a variable x and succeed for any value of z which is a man. This is called indefinite assignment. The assignment program for a definite description ~he manager gives a value to a variable if and only if there is only one possible value in the model under consideration.","Complex programs can be formed by means of negation, implication and sequential composition. Negation and implication always form tests, but se-62 quential composition does not. Sequential compositions are tests if and only if the component programs are tests. 2.2 Syntax For ease of exposition we will assume there are no function symbols in the DPL representation language, so the terms of DPL are either constants or variables. Let C be the set of constants, V the set of variables, and assume c E C, v E V. DPL terms t ::= c I v. Assume a set of relation symbols R with arities. Then the programs of DPL are given by the following BNF definition. DPL programs ~r ::= t = t I Rt...t [ Qr;r) [(r ::~"]},{"title":"I I v: I,v :","paragraphs":["We will use man, see as the relation symbols that translate \"man\", \"see\", and so on. Thus, (1) is a DPL program. (1) (T/v2 : man(v2); see(v2, v4)). We will omit outermost brackets and brackets in sequential compositions like"]},{"title":"((71\"1;7i'2);r3).","paragraphs":["This is harmless, for sequential composition is associative. Also, we will abbreviate r]v : v = t as v := t. This abbreviation is natural, as the sequential composition of random assignment to v and test for equality with t boils down to assigning the value of t to v. 2.3 Indices for Antecedents and Anaphors In the natural language fragment we treat, we use co-indexing to indicate intended anaphoric links. We follow Barwise [1] in using superscripts for an-tecedents and subscripts for anaphors. (2) A man walked in. He smiled. If we intend the pronoun in (2) to refer to the subject of the first sentence, we indicate this intention as follows. (3) A man 1 walked in. He1 smiled. The superscript on the indefinite noun phrase indicates that this NP acts as an antecedent for NPs with the same index as a subscript. The subscript on the pronoun indicates the antecedent to which the pronoun is linked.","The use of subscripts and superscripts is necessary because noun phrases can act as anaphors and an-tecedents at the same time. (4) A man I walked in.","Another man~ walked ont.","Hez was angry. In example (4) the noun phrase another man is anaphorically constrained by an antecedent noun phrase a man (it must have a different referent), and at the same time acts as antecedent for the second occurrence of a man.","The superscripts and subscripts refer to the variables we employ in the translation of the noun phrases. Superscripts correspond to variables that get assigned a value in the translation, subscripts to variables that are simply used. Sentence (5) will get translated as (6) (tense is ignored, here and hereafter, for ease of exposition). (5) John 1 saw a man 2."]},{"title":"(6) vl := J; : man( 2); see( l,,2).","paragraphs":["Sentence (7) gets translated as (8). (7) Mary 3 ignored himx. (8) va := M; ignore(va, vl). Sentence (9) gets translated as (10). (9) Shea saw another man~. (10) ~/v4; v4 ¢ v2; man(v4); see(va, v4). Turning now to definite descriptions, the natural translation of example (11) is (12). (11) John I saw the man 2. (12) vl := J; ~v2 : man(v2); see(vl, v2). In the error state semantics for DPL that we have in mind for this, (12) gives error in every model where there is no unique man. It is clear that in most cases this is too strong. Still, we do not think this is a serious problem for our general approach. It seems to be a linguistic fact that definite descriptions often are used in a context-dependent way, to designate a unique referent in a very specific context, which however is not made fully explicit.","One context where (11) makes perfect sense is a situation where John and some other male individual are present, and where it is left implicit that John is excluded from the context where the reference is unique. In such cases we propose to read the definite description as uniquely satisfying the description plus the extra condition of being non-identical with some constraining antecedent, in this case the subject of the sentence. This strategy boils down to reading (11) as (13). (13) John 1 saw the other man~. Here the determiner the otheri is treated similarly to anotheri. This gives translation (14)."]},{"title":"(14) Vl","paragraphs":[":= J; ,v2:(v2 ¢ vi; man(v2));"]},{"title":"see(vi,","paragraphs":["cases another mechanism seems to be at In many"]},{"title":"work.","paragraphs":["(15) A man walked in. John saw the man. Example (15) has a natural reading where the definite description is anaphorically linked to an antecedent. We propose to make such implicit anaphoric links explicit, as in (16). (16) A man a walked in. John 2 saw the man~. If we provide the right translation instruction for such anaphoric uses of the, we arrive at translation 63 (17). (17) Ovl : man(vl); walk-in(v1); vg~ := J;","/,'03 : (133 = 131; man(vs)); see(v2, v3). This gives the man~ the meaning: the unique man that is equal to vl, with v3 available for later reference to this individual. It seems to us that this gives the correct result, in the present case and in lots of other cases.","In the case of (18) we still run into trouble, however. (18) The man with the hat smiled. Here, the natural translation is (19).","(19) +vx : (man(v1); ,vz : hat(v2); is-of(v2, vl); smile(v1). This translation contains a definite assignment ev2 : hat(v2), so it seems to assume that there is a unique hat in the domain of discourse, which is perhaps a bit too strong. There are at least the following two ways out. One is by handwaving. Just remark that in descriptions like the man with the golden gun, the second definite article is not quite as definite as it looks, and the description is in fact idiomatic for the more strictly correct the man with a golden gun. The other escape is to add an epicycle to the analysis, in order to achieve that man 1 with1 the hat 2 translates into (20). (20) man(~)l); t~)2: (hat(I)2)\" ~ i8-0f(I;2,1)1) ). We provisionally opt for the first solution. 2.4 Semantics The standard DPL semantics maps input states to sets of possible output states. Let a model .A4 = (M, II, where M is the domain and I the interpretation function for a set of constants and relation symbols be Kiven. Then the set of states is the set of functions M v , and the standard semantics for DPL is given by a function [.]~ : M V --+ ~p(MV).","In order to capture the uniqueness presuppositions of definite descriptions, we replace the standard semantics by an error state semantics. In a Russellian account of definite descriptions, \"The king of France is bald\" when evaluated with respect to the state of affairs in 1905 or 1993 is false, for there is no unique referent for the description. But it is much more natural to follow Frege, Strawson and the majority of the linguistic community in assuming that statements in-volving \"the king of France\", when interpreted with respect to a state of affairs where there is no unique king of France, may be neither true nor false, because they suffer from presupposition failure.","We propose to use an error state semantics to take in account the failure of uniqueness presuppositions of t assignments. The error state semantics of DPL if given by a function","[.].~ : (M e t.J <r) -+- :P(M V 12 e). In the definition of this function, which follows, e refers to a special error state, A ranges over proper states, B ranges over states in general (including the error state), and A[x := d] is used for the proper state which is like A, except for the fact that z is mapped to d.","1. [xl.~l(e) = {c}","2. [Rta...tn].~(A)=","{A} if (V~,a(tl), .... V.~,a(tn)) E I(R)","0 otherwise.","3. [t~ = t2].~(A) ="]},{"title":"{A} if Vdbl,A('l)","paragraphs":["~-"]},{"title":"V.I~,A('2)","paragraphs":["0 otherwise. 4. [(~1; ~2)]~(a) =","s. [(~, ~ ~)|~(a) =","/ {~} if there is a state B E [a'l]~(A)","with[lr2]~(B) = {c} {A} if for all B e [~II~(A)","it holds that[a'2]~(B) {e)","otherwise.","6. [('~x]~a(A) = {e} if [a']~(A) = {e} {A} if [Tr],~(A) = $ O otherwise.","7. [,lx: ,~]~(A) = U{[-]~(A[z := d])ld e A4}. s. [,,x:.l~CA) =","{ [x]~(A[z := d]) for the unique d with","[x]~(A[z := d]) g {e}","if d exists","{e} otherwise.","More information on this definition can be found in","[2]. For present purposes it is sufficient to note that","a DPL program can execute in three different ways,","when acting on a given input state:","1. The program reports success by producing at least one proper output state. For example, the program man(vx) when acting on an input state where Vl refers to John will succeed and return the input state as its only output state.","2. The program reports failure by not producing any output at all. For example, the program rlvl : woman(v1) will fail for any input state (except e) if there are no women in the model under consideration (its output state set will be empty).","3. The program reports error by producing e as its only output. For example, the program ,.vl : manager(v1) will produce e for any input state if the model under consideration does not have a unique manager. 64"]},{"title":"3 Preconditions of DPL programs","paragraphs":["Above, we have referred to DPL formulas as programs. We are now going to use tools for programming language analysis on DPL. We will use quantified dynamic logic over DPL to describe the preconditions for success, failure and error of DPL programs. QDL terms t ::= c I v, qDLprograms lr ::= t = t ] Rt...t I Or; It) ] QDLformulas ~::=t--tIRt..-tl(~A~)l--~l Note that the QDL programs are precisely the DPL programs. An atomic relation Rtl, ..., tn can occur inside a QDL program or as an atomic QDL formula, so we need to distinguish the programs of QDL from the static QDL relations. We use boldface for the test program Rt~ ... tn and italics for the formula Rt t ...t~.","We omit outermost parentheses as usual, and use T for a formula which is always true, I for a formula which is always false.","The semantics of QDL is as for first order logic, with the following clauses for the program modalities added (assume A ~ e):","• A4 ~A (~')~ iff there is some B with B E [Tr]]~a(A), B ¢ e and .44 ~B 9.","• A4 ~A [lr]~ iff for all S e Iris(A) it holds that B # e and .44 ~ 9-Note that (~r) and [~r] are not duals. (~')T expresses the conditions for success of ~r, [~-].L the conditions for failure of z. It follows that ~(~r)T A --[~r].l_ expresses the conditions for error.","The following axiom schemata can be used to compute these conditions as formulas of FOL. 1. (Rt, ... t,,)~ ~ (ntt ...t, A ~). 2. [Rt, ...t,]to ~ (Rtt...tn -~ 9). ~. (t, = t,)~, ~ (t~ = t~ ̂9). 4. It, = t~]~, ~ (t~ = t~ --. 9)-"]},{"title":"6. [~, ;~:~]~ ~ [~,][~]~. 7. (-,~)~ ~ (~, ̂[~]±). 8. [-~-]~, ~ ((~)-r v (~, ̂[~-]±)).","paragraphs":["10. [~r, =~"]},{"title":"~r,]~ ~ (([~',]((~r,)T V [~r,]J_)) A ([~r,](~,)T --~ 9))-","paragraphs":["11. (n,,: ,r)~, ~. a~,(,,-)~,."]},{"title":"12. Nv: ~r]~# --Vv[vr]~. 14. [,,,: ~-]~, ~ (a!v(~-)T ̂V,,((~-)T","paragraphs":["--+ [~-]~)). The most interesting item of this list is the universal schema for t assignment (item 14). To see what it means, note that [~r]m expresses that all output states of ~r are proper. The schema states that the following are equivalent:","• For proper input state A, the program tv : lr","does only have proper output states, and all of","these satisfy ~a.","• For proper input state A there is precisely one","d E M for which 7r has a proper output on input","A[v :- d], and for all d' for which ~r has proper","outputs on A[v := d'], all outputs of lr on A[v :=","d'] are proper and satisfy 9. It is not very difficult to see that these are indeed equivalent, so the axiom schema is sound, as are the other axiom schemata.","The axiom schemata can be used to calculate the truth, falsity and error conditions of DPL programs as formulas of FOL. If we represent a first order model as a database, then evaluation of DPL in a model reduces to evaluation of first order formulas in the database.","An example will make clear how the axioms may be used to compute preconditions of DPL programs as FOL formulas. Consider example (21) with translation (22). (21) If a woman is married,","her husband looks after her. (22) (qx : Wx; Mx) =~ (~y: gyx; Lyx). Here is the derivation of the truth conditions.","((rlz : Wa~; Mz) =~ (ty: Hyz;"]},{"title":"Lyx))T","paragraphs":["4-~ [~x: Wx; Mx](~y : ttyx; Lyx)T ~-+ [rlx: Wx][Mz](*y :"]},{"title":"I'lyz)(Ly~)T","paragraphs":["~-* Vx[Wx][Mx](Ly :"]},{"title":"Hyx}(Lyx)T Vx(Wx ~","paragraphs":["(Mx -~"]},{"title":"(:JIy(I-Iy~c)-t- A By(I-Iyx)(Lyx)T)))","paragraphs":[",-, Vx(W2: .-* (Mx"]},{"title":"(3!yH~ ̂3y(Hy~ ̂Lye)))).","paragraphs":["To calculate the falsity conditions, we can use theorem (23), which is derivable from the axiom schemata: Applying theorem (23), we get the following falsity conditions for (22):","3x(Wx"]},{"title":"A","paragraphs":["Mx"]},{"title":"A","paragraphs":["3!yHyx A Vy(Hyx ~ -~Lyx)). Program (22) aborts with error if it doesn't succeed and doesn't fail. Modulo some FOL reasoning the conditions for this are given by (24): (24) 3x(Wx"]},{"title":"A","paragraphs":["Mx"]},{"title":"A","paragraphs":["-,d!yYyx). This means that in all models where married women do have unique husbands, program (22) will never abort with error. In other words, the calculus allows us to derive that the presupposition of the definite description has been cancelled by the implication. 65 4 The Implementation The parser The grammar for our fragment uses categorial feature unification, and the parser is based on standard techniques for such grammars. The syntax consists of a lexicon, which associates categories with lexical items, a category descriptor which gives definitions of complex categories in terms of simpler categories and some reduction rules.","Basic categories are S without features, and E with features for number, person, case,"]},{"title":"uindez","paragraphs":["for up index (= antecedent index) and"]},{"title":"dindex","paragraphs":["for down index (= anaphor index). Complex categories are built with / and \\ and the constraints on feature unification in the usual way. The index features"]},{"title":"uindez","paragraphs":["and"]},{"title":"dindez","paragraphs":["also occur on noun phrases and determin-","ers. Here are some examples of complex categories","(, marks the feature values that do not matter). • N(number) = S/E(number,*,*,*). • NP(number,person,case,uindex,dindex) = S/(E(number,person,case,uindex,dindex) kS). • VP(number,person,*) = E(number,person,Nom,*,*)\\S. • TV(number,person,tense) = VP(*,*,tense)/NP(*,*,Acc,*,*). • DET(number,uindex,dindex) = NP(number,Third,*,uindex,dindex)/ N(number). • AUX(number,person) - VP(number,person,Tensed)/ VP (number ,person ,In f). • NEG = AUX(number,person)\\AUX(number,person).","Basic categories get assigned in the lexicon. For ex-","ample: word Category John ~ NP(Sg,Third,*,i,*) hei NP(Sg,Third,Nom,*,i) himi NP(Sg,Third,Acc,*,i) sees TV(Sg,Third,Tensed) a i DET(Sg,i,*) the i DET(*,i,*) another~ DET(*,i~i) his} DET(*,ij) man N(Sg) with (N(nr)kN(nr))/NP(*,*,*,*,*) Some examples of complex category formation:","• a man;: DET(Sg,i,*). N(Sg) = NP(Sg,Third,*,i,*)/N(Sg). N(Sg) = NP(Sg,Third,*,i,*).","• sees a man*: TV(Sg, Third, Tensed) • NP(Sg,Whird,*,*,*) = (VP(Sg,Third,Tensed)/ NP(Sg,Third,Acc,*,*,*)) -NP(Sg,Third,*,*,*) = VP(Sg,Third,Tensed).","• John~ sees a mani: NP(Sg,Third,*j,*)- VP(Sg,Third,Tensed) - (S/(E(Sg,Third,* j,*)kS))- (E(Sg,Third,Nom,*,*)\\S) mS. The translator The translator uses A-calculus to translate parse trees into DPL programs• We could have translated on the fly, building translations while parsing, but the present set-up seemed preferable for reasons of modularity of design.","The translation algorithm makes use of a lexical function mapping pairs consisting of a lexical item with an associated category to A-expressions in the lexicon, along the lines of [9].","Translating a sentence into DPL boils down to lambda reduction of the lambda expression which results from combining the lambda expressions associated with the leaves of the parse tree, according to the rules of functional application dictated by the categorial structure.","Here are some examples of lambda expressions associated with lexical items with categories. Note that we assume the presence of indices in the lexicon, so we can handle anaphoric links by co-indexing.","For a proper understanding of the translation instructions one should bear in mind the distinction between DPL variables that are used for DPL assignment and lambda calculus variables. We use lower case for the first and upper case for the latter. Translation for man, N(Sg):"]},{"title":"AVl.m..(VI).","paragraphs":["Translation for"]},{"title":"John i,NP(Sg,Third,*,i,*): AVl.vi := J; Vi(v,).","paragraphs":["Translation for sees, TV(Sg,Third,Tensed):"]},{"title":"A VI.( A V2.(Vl A V3.see(V2,","paragraphs":["V3))). Translation for"]},{"title":"is,","paragraphs":["TV(Sg,Third,Tensed):"]},{"title":"A VI .( A V2.(Vl A Vs. V2 = v3)).","paragraphs":["Translation for"]},{"title":"a(n) i,","paragraphs":["Det(Sg,i,*):"]},{"title":"AV~.(AV2.(,lv, : VlO,,); V2(,,))).","paragraphs":["Translation for"]},{"title":"the i,","paragraphs":["Det(*,i,*):"]},{"title":"AVI.(AV~.(~,,,:","paragraphs":["V,(v,); V~(v,))). Translation for"]},{"title":"the~,","paragraphs":["Det(*,ij) (the anaphoric use of"]},{"title":"the): AVI.(AV2.~v, : (v, = vi; VlV,); v2(,,)).","paragraphs":["Translation for"]},{"title":"if,","paragraphs":["(S/S)/S:"]},{"title":"A VI ,( A V2. V, =~ v~ ).","paragraphs":["Translation for"]},{"title":"does,","paragraphs":["AUX(Sg,Third):"]},{"title":"AVI.V1.","paragraphs":["66 Translation for"]},{"title":"not,","paragraphs":["NEG:"]},{"title":"~ v~ . ( ~ v~ . -, ( v~ v~ ) ) .","paragraphs":["Translation for"]},{"title":"another,","paragraphs":["DET(Sg,i,j):"]},{"title":"~Vl.(~v~.(,~v~ : ,~ # v~; v](~); V~(vd)). Translation for the other, DET(*,i~): ~Vl.(~V~.(~,~ : (.~ # ~; V~(v~)); V~(~d)).","paragraphs":["Translation for he/, NP(Sg,Third,Nom,*,i):"]},{"title":"~v~.v,(~,).","paragraphs":["Translation for"]},{"title":"hisS,","paragraphs":["DET(*,ij):"]},{"title":"~v~.(~v~.,v~ : Vl(,d; iso/(,~, ~); V2(vd).","paragraphs":["Translation for with, (N(nr)\\N(nr))/NP(*,*,*,*,*):"]},{"title":"~ v~.( ~ v2.( ~ v~.( v~(v~); Vl ( ~ 1⁄4 ~of ( V~, v3)))).","paragraphs":["All these translations are typed, but we have left most of the typing discipline implicit. For example, the translations of noun phrases all are of the type of (dynamic) generalized quantifiers, which take a property to give a DPL program. The translation of proper names is a dynamic variation of the Montague treatment for proper names [8]. In extensional Montague grammar, proper names translate into expressions denoting the set of properties which are true of the named individual. Here, proper names translate into expressions that for every property give the DPL program which first assigns the name of the individual to the index variable of the proper name, and then tests for the property. This is like in Montague grammar, but with a dynamic touch added. Anaphoric links to the name remain possible by means of the index variable as long as its value remains unchanged.","Other noun phrases with a dynamic flavour are indefinite and definite descriptions. Indefinite descriptions translate into expressions that for every property give the DPL program which does an indefinite assignment to an index variable and tests for the property. Definite descriptions are handled likewise, but with definite assignment instead of indefinite assignment. (25)"]},{"title":"John x uses his pc~.","paragraphs":["As an example, we treat the translation of (25), which is obtained starting from the following parse tree: (S,"]},{"title":"(NP 1, John) , (yP, (TV, u~e~), (NP?, (DET~,his), (N, pc) )","paragraphs":["The translation step by step: his pc~ ~ AVI.()W~.tv2"]},{"title":": y~ (v2); i8-o/(v2, ,1); y2(,2))(~v~ .pc(V1))","paragraphs":["*-.-b"]},{"title":";w2.,v2 : pc(v2); is-of(v2, v0; v2(~2).","paragraphs":["uses his pc~ )~ V~ . ( )W2 . V, ( ), Vs . use ( V2 ,113 ) ) )"]},{"title":"(~v2.~v2 : pc(v2); i~-of(~2, v0; v2(v2))","paragraphs":[".--'4\""]},{"title":"~v2.(~v2.(~ : pc(~2); i~-of(v2, ~); V2(v2)) (aV3.use(V~, V,)) (AV~.tv2 : pc(v2); is-of(v~.,","paragraphs":["vl);"]},{"title":"(AVa.use(V2, Vs))(v2)) ~v2.,v2 : p~(v2); is-of(,2,,1); use(V2, ~2).","paragraphs":["John 1 uses his pc~"]},{"title":"(~Vl.v~ := J; (vdvl)) ~V2.,v2 : ~c(v~); i~.of(v~, v~); use(V2, v~)","paragraphs":[",.-+ v~ := J; (AVz .tv2:"]},{"title":"pc(v2); is-of(vg.,","paragraphs":["Vl);"]},{"title":"use(V~,","paragraphs":["vg.))(vl) ...4"]},{"title":"Vl := J; ~ : ~c(v~); is-of(~, ~1); use(~x, v~).","paragraphs":["In the same way, (26) gets translated into (27). (26)"]},{"title":"John 1 is a man ~.","paragraphs":["(27) vl := J; ~/v2 :"]},{"title":"man(v2); Vl = v2.","paragraphs":["Note that 'is' is treated as in Montague grammar [8]."]},{"title":"5 Experiences with the GSdel Implementation Language","paragraphs":["The declarative semantics of GSdel improves on the semantics of Prolog: extra-logical Predicates (such as"]},{"title":"vat, nonvar, assert, retract,","paragraphs":["! .... ) are avoided and sometimes replaced by declarative counterparts. Like Lambda Prolog [7], GSdel is a typed language: it is necessary to declare the type and domain of all functions and predicates (polymorphism is allowed, however). This convention makes program writing a bit more cumbersome, For example, we have to declare the type Program for representing a DPL program. For each DPL statement, it is necessary to define a function to build a Program (example: Piota : Variable * Program ~ Program). We also have to declare a type Expression for A-expressions. Some complications arise from the fact that an expression may contain a DPL program and vice versa. On the plus side, more errors are detected during compila-tion, the compiler generates more efficient code, and the typing discipline makes for more legible, comprehensible programs. Last but not least, the typing discipline has obliged us to think a bit more about the clauses we were writing than we perhaps would have done otherwise. 67 GSdel has facilities that permit elegant meta-programming. In Prolog the program and the meta-program are not independent: the predicates"]},{"title":"as-sert","paragraphs":["and"]},{"title":"retract","paragraphs":["modify the program itself in which these predicates occur. In GSdel, program and meta-program are completely independent. It is possible for a program to load another program, to modify this other program by inserting or retracting predicates, functions or types, and to demonstrate a goal. In our implementation we use these facilities to represent a model as a logic database and a precondition as a complex goal. 6 The Program Itself","The main module takes a sentence or text as input","and produces a report containing the sentence, the","parse tree, the DPL program it gets translated into,","and the preconditions. This module uses the follow-","ing submodules: • the parser module which from a sentence, finds","its category and builds its parse tree, • the translation module which from the parse","tree, computes a representation of a DPL pro-","gram, • the precondition module which from a DPL pro-","gram, derives the preconditions (this module","calls another module to simplify the resulting","FOL formulas), • the evaluation module which performs a","database evaluation.","A lexicon module is called by the first two of these","modules. It contains the words, with their categories","and the associated A-expressions. 6.1 Main module This module receives a sentence represented by a list of words and parses it, translates it, produces a report, computes preconditions and evaluates these in a given model. 6.2 Output This module defines how to output programs, expressions, categories, trees, words, ... It uses the facilities of GSdel for manipulating text files. 6.3 Lexicon The lexicon is defined by a predicate"]},{"title":"Diet","paragraphs":["with three arguments: the word itself, a category and an appropriate lambda expression. 6.4 Parser The parser employs backtracking and unification in the usual way. GSdel (as all logic programming languages) has these features built in, which makes it very easy to implement a parser for a simple fragment like ours. The parsing of a sentence consists of three steps:","* generate a list of categories corresponding to the sequence of words, • reduce the list of categories,","• test if you have a sentence else retrace your steps and try again. We use the type"]},{"title":"categor","paragraphs":["to represent categories. It is defined by the constant S and the functions"]},{"title":"E(nnmber, person, case, nindex, dindez), NP (number, person, case, uindex, dindex), N(number),","paragraphs":["and so on. The two infix functions / and \\ serve to build new and more complex categories. Sentences axe parsed by building a binary parse tree in bottom-up fashion. The binary parse trees are represented by a constant"]},{"title":"Empty","paragraphs":["and a function A."]},{"title":"Empty","paragraphs":["represents the empty tree and the function A gives the information at the current node, the left subtree, and the right subtree. The information content of the nodes is of two kinds: internal nodes carry the result of combining the categories of the subtrees and leaf nodes carry a pair consisting of a word and its category. The parse trees are built during the reduction of the list of categories, starting with a list of trees corresponding to the words of the sentence. When we reduce two adjacent categories, we replace the two corresponding trees T1, 7\"2 by a single tree with T1 and Tz as immediate subtrees. 6.5 Translator The translator uses two types:"]},{"title":"Program","paragraphs":["and"]},{"title":"Ezpression.","paragraphs":["The first represents a DPL-program, the second a complex A-expression. We have left the rest of the typing of the lambda expressions implicit. The definition of programs and lambda expressions is a bit cumbersome, for a A-expression may contain a program and vice versa. This complication is reflected in the rules for substitution and reduction. For example, it is necessary to define the substitution of an expression for a variable in a program, the free occurrence of a variable in a program, etc. The rules of reduction are a straightforward rendering of the rules of ~-reduction and 7-reduction in A calculus. We do not handle a reduction, as we see no need for variable renaming. The translation process employs the following predicates: Trad This predicate translates a parse tree into a reduced A-expression. Depending on the information at the current node of the parse tree, a lexical lookup of the translation takes place, or the translation is found by reducing the application of the translations of the left and right subtrees. Trans This predicate translates a list of parse trees for the sentences of a text into the corresponding 68 DPL program. It uses the predicate"]},{"title":"Trad","paragraphs":["to translate each sentence, and then links these translations by applications. Canted This predicates takes a h-expression and reduces it using the declarative functional semantics of h-calculus. 6.6 From DPL to QDL We have seen that DPL programs are represented as G6del functions. The reduction of DPL to FOL by means of QDL gets implemented by defining reduction predicates corresponding to the QDL axiom schemata. These predicates call each other recursively.","• Fa(Rei(s,v)) is a relational atomic test."]},{"title":"(at1...t.)","paragraphs":["• Fequal(tl, t2) is an atomic test of equality of","the terms tl and t2. (tl = t2) • Fand(phil, phi2) is the conjunction of two for-","mulls. (~1 A ta2) • For(phil, phi2) is the disjunction of two for-","mulls. (~1 V ta2) • Fimplie(phl,phi2)is the implication of two","formulas. (ill --* ta2) • Fall(V(i), phi) is the expression (Vvi~) • Fexist(V(i), phi) is the expression"]},{"title":"(3vita)","paragraphs":["• Fonlyone(V(1), phi) is the expression (q!vi~) • Fnot(phi) is the negation of the formula ta.","• Fpreeexist(pi, phi)is the expression ((~r)ta)","• Fprecuniv(pi, phi)is the expression ([~r]ia)","• Fpar(pi, phi) is the expression (-~(Tr)taA-~[Tr]~). In the course of applying these predicates, formulas may get generated with obvious redundancies. We have defined a formula simplifier to remove some of these. This improves the readability of the output (the formulas are output in LaTeX format) and the performance of the database lookup on the basis of the conditions. There is the list of simplifications handled by the module"]},{"title":"Simple. • ~# A T +-~ ~#","paragraphs":["• ~# A.L +-+ J- • ~VT~T • ~ V-L ~-~ ~ • (~T)~T • (T*- • (_I_ *- ~) ~-~ T • -~T ~ _L • (3!v~ A =Ivy,) ~ :l!v~. 6.7 Evaluation The intermediate language QDL allows us to translate DPL programs into formulas of FOL. These are then evaluated in a database model, i.e., a first order model which is implemented as a G6del database (a G6del program). There we have a so-cMled meta-module"]},{"title":"Evaluation","paragraphs":["and an object program"]},{"title":"Logic Database,","paragraphs":["and the meta-program manipulates the object program. We translate first order conditions into G6del goals, and then apply the goal to the object G6del program, using the possibilities of meta-programming offered by G6del. In ordinary Prolog, these things could also be done, but they would look much less elegant. Here is an example of a Gfdel model (the lines preceded by % are comment lines): MODULE Model1. IMPORT Strings, Sets. BASE Symbol. % We use this base for every kind of term. CONSTANT John, Bill, Freddy, Borsalino, Myclone: Symbol. PROPOSITION Top. PREDICATE Admire, Cheer, Isof, See, Use : Symbol * Symbol; tilt, Man, Adult, King, Pc, Manager : Symbol. % The relations defined in the model Admire(John,Bill). King(Bill). Isof(Borsalino,Bill). ttat(Borsalino). See(John,Bill). See(Bill,John). Manager(Bill). Man(John). Man(Bill). Man(Freddy). Adult(John). Adult(Bill). Pc(Myelone). Use(John,Myclone). Top. % Top must be defined in every model. 69 7 Conclusion The QDL translation discussed above only handles uniqueness presuppositions of definite descriptions. The method employed is general enough, however, to handle lots of other kinds of presupposition. Lexteal presuppositions, for example, are handled in the error state semantics by a slight revision of the semantic clause for atomic tests. Being a bachelor presupposes being male and adult, so the test for bachelorhood should give error if it is performed on an entity that does not satisfy the test for being a male adult. Formally, the revision boils down to this. Let At be the set of atomic formulae of DPL. Assume a lexicat presupposition function lp :"]},{"title":"At ~ DPL","paragraphs":["mapping each atomic test predicate of the representation language to its associated lexical presupposition, conceived as a program of the representation language. For example, here are the lexical presuppositions for bachelorhood."]},{"title":"lp(bachelor x) = (male x; adult x).","paragraphs":["The semantic clause for atomic relations is modified to take the function lp into account: 2'. [R(tx.-.~.)]~(A) =","{A} if"]},{"title":"~lp(Rtl...t,)]~(A) q~","paragraphs":["{e} and A4 ~A"]},{"title":"Rta ...tn, 0","paragraphs":["if [lp(Rtl-.."]},{"title":"t,)]~(A) 9~","paragraphs":["{'} and"]},{"title":".~4 ~A Rta ...t,~,","paragraphs":["{,} if ~lp(Rtl-..t,)]~(A) C_ {,}. This modified definition gives the success and failure of the relational test modulo the fact that the lexical presupposition of the relational test holds; if the presupposition does not hold then the test results in error. There is no need for any other changes in the rules, for the projection of lexical presupposition is taken care of by the general principles of error percola-tion that are already implicit in the semantic clauses. Thus, the DPL error semantics gives us that (28) presupposes that Jan is male and adult, but that (29) only presupposes that Jan is adult. (28)"]},{"title":"Jan is a bachelor.","paragraphs":["(29)"]},{"title":"If Jan 1 is male, then hel is a bachelor.","paragraphs":["The change in the semantic clause for atomic relations is reflected in the calculus by replacing the schemata for"]},{"title":"Rtl ...tn","paragraphs":["by the following versions: 1. (Rtl...tn)~a ~-+"]},{"title":"(Rtl...","paragraphs":["t,, A (p A (lp(Rt~ • • • tn))r).","2. [Rtl...tn]~ *-+ ( Rtl . . . t. --+ ~) ̂(lp(m~ .. • tn))r). In the implementation, lexical presupposition is handled by a predicate"]},{"title":"Lp","paragraphs":["and a modification of the reduction predicates for the relational test axiom schemata. Right now, we are extending the fragment to deal with other kinds of presupposition failure, in particular failure of presupposition of aspectual verbs such"]},{"title":"as start","paragraphs":["and"]},{"title":"stop.","paragraphs":["References","[1] J. Barwise. Noun phrases, generalized quantitiers and anaphora. In P. G~rdenfors, editor,"]},{"title":"Generalized Quantifiers: linguistic and logical approaches,","paragraphs":["pages 1-30. D. Reidel Publishing Company, Dordrecht, 1987.","[2] J. van Eijck. The dynamics of description."]},{"title":"Journal of Semantics,","paragraphs":["10, 1993. to appear.","[3] J. van Eijck. Presupposition failure -- a comedy of errors. Manuscript, CWI, Amsterdam, 1993.","[4] J. van Eijck and F.J. de Vries. Dynamic interpretation and Hoare deduction."]},{"title":"Journal of Logic, Language, and Information,","paragraphs":["1:1-44, 1992.","[5] J. Groenendijk and M. Stokhof. Dynamic predicate logic."]},{"title":"Linguistics and Philosophy,","paragraphs":["14:39-100, 1991.","[6] P.M. Hill and J.W. Lloyd. The GSdel report. Technical report, Department of Computer Science, University of Bristol, Bristol, 1991 (revised 1992).","[7] D.A. Miller. A logic programming language with lambda abstraction, function variables and simple unification. In P. Schroeder-Heister, editor,"]},{"title":"Eztensions of Logic Programming.","paragraphs":["Springer, 1990.","[8] R. Montague. The proper treatment of quantification in ordinary english. In J. Hintikka e.a., editor,"]},{"title":"Approaches to Natural Language,","paragraphs":["pages 221-242. Reidel, 1973.","[9] R. Muskens. Anaphora and the logic of change. In J. van Eijck, editor,"]},{"title":"Logics in AI / European Workshop JELIA '90 / Amsterdam, The Netherlands, September 1990 / Proceedings,","paragraphs":["Lecture Notes in Artificial Intelligence 478, pages 412-427. Springer Verlag, 1991.","[10] R. Muskens. Tense and the logic of change. Manuscript, University of Tilburg, 1992.","[11] V. Pratt. Semantical considerations on Floyd-Honre logic."]},{"title":"Proceedings 17th IEEE Symposium on Foundations of Computer Science,","paragraphs":["pages"]},{"title":"109-121,","paragraphs":["1976. 70"]}]}