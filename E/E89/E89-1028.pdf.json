{"sections":[{"title":"","paragraphs":["COMPUTATIONAL SEMANTICS OF MASS TERMS Jan Tore l..¢nning","Department of Mathematics University of Oslo P.O. Box 1053, Blindern 0316 Oslo 3, Norway ABSTRACT Although the formalisms normally used for describ-ing the semantics of natural languages are far from computationally tractable, it is possible to isolate particular semantic phenomena and interpret them within simpler formal systems. Quantified mass noun phrases is one such part. We describe a simple formal system suitable for the interpretation of quantified mass noun phrases. The main issue of this paper is to develop an algorithm for deciding the validity of sentences in the formal system and hence for deciding the validity of natural language inferences where all the involved noun phrases are quantified mass noun phrases. The decision procedure is based on a tableau calculus. INTRODUCTION A formal semantics for a part of a natural language attempts to describe the truth conditions for sentences, or propositions expressed by sentences, in model theoretic terms, and thereby also the relation of valid inferences between sentences. From the point of view of computational linguistics and natural language understanding, it is important whether this relation of entailment can be made computational. In general, the question must be answered in the negative. All proposed formal semantics of, say, English are at least as complex as first order logic and hence at best semi-decidable, which means that if a sentence 13 is a logical consequence of a set of sentences Y., then there exists a proof for [3 from ~, but no effective way to find such a proof. Several proposals use even more complex logics, like the higher order intensional logic used in Montague grammar, which has no deductive theory at all.","We will not oppose to the view that English incorporates at least the power of first order logic and that even more complex formalisms may be needed to represent the meaning of all aspects of English. But we believe there are two different possible strategies when one is to study one particular semantic phenomenon in natural languages. The first one is to try to interpret the particular phenomenon into a system that attempts to capture all semantic aspects of the natural language. The other slrategy is to try to isolate the particular semantic phenomenon one wants to study and to build a semantic interpretation suited for this particular phenomenon. By following the latter strategy it might be possible to find systems simpler than even first order logic that reflect interesting semantic phenomena, and in particular to come up with systems that are computationally tractable.","Quantified mass noun phrases is one such phenomenon that can be easily isolated. The properties particular for the semantics of quantified mass terms have been difficult to capture in extensions of systems already developed for count terms, like first order logic. However, if one isolate the mass terms and tries to interpret only them, it is possible to build a model where their typical properties fall out naturally. We have earlier proposed such a system and shown it to have a decidable logic (L0nning, 1987). We repeat the key points in the two following sections. The main point of this paper is a description of an algorithm for deciding validity of sentences and inferences involving quantified mass terms.","The strategy of isolating parts of a natural language and giving it a semantics that can be computational is of course the strategy underlying all computational uses of semantics. For example, in queries towards data bases one disregards all truly quantified sentences, and use only atomic sentences and pseudo quantified sentences where e.g. for all means for all individuals represented in the data base. The system we present here contains genuine quantifiers like all water and much water, but contain other restrictions compared to full first order logic. In particular the mass quantifiers behave simpler with respect to scope phenomena than count quantifiers. REPRESENTING QUANTIFIED MASS NOUNS We will make use of a very simple formal language for representing sentences containing quantified mass nouns, called LM (Lcnning, 1987). We refer to the original paper for motivation of the particular chosen format and more examples and repeat only the key points here.","1. A particular LM language consists of a (nonempty) set of basic terms, say: water, gold, - 205 - blue, hot, boil, disappear .... and a (possibly empty) set of non-logical determiners, say\" much, little, less..than two kilos_of..","2. Common to all LM languages are the unary operator: -, the binary operator:., the logical determiners: : all, some, and the propositional connectives: : --1, ,̂ v, --~. 3. A term is either basic or of one of the two forms (t.s) and (--t) if t and s are terms. 4. An atomic formula has the form D(t)(s) where D is a determiner and t and s are terms.","5. More complex formulas are built by the propositional connectives in the usual way.","A model for the particular language is a pair consisting of a Boolean algebra A = <A, +, *, -, 0, 1> and an interpretation function [ ], such that 1. [t] is a member of A for all basic terms t,","2. [/9] is a set of pairs of members of A for all determiners D.","The interpretation of more complex expressions is then defined as an extension of [ ]:","1. [-t]= -[t], the Boolean complement of [t], [t.s]=[t]*[s], the Boolean product (or meet) of"]},{"title":"It] and Is].","paragraphs":["2. [D(t)(s)] is true provided ([t],[s])~ [D], in particular [All(t)(s)] is true provided [t]_<[s], and [Some(t)(s)] is true provided [t]*[s] ~ 0. 3. The propositional part is classical.","To get an intuition of how the semantics work one can think of [water] as the totality of water in the world or in the more limited situation one considers, of [blue] as the totality of stuff that is blue and of [disappear] as the totality of stuff that disappeared. However, one shall not take this picture too literally since the model works as well for abstract as for concrete mass nouns.","In the formalism, a sentence like (la) is represented as (lb) and (2a) is represented as (2b) if the negation is read with narrow scope and as (2c) if the negation is read with wide scope. (1) (a) All hot water is water.","(b) All(hot, water)(water) (2) (a) Much of the water that disappeared was","not polluted.","Co) Much(water.disappeared)(-polluted)","(c) ~ Much(water,disappeared)(polluted)","Formula (lb) is a valid LM formula. In general, the","valid English inferences that become valid if a mass","term like water is interpreted as quantities of water and all water is read as all quantities of water are also valid under the LM interpretation.","In addition, this approach can explain several phenomena that are not easily explained on other approaches. Roeper (1983) pointed out that paraphrasing water as quantities of water was problematic when propositional connectives were considered. If some water disappeared and some did not disappear, there will be many quantities that partly disappeared and partly did not disappear. If disappear denotes the set of all quantities that wholly disappeared and did not disappear denotes the complement set of this set, then all quantities that partly disappeared will be members of the denotation of did not disappear. The sum of quantities that are members of the denotation of d/d not disappear will equal all the water there is. Roeper solved this problem by letting the quantities be members of a Boolean algebra and used a non-standard interpretation of the negation. In LM it naturally comes out by the Boolean complement as in (2b) and water that did not disappear is represented by (water.(--disappear)).","A main feature of the current proposal is that it introduces non-logical quantitiers co-occurring with mass nouns, like much, little, most .... in a straightforward way. A sentence like much water was blue does not say anything about the number of quantities of blue water, but says something about the totality of blue water, which is the way it is interpreted in LM.","It might seem a little like cheating that the system only introduces interpretations of mass quantitiers with minimal scope with respect to other quanriflers, that it is not possible to interpret one quantitier with scope over another quantifier. In particular, since this is a main reason to why the logic in the sequel becomes simple. However, it is characteristic for mass quantifiers that they get narrow scope.","(3) (a) A boy ate many pizzas. (b) A girl drank much water. While it might be possible to get a reading of (3a) which involves more than one boy, i.e., one boy for each pizza, it is not possible to get a reading of (3b) involving more than one girl.","The only determiners that get a fixed, or logical interpretation in LM are : all and some. For the other determiners we can add various sorts of constraints on the interpretations that will make more of the inferences we make in English valid in the logic. For example, it has been claimed that all natural language determiners are conservative (or \"live on\" their fast argumen0, i.e: (a,b)¢ [D] if and only if (a,b*a)~ [/9] (Barwise and Cooper, 1981).","Several determiners are monotone, either increasing or decreasing, in one or both arguments, e.g., much is monotone increasing in its - 206 - second argument: if (a,b) ~ [much] and b < c then (a,c) e [much], and less than_two_kilos_of is monotone decreasing in-its second argument. Whether an inference like","Much water evaporated.","All that evaporated disappeared.","• \" Hence much water disappeared,","becomes valid in the logic, will depend on whether","the denotation of much is constrained to be mono-","tone increasing in its second argument or not. LOGICAL PROPERTIES We will repeat shortly several of the properties of the logic LM shown in (LCnning, 1987) as a background for the decision algorithm for validity.","A Hilbert style axiomatization was given and it was shown that any set of LM sentences consistent in the logic has a model: the logic is complete and compact.","It was implicitly shown, but not stated, that any model for LM must be a Boolean algebra: let a model be any set A with one unary operation [-], one binary operation [-], and a binary relation JAil] then the model is a Boolean algebra with [-] the Boolean complement, [.] the Boolean product (meet) operation and JAil] the ordering < on A.","It was also shown that the logic was complete and compact with respect to the smaller model class: the atomic Boolean algebras, i.e. any consistent set of sentences has a model which is an atomic algebra, and in fact a finite such.","From this, it was shown that LM with no non-logical determiners, let us call it LA, is equivalent to a subset of monadic first-order logic, hence it is decidable. It was also shown that the full LM is decidable. The argument is based on the fact that the number of possible models for a sentence is finite and decidable. This number grows rapidly, however. Already a sentence in LA with n different basic terms have 2(2n) different models, so the argument does not establish a good procedure for checking validity in practice. We will establish procedures that are better (in most cases) in the next section.","Several natural restrictions on determiners, like conservativity and monotonicity can be expressed completely in LM. It is not surprising that this can be done for a fixed LM language given the finiteness of its nature. The more important point is that the properties can be expressed in a uniform way independently of the atomic terms of the language, which in next section will give rise to uniform inference rules. A DECISION PROCEDURE We shall establish a procedure for deciding the validity of LM sentences. The procedure is a combina-tion of a normal form procedure and a tableau procedure (see e.g. Smullyan, 1968).","We start with an LM formula 9 for which we want to decide whether it is valid, ~. 9. This is equivalent to deciding whether ~tp is satisfiable. One can think of the process as an attempt on building a model for ~9. If we succeed, we have shown that tp is not valid and we have found an explicit counterexample; if we fail, we have shown that tp is valid. We assume all propositional connectives in 9 to be basic: 9, ,̂ v.","1. First we introduce a new unary quantifier Null such that Null(t) is a formula when t is a term. The meaning is that [Null(t)] is true ff and only if [t]=0. Then substitute Null(t.(-s)) for All(t)(s) Null(t.s) for ~ Some(t)(s) ~Null(t.s) for Some(t)(s) This step is not necessary, but it gives a more convenient notation to work with and fewer instances to consider in the sequel. The substitutions correspond to the fact that Some and Every can be taken to be unary and the one can be defined from the other, as in the case with count nouns.","2. Then transform $ to conjunctive normal form, that is, a conjunction of disjunctions of literals, where a literal is an atomic or negated atomic formula. 3. Observe that (i) and (ii) are equivalent. (i) P ~lV̂2.̂..~̂n"]},{"title":"(ii) N~I, NV2...andNVn,","paragraphs":["Hence we can proceed with each conjunct separately.","4. We shall now check P ~lVXlt2v...VVn, where each Vi has the form Null(t), --Wull(t), D(t)(s) or -d)(t)(s). Observe that the following two formulas are equivalent, where t+s is shorthand for"]},{"title":"-((-t).(-s)).","paragraphs":["(i) ~ Null(t) v ~ Null(s) (ii) ~ Null(t+s) (This corresponds to the equivalence between 3xtp v 3xV and 3x(9 v ~) in first order logic.) Hence contract all the literals of the form --Wull(t) to one. 5. We are then left with a formula of the form","-.-aVull(t)vNull(sl)v... vNull(srOvaF l V... VVm, where each ~Fi has the form D(u)(v) or --4)(u)(v), for some non-logical D. First assume that there are no ~i's. Then observe that (i) and (ii) are equivalent. - 207 - (i) 1= ~ Null(t) v Null(sl) v...v Null(slO","(ii) h ---3lull(t) v Null(sl) or... or","h ~ Null(t) v Null(sn). (If there are no si's proceed with h ~ Null(t).) This equivalence might need some argument. That (ii) entails (i) is propositional logic. For the other way around, there are two possibilites. Either h--31ull(t), which yields the equivalence. Otherwise, there exists a model A for the language of d~ where [t]=0 and for all other terms s in the language: Is]=0 if and only if All(s)(t) is a valid formula. Let V be the formula ~Null(t) v Null(sl) v ... v Null(sn). Then ~ is valid if and only if ~ is true in A. To show this, it is sufficient to show that if there is a model B in which q/is not true then W is not true in A. If B is a model in which W is not true, then It]=0 and each [si]~0 in B. Hence All(sO(t) cannot be valid and [si]*:O in A for each si. Since [t]=0 in A, ~ cannot be true in A. The same type of argument yields that --,Vull(t) v Null(sO is valid if and only if it is true in A. If we write A h 11 for ~1 is true in A, the following equivalence is propositional logic and yields the equivalence above.","(i) A h ~ Null(t) v Null(sl) v...v Null(sn)","(ii) A h --1 Null(t) v Null(sl) or... or","A h --, Null(t) v Null(sn).","6. a. We shall describe two different ways for checking h ---dVull(t) v Null(sO. The first one proceeds by a transformation to normal form and may be the easiest one to understand if one is not accustomed to tableau calculus. The second one which uses a tableau approach is more efficient. First observe that (i) and (ii) are equivalent. (i) h ~ Null(t) v Null(sO","Oi) h Null((-t),si), (i.e. h All(sO(t)). The last claim entails the first one since Null((-t)*si) ~ -3lull(t)vNull(si) is a valid LM-formula. To see that (ii) entails (i) observe that if --dVull(t)vNull(si) is valid, it will in particular be true in the model A described in step 5, hence h All(sO(t).","To check hNull ((-t).si) rewrite the term (-t)°si in disjunctive normal form: allow the symbol + and write the term on the form Sl+...+Sm where each si has the form Ul°....Uk and each uj is either an atomic term or on the form -v for an atomic term v. Then h Null(sl+...+Sm) if and only if h Null(sl) and ... and hNull(sm), and hNull(ul.....Uk) if and only if there is a v such that one uj equals v and another uj equals -v.","b. The checking of h ~Null(t)vNull(si) will be faster using a tableau procedure instead of rewriting to normal form. Note that the following are equivalent:"]},{"title":"h","paragraphs":["--1 Null(t) v Null(sO","h NuU((-t).sO '~","h --i Null(t+(-si))","There is a close connection between propositional logic and Boolean algebras. To each term in LM, t, there corresponds a formula Pt in pure propositional logic such that --~Vull(t) is valid in LM if and only if the corresponding formula Pt is a tautology: shift each basic LM term t with a corresponding propositional constant Pt, and exchange - with --i, * with ,̂ and + with v. In particular, the following are equivalent: h --~lull(t+(-si)) (in LM) h (Pt v(-~Psi)) (in propositional logic)","(By the earlier mentioned connection between LM and first order logic this corresponds to the fact that a first order formula 3xq~ is valid if and only if ¢p is a tautology whenever q~ is quantifier free.)","Step (6a) above is equivalent to checking this latter formula for validity by transformation to a normal form. Instead it can be checked by a standard tableau procedure (see e.g. Smullyan 1968).","We give a short description of the tableau approach to propositional logic. In order to verify a formula V, we try to build a model that falsifies it. To ease the description we assume that V is on negation normal form, that is, built up from literals by ,̂ v. The attempt to build a model is done by building a tree for V. We start with a root node depicted by V and use the following two rules:","1. For each node a depicted by a formula of the form y v TI attach to each leaf below a in the tree constructed so far one successor node b depicted by y and one successor node c to b depicted by rl.","2. For each node a depicted by a formula of the form T ̂rl attach to each leaf below a in the tree constructed so far two new leaf nodes one depicted by T and another one depicted by rl.","The tree is complete when all formulas of the forms y v 11 and \"/̂11 are reduced according to the rules above. A branch in a tree is called closed if there is a formula T such that one node along the branch is depicted by T and another node along the branch is depicted by --,7. A branch in a complete tree for V which is not closed describes a valuation that falsifies V. Conversely, if all branches in a complete tree for V are closed, W is valid. We illustrate with an example: - 208 - ~pv (-~ qA (p V -'1 r))v (r A q~"]},{"title":"I ~qA (pv~ 1\")","paragraphs":["(r/q) ~q pv--,r"]},{"title":"/\\ I","paragraphs":["r q p"]},{"title":"I I # #","paragraphs":["The sign # indicates that a branch is closed. We have not completed the rightmost branch since it is already closed. Since there is one open branch in the tree, the formula is not valid. The literals along the open branch: ~p, ~q, r shows that any valuation V such that V(p) = T, V(q) = T, V(r) = .L, falsifies V.","The strategy in step (6a) above with transformation to normal form corresponds to construction of separate copies for each branch, hence duplicating parts of the tree, while the tableau procedure exploits the possibility of structure sharing.","Returning to our main point, we can observe one additional gain by using the tableau approach. Our goal is to check whether t\""]},{"title":"--Wull(t)vNull(sl)","paragraphs":["or .... or P-"]},{"title":"---~ull(t)vNull(sn),","paragraphs":["which is equivalent to check whether (tv(~sl)) or .... or (tv(~sn)) is a tautology. The part of the tableau tree that corresponds to t can be constructed (and if possible reduced by removing closed branches) once and for all, and then be reused with all the different si's.","7. We now return to step 5 and consider the case where one or more disjuncts have the form"]},{"title":"D(u)(v)","paragraphs":["or"]},{"title":"---~(u)(v),","paragraphs":["for some non-logical D. Then the following are equivalent. (i) b"]},{"title":"--~Null(t)vNull(sl)v...vNull(sn)WlV...V~m","paragraphs":["(ii)~-"]},{"title":"-Wull(t)vNull(si)","paragraphs":["for some si, 1 < i _< n, or"]},{"title":"--~Vull(t)VVkWj","paragraphs":["for some k andj between 1 and m, where Vk lias the form"]},{"title":"D(a)(b)","paragraphs":["and Vj has the form"]},{"title":"---D(u)(v)","paragraphs":["for the same determin6r D. That (ii) entails (i) is immediate. For the other way around, suppose that (ii) does not hold. We shall then construct a model which falsifies the original formula in (i). Let A be the model where only terms provably less than t denote 0 and where a pair ([d],[e]) is a member of [/9] if and only if --~D(d)(e) is one of the disjuncts Vi's. By the construction, A will falsify"]},{"title":"--,Null(t)","paragraphs":["and each disjunct of the form"]},{"title":"---~(d)(e).","paragraphs":["As in step 5 above, A will falsify each"]},{"title":"Null(si).","paragraphs":["It remains to show that A falsifies each disjunct of the form"]},{"title":"D(a)(b).","paragraphs":["Let ~/be one such disjunct, let rlj, 1 < j < s, be all the disjuncts of the form --dg(d)(e) with the same determiner D as in ~/ and let ej be"]},{"title":"---aVull(t)v'l, vTIj\"","paragraphs":["Since (ii) does not hold, theie exists a model B] where ej is false, for each e\" Then there also exists a model A\" which J\" . .J equals A except possibly for the interpretaUon of D, and where D gets the same interpretation as in Bj. Hence ej is false in A'j. Since there, exists such an Aj for each ej, ~/cannot be true m A. 8. Whether b"]},{"title":"-WuU(t)vD(a)(b)v--43(u)(v)","paragraphs":["holds, depends on which restrictions are put on D. With no restrictions, any possible counterexample is one where [t]=0, ([u],[v])~ [D] while ([a],[b])~ [D] . The only reason we should not be able to construct such a model is that [a] =[u] and[b] =Iv] whenever It] --0. We can hence proceed to check I ~ --,Nutl(0 v"]},{"title":"(Nult((-a.u)+(a.-u) ) A Nult((--b'v)+(b'-v) )),","paragraphs":["according to the same procedures as in step 6 above.","If we have the additional constraint that the determiner in question is conservative, the last rule is changed such that the last conjunct, which above stated that the symmetric difference between b and v was zero, now instead states that the symmetric difference between"]},{"title":"a.b and u.v","paragraphs":["is zero."]},{"title":".--~ull(t) v (Null((--a.u)+(a.-u)) A Nutt( (-(a.b).v)+( (a.b).-v) ) )","paragraphs":["Similarly, if we know that the determiner is up-wards monotone in its second argument"]},{"title":"D(a)(b)v---D(u)(v)","paragraphs":["has to be true in any model where"]},{"title":"[al=[u]","paragraphs":["and [v]__,[b], so the last conjunct will be"]},{"title":"Null((-b.v))","paragraphs":["instead of"]},{"title":"Null((-b.v)+(b.-v)).","paragraphs":["If the determiner is restricted to be both conservative and monotone, the last conjunct shall be"]},{"title":"Null((-(a.b).u.v)).","paragraphs":["Similar modifications of the rule can be done for determiners with other forms of monotone behaviour. GENERALIZED QUANTIFIERS One main feature of the decision procedure is that it incorporates generalized quantifiers (step 7 and 8). The rules for generalized quantifiers correspond to axioms one will use in an axiomatization of LM. For example, the rule for quantifiers with no additional constraints correspond to the extensionality schemata: For all terms a, b, u, v:"]},{"title":"(All(a)(u) ̂All(u)(a)) ~ (D(a)(b) ~ D(u)(b)) (All(b)(v) ̂All(v)(b)) --~ (O(a)(b) ~ O(a)(v))","paragraphs":["One should remember that we do not try to develop a logic for the strong logical interpretation of determiners like"]},{"title":"most,","paragraphs":["but a logic for some minimal constraints that interpretations of the determiners should at least satisfy. - 209 -","Just like there is a meaning preserving translation from LA into first order logic, LM can be translated into first order logic extended with generalized quantiflers. A proof procedure for first order logic, like a tableau or a sequent calculus, can be extended with rules for generalized quantifiers similar to the rules introduced here. If Q is a binary quantifier with no additional constraints on its interpretation then the following are equivalent.","O) b Qx(A(x),B(x)) v ~Qx(C(x),D(x))","(ii) ~. Vx(A(x) ~ C(x)) ̂Vxf~(x) ~ D(x)) So to show that (i) is valid one has to show that (ii) is valid. This can be incorporated into a tableau or sequent calculus for In'st order logic. If the first order logic is monadlc, as the logic we get after translating LM into first order logic is, one can use a similar procedure as the one described here. If the extended first order logic is not monadie, the procedure one gets when rules corresponding to the reduc-tion from (i) to (ii) are included, becomes more complex. EFFICIENCY","We chose to transform the formula being tested to normal form early in the procedure (step 2). Alternatively to the described algorithm one could think of using a tableau procedure all the way, and not first transform to conjunctive normal form in step 2. In general, transformation to normal form is slower than using a tableau procedure (el. step 6 above). The reason we made the transformation to normal form was that this was necessary to split the formula in step 5 and step 7. In the procedure one gets by translating LM into first order logic (with generalized quantifiers) and using a tableau procedure from the start, it is not possible to split the tree similarly. If we for simplicity considers a formula with no generalized quantifiers, the pure tableau calculus will not lead to a separate tree for each si to-gether with t but to one big tree containing all the si's and roughly one copy of t for each si. This corresponds to the quantifier rules in a tableau calculus for first order logic: (i) for each formula of the form Vxqb introduce one new formula dd(a) where a is some new term, (ii) for each formula 3xw introduce one new formula V(a) for each term a introduced in the tree at a branch to which 3x~ belongs. The successful separation in the described algorithm here will also be possible in a proof procedure for monadic first order logic.","The two different procedures will be of the same time complexity in worst cases. In the practical applications we have in mind, the procedure described here will be faster. Typically we want to check whether a formula 13 follows from al ..... a n. This is the same as deciding whether ~tlV...V~nVl3 is valid or not. The transformation to normal form will produce one additional copy for each v within an ai and each ̂within 13. If each ai and [3 are LM formulas that represent English sentences, they can each be expected to be relatively short and in particular not contain many v's, so the number of copies made will be relatively small. On the other hand, the number of ai's may be large if they represent the dialogue so far or the agent's knowledge. It is therefore important that each disjunct can be split up as much as possible. IMPLEMENTATION The inference algorithm has been implemented in PROLOG. To test it out we have built a small (toy) natural language question-answering-system around it. The program reads in simple sentences and questions from the terminal and answers the questions. It can handle simple statements, like If some of the hot coffee that did not disappear was black then much gold is valuable (the fragment in Lenning 1987) and yes/no questions like Did much water evaporate? and Was the old gold that disappeared valuable? We have written the grammar and translation to LM in the built in DCG rules (Pereira and Warren, 1980).","Statements typed on the terminal are interpreted as facts about the world and stored as simple sentences ~bl ..... qb n. When a question like Did much water evaporate? is asked, it is parsed and turned into a formula like V: Much(water)(evaporate). Then the program proceeds to check the validity of (Ol.̂..Ôn) --) V- If it is valid, the program answers yes, otherwise it checks (ddl.̂..0̂n) ---) ~V. If this is valid, the answer is no, otherwise the program answers that it does not know. When a state-ment is made the program checks whether it is consistent with what the program already knows before it is added to the knowledgebase.","The system is mainly made to test the inference algorithm and is not meant as an application by it-self. But it illustrates some general points. It is a system where natural language inferences are made from natural language sentences and not from a fixed database. The system contains a complete treatment of propositional logic and illustrates a sound treatment of negation where failure is treated as does not know instead of negation. On the other hand, there is also a price to pay for incorporating full propositional logic. The system can only handle examples of a limited size in reasonable time. CONCLUSION We have here presented a computational approach to the semantics of quantified mass noun phrases. We think the semantics ascribed to quantified mass - 210nouns through a translation into LM is the one that most adequately reflects their particular semantic properties. In addition this semantics can be made computational in a way not possible for other approaches to the semantics of mass terms, like Bum's (1985) which extends axiomatic set theory, or Link's approach (1983) based on Montague's higher-order intensional logic.","We have modified and adapted a tableau calculus to be used with mass terms and extended it with generalized quantifiers. Although the implementation we have made is of limited applicability, we hope that the algorithm can be used to incorporate quantified mass noun phrases into larger systems treating count terms. In particular, it should be possible to combine the algorithm with other approaches based on a tableau calculus, like the one described by Guenthner, Lehmann and SchOnfeld (1986). REFERENCES","Barwise, J. and R. Cooper: 1981, 'Generalized Quantifiers and Natural Language\","]},{"title":"Linguistics and Philosophy,","paragraphs":["4, 159-219. Bunt, H.: 1985,"]},{"title":"Mass terms and model-theoretic semantics,","paragraphs":["Cambridge University Press, Cambridge.","Guenthner, F., H. Lehmann and W. SchOnfeld: 1986,'A theory for the representation of knowledge',"]},{"title":"IBM J. Res. Develop.","paragraphs":["30, 39-56.","Link, G.: 1983,'The Logical Analysis of Plurals and Mass terms: A Lattice-Theoretical Approach', in Bauerle et al. (eds.),"]},{"title":"Meaning, Use, and In-terpretation of Language,","paragraphs":["Walter de Gruyter, Berlin.","LCnning, J.T.:1987,'Mass Terms and Quantifica-tion',"]},{"title":"Linguistics and Philosophy,","paragraphs":["10, 1-52.","Pereim, F.C.N. and D.H.D. Warren: 1980, 'Definite Clause Grammars for Language Analysis w A Survey of the Formalism and a Comparison with Augmented Transition Networks',"]},{"title":"Artificial Intelligence","paragraphs":["13, 231-278.","Roeper, R.:1983,'Semantics for Mass terms with Quantifiers',"]},{"title":"Nor.s,","paragraphs":["17, 251-265. Smullyan, R.M.: 1968,"]},{"title":"First-Order Logic,","paragraphs":["Springer, New York. - 211 -"]}]}