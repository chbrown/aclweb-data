{"sections":[{"title":"Generating Referring Expressions Involving Relations","paragraphs":["Robert Dale","Department of Artificial Intelligence","and Centre for Cognitive Science University of Edinburgh Edinburgh EH8 9LW","Scotland"]},{"title":"R. Dale~uk. ac. edinburgh Abstract","paragraphs":["In this paper, we review Dale's [1989] algorithm for determining the content of a referring expression. The algorithm, which only permits the use of one-place predicates, is revised and extended to deal with n-ary predicates. We investigate the problem of blocking 'recursion' in complex noun phrases and propose a solution in the context of our algorithm."]},{"title":"Introduction","paragraphs":["In very simple language generation systems, there is typically a one-to-one relationship between entities known to the system and the linguistic forms available for describing those entities; in effect, each entity has a canonical name. In such systems, deciding upon the form of reference required in a given context requires at most choosing be-twc(,n a pronoun and the canonical name. 1","As soon as a generation system has access to a knowledge base which contains richer knowledge about the entities in the domain, the system has to face the problem of deciding what particular properties of an entity should be used in describing it in a given context? Producing a description which includes all of the known properties of Lhe entity is likely to be both inefficient and","t~.Ve do not mean to imply, of course, that the decision as to whether or not to use a pronoun is simple.","2This problem exists quite independently of any considerations of the different perspectives that might be taken upon an entity, where, for examplep one entity can be viewed from the perspective of being a father, a bicyclist and a teacher, with separate clusters of properties in each case. Even if the system is restricted to a single perspective upon each entity (as almost all language generation systems are), in any sophisticated knowledge base there will still be more information available about the entity than it is sensible to include in a description. Nicholas Haddock","Hewlett Packard Laboratories","Filton Road Stoke Gifford Bristol Bsl2 6QZ","England"]},{"title":"njh@com, hp. hpl. hplb","paragraphs":["misleading.","The core of the problem is finding a way of describing the intended referent that distinguishes it from other potential referents with which it might be confused. We refer to this problem as the content determination task. In this paper, we point out some limitations in an earlier solution proposed in Dale [1988, 1989], and discuss the possibilites of extending this solution by in-corporating a use of constraints motivated by the work of Haddock [1987, 1988]."]},{"title":"Generating Referring Expressions","paragraphs":["The Principles of Reference Dale [1988, 1989] presents a solution to the content determination task which is motivated by three principles of refcrence. These are cssentinily Gricean conversational maxims rephrased from the perspective of generating referring expressions:","1. The principle of sensitivity states that the referring expression chosen should take account of the state af the hearer's knowledge.","2. The principle of adequacy states that the referring expression chosen should be sufficient to identify the intended referent.","3. The principle of efficiency states that the referring expression chosen should provide no more information than is necessary for the identification of the intended referent. The solution proposed in Dale [1988, 1989] focuses on the second and third of these principles of reference as constraints on the content determination task. 161 - Distinguishing Descriptions Other researchers (see, for example, [Davey 1978; Appclt 1985a]) have suggested that the process ol: determining the content of a referring expression should be governed by principles like those just described. Detailed algorithms for satisfying these requirements are rarely provided, however.","Suppose that we have a set of entities C (called the context set) such that C = {al,a2,...,an} and our task is to distinguish from this context set some intended referent r where r E C. Suppose, also, that each entity ak is described in the system's knowledge base by means of a set of propertics, pk~, Pk2, • • •, Pk,,.","In order to distinguish our intended referent r from the other entities in C, we need to find some set of properties which are together true of r, but of no other entity in C. 3 The linguistic realisation of this set of properties constitutes a distinguishing description (DD) of r with respect to the context C. A minimal distinguishing description is then the linguistic realisation of the smallest such set of properties. An Algorithm to Compute Distinguishing Descriptions I,eL Lr be the set of properties to be realised in our description; and let t~ be the set of propertics known to be true of our intended referent r (we assume that Dr is non-empty). The initial conditions are thus as follows: • C,. = {(all entities in the knowledge base)}; • Pr = {(all properties true of r)}; • In order to describe the intended referent r with respect to the context set Cr, we do the following: 1. Check Success if [Cr I = 1 then return Lr as a DD elseif Pr = 0 then return Lr as a non-DD else goto Step 2. \"2. Choose Property for each Pi E P~ do: Cr, ~-- C~ f3 {x]pi(x)} Chosen property is pj, where Crj is the small- (;st setf goto Step 3.","3A sirnilar approach is being pursued by Leavitt (personal communication) at CMU.","4In the terminology of Dale [1988, 1989], this is equivalent to finding the property with the greatest discriminatory power. . Extend Description (wrt the chosen pj) Lr *-- LrU {pj} P~ *-- Pr - {Pj} goto Step 1. If we have a distinguishing description, a definite determiner can be used, since the intended referent is described uniquely in context. If the result is:a non-distinguishing description, all is not lost: we can realise the description by means of a noun phrase of the form one of the Xs, where X is the realisation of the properties in Lr. 5 For simplicity, the remainder of this paper concentrates on the generation of distinguishing descriptions only; the extended algorithm presented later will simply fail if it is not possible to produce a DD.","The abstract process described above requires some slight modifications before it can be used effectively for noun phrase generation. In particular, we should note that, in noun phrases, the head noun typically appears even in cases where it does not have any discriminatory power. For example, suppose there are six entities on a table, all of which are cups although only one is red: we are then likely to describe that particular cup as as the red cup rather than simply the red or the red thing. Thus, in order to implement the above algorithm, we always first add to L that property of the entity that would typically be denoted by a head noun. ° In many cases, this means that no further properties need be added.","Note also that Step 2 of our algorithm is nondeterministic, in that several properties may independently yield a context set of the same minimal size. For simplicity, we assume that one of these equally viable properties is chosen at random. Some Problems There are some problems with the algorithm just described.","As Reiter [1990:139] has pointed out, the algorithm does not guarantee to find a minimal distinguishing description: this is equivalent to the minimal set cover problem and is thus intractable as stated.","Second, the mechanism doesn't necessarily produce a useful description: consider the example","SOne might be tempted to suggest that a straightforward indefinite, as in an X, could be used in such cases; this is typically not what people do, however.","SFor simplicity, we can assume that this is that property of the entity that would be denoted by what P~sch [1978] calls the entity's basic category. 162 - offered by Appelt [1985b:6], where a speaker tells a hearer (whom she has just met on the bus) which bus stop to get off at by saying Get off one stop before I do. This may be a uniquely identifying description of the intended referent, but it is of little use without a supplementary offer to indicate the stop; ultimately, we require some computational treatment of the Principle of Sensitivity here.","Third, as has been demonstrated by work in psycholinguistics (for a recent summary, see Levelt [1989:129-13d]), the algorithm does not represent what people seem to do when construct-ing a referring expression: in particular, people typically produce referring expressions which are redundant (over and above the inclusion of the head noun as discussed above). This fact can, of course, be taken to nullify the impact of the first problem described above.","We do not intend to address any of these problems in the present paper. Instead, we consider an extension of our basic algorithm to deal with relations, and focus on an orthogonal problem which besets any algorithm for generating DDS involving relations."]},{"title":"Relations and the Problem of 'Recursion'","paragraphs":["Suppose that our knowledge base consists of a set of facts, as follows:"]},{"title":"{cup(c]), cup(c2), cup(c3), bowl(bx), bowl(b2), table(t]), table(t2), floor(I] ), in(cl, bl),","paragraphs":["in(c2, b2), on(c3, fl), on(b], fl), on(b2, Q), on(t],fl),on(t~,fl)} Thus we have three cups, two bowls, two tables and a floor: Cup c] is in bowl bl, and bowl b] is on the floor, as are the tables and cup ca; and so on. The algorithm described above deals only with one-place predicates, and says nothing about using relations such as on(bl,fl) as part of a distinguishing description. How can we extend tile basic algorithm to handle relations? It turns out that this is not as simple as it might seem: problems arise because of the potential for infinite regress in the construction of the description.","A natural strategy to adopt for generating exprcssions with relations is that used by Appelt [1985a:108-112]. For example, to describe the entity c3, our planner might determine that the predicate to be realized in our referring expression is the abstraction Ax[cup(x)Aon(x, fl)], since this complex predicate is true of only one entity, namely ca. In Appelt's TELEGRAM, this results first in the choice of the head noun cup, followed by a recursive call to the planner to determine how fl should be described. The resulting noun phrase is then the cup on the floor.","In many cases this approach will do what is required. However, in certain situations, it will attempt to describe a referent in terms of itself and generate an infinite description.","For example, consider a very specific instance of the problem, which arises in a scenario of the kind discussed in Haddock [1987, 19881 from the perspective of interpretation. Such a scenario is characterised in the above knowledge base: we have two bowls and two tables, and one of the bowls is on one of the tables. Given this situa-tion, it is felicitous to refer to b~ as the bowl on the table. However, the use of the definite article in the embedded NP the table poses a problem for purely compositional approaches to interpretation, which would expect the embedded NP to refer uniquely in isolation.","Naturally, this same scenario will be problematic for a purely compositional approach to generation of the kind alluded to at the beginning of this section. Taken literally, this algorithm could generate an infinite NP, such as: z the bowl on the table which supports the bowl on the table which supports ...","Below, we present an algorithm for generating relational descriptions which deals with this specific instance of the problem of repetition. Haddock [1988] observes the problem can be solved by giving both determiners scope over the entire"]},{"title":"NP, thus: (3tx)(:l!y)bowl(m) A","paragraphs":["on(x, y)"]},{"title":"A table(y)","paragraphs":["In Haddock's model of interpretation, this treatment falls out of a scheme of incremental, left-to-right reference evaluation based on an incremental accumulation of constraints. Our generation algorithm follows Haddock [1988], and Mellish [1985], in using constraint-network consistency to determine the entities relating to a description (see Mackworth [1977]). This is not strictly necessary, since any evaluation procedure such as generate-and-test or backtracking, can produce the desired result; however, using network consistency provides a natural evolution of the existing algorithm, since this already models the problem in terms of incremental refinement of context sets.","?We Ignore the question of determiner choice in the present paper, and assume for simplicity that definite determiners are chosen here. - 163 - We conclude the paper by investigating the implications of our approach for the more general problem of recursive repetition."]},{"title":"A Constraint-Based Algorithm","paragraphs":["Data Structures We assume three global kinds of data structure.","1. The Referent Stack is a stack of referents we are trying to describe. Initially this stack is set to contain just the top-level referent: s [Describe(b2, x)] This means that the goal is to describe the referent b2 in terms of predicates over the variable X.","2. The Property Set for the intended referent r is the set of facts, or predications, in the knowledge base relating to r; we will notate this as Pr. For example, given the knowledge base introduced in the previous section, the floor fl has the following Property Set: PA = {floor(f1), on(e3,/1), on(b1,/1),"]},{"title":"on(tl, fl), on(t2, fl) }","paragraphs":["3. A Constraint Network N will be viewed abstractly as a pair consisting of (a) a set of constraints, which corresponds to our description L, and (b) the context sets for the variables mentioned in L. The following is an example of a constraint network, viewed in these terms:"]},{"title":"i.(x, u)}, {c: = {ca, = {bl, b2}])","paragraphs":["The Algorithm For brevity, our algorithm uses the notation"]},{"title":"N~p","paragraphs":["to signify the result of adding the constraint p to the network N. Whenever a constraint p is added to a network, assume the following actions occur: (a) p is added to the set of constraints L; and (b) the context sets for variables in L are refined until their values are consistent with the new constraint. 9 Assume that every variable is","~\\Ve represent the stack here as a list, with the top of the stack being the left-most item in the list.","9We do not address the degree of network consistency required by our algorithm. However, for the examples treated in this paper, a node and arc consistcncy algorithm, such as Mackworth's [1977] AC-3, will suffice. (Haddock [1991] investigates the sufficiency of such low-power techniques for noun phrase interpretation.) We assume that our algorithm handles constants as well as variables within constraints. initially associated with a context set containing all entities in the knowledge base. In addition, we use the notation"]},{"title":"It\\rip","paragraphs":["to signify the result of replacing every occurence of the constant r in p by the variable v. For instance, [c3\\x]on(c3,"]},{"title":"fl)","paragraphs":["= on(x, fl) The initial conditions are as follows: • Stack = [Describe(r,v)]"]},{"title":"• Pr = {(all facts true of r)}","paragraphs":["• N = ({}, [C. ="]},{"title":"{(all entities)}])","paragraphs":["Thus, initially there are no properties in L. As before, the problem of finding a description L in-volves three steps which are repeated until a successful description has been constructed:","1. We first check whether the description we have constructed so far is successful in picking out the intended referent.","2. If the description is not sufficient to pick out the intended referent, we choose the most useful fact that will contribute to the description.","3. We then extend the description with a constraint representing this fact, and add Describe goals for any constants relating to the constraint. The essential use of constraints occurs in Step 2 and 3; the detail of the revised algorithm is shown in Figure 1. An Example There is insufficient space to go through an example in detail here; however, we summarise some steps for the problematic case of referring to b2 as the"]},{"title":"the bowl on the table. 1°","paragraphs":["For simplicity here, we assume our algorithm will always choose the head category first. Thus, we have the following constraint network after one iteration through the algorithm: N = ({bowl(x)}, [Cx = {bl, b~}])","Let us suppose that the second iteration chooses on(b2, tl) as the predication with which to extend our description. When integrated into the constraint network, we have","l°Again, we ignore the question of determiner choice and assume definites are chosen. - 164 - Note that in Steps 1, 2 and 3, r and v relate to the current Describe(r, v) on top of the stack. 1. Check Success if Stack is empty then return L as a rOD elseif ICy] = 1 then pop Stack &goto Step 1 elseif Pr = ~ then [aft else goto Step 2 2. Choose Property for each propert,y Pi E P,- do","p' ~-[r\\,vb,","N, ,-- N (2)I\", ('bosch predicatiou is Pa, where Nj contains the smallest sew C,, for v. goto Step 3","3. I':xtcnd l)escriptio,~ (w.r.t. the chosen p) 1',. ~- 1'~ -"]},{"title":"{p} t, ,-[r\\~b","paragraphs":["for every t)thcr corlstant r' in p do associate r' with a new, unique variable v'"]},{"title":"~) ~-[/\\v'b","paragraphs":["push Describe('r', v') onto Stack initialisc a sct 1~, of facts true of r' :'V ,-- N • p goto Step 1 I,'igure 1: A Constraint-l{ased Algorithm I","1\\; = ({bowl(x),on(x, y)}, [C= = {b,,b,~},C~"]},{"title":"= {/1,h}])","paragraphs":["Note that the network has determined a set for g which does not include the second table t2 be-ca.llse it is not known to support anything.","(liven our head-category-first strategy, the third itcratiorl through the algorithm adds table(t1) as a coIistraint to N, to form l,h(; new network"]},{"title":"A' = ({ bowl(x), on(x, y), table(y)},","paragraphs":["[C, = {b~},C~ = {t,}]) Ahcr adding this new constraint, fl is eliminated I'rt)nl ~y. This leads to the revision of to Cx, which must remove every vahm which is not on Ii.","On the fourth iteration, we exit with the first corn p,ment of this network, L, as our description; w(: can then realize this content as the bowl on ll., lath'."]},{"title":"The Problem Revisited","paragraphs":["The task of referring to b2 in our knowledge base is something of a special case, and does not illustrate the nature of the general problem of recursion. Consider the task of referring to el. Due to the non-determinism in Step 2, our algorithm might either generate the DD corresponding to the cup in the bowl on the floor, or it might instead get into an infinite loop corresponding to the cup in the bowl containing the cup in the bowl containing ... The initial state of the referent slack and O's property set will be:","Stack = [Describe(cl,z)] P~ = {cup(o),in(cl,bi)} At the beginning of the fourth iteration the algorithm will have produced a partial description corresponding to the cup in the bowl, with the top-level goal to uniquely distinguish bl: Stack = [Describe(bt,y), Describe(ca,x)]"]},{"title":"Pc, = O","paragraphs":["Pb, = {in(o,bl),on(bl,fl)}"]},{"title":"N = ({cup(x),in(x,y),bowl(y)}, to= = {cl,o~},C~ = {b,,b~)])","paragraphs":["Step 2 of the fourth iteration computes two networks, for the two facts in Pb, : Nl = N ~in(o,y)"]},{"title":"= ({cup(x), in(x,y), bowl(y),in(cl, y)}, [c~ = {cx }, c~ = {b, }l)","paragraphs":["N2 = N ~on(y, fl)"]},{"title":"= ({cup(x), in(x, y), bowl(y), on(y, fl)}, [c=","paragraphs":["= {c,},c, = {b,}]> Since both networks yield singleton sets lbr Cu, the algorithm might choose the property in(el, bl). This means extending the current description with a constraint in(z,y), and stacking an additional commitment to describe cl in terms of the variable z. Hence at the end of the fourth iteration, the algorithm is in the state","Stack = [Oescribe(cl,z),Describe(bl,y), Describe(o, x)]"]},{"title":"P~,, = 0","paragraphs":["ebl ="]},{"title":"{on(bl, fl)}","paragraphs":["Pea. = {cup(o),in(cl,b,)}"]},{"title":"N = ({cup(x),in(x,y),bowl(y),in(z,y)}, [...])","paragraphs":["and may continue to loop in this manner.","The general problem of inlinite repetition has been noted before in the generation literature. For example, Novak [1988:83] suggests that - 165 - [i]f a two-place predicate is lined to generate the rc.~trictive relative clause, the second object of this predicate is characterized simply by its propcrties to avoid recursivc reference as in the car which was overtaken by the truck which overtook the car.","Davey [1979], on the other hand, introduces the notion of a CANLIST (the Currently Active Node List) for those entities which have already been mentioned in the noun phrase currently under construction. The generator is then prohibited from describing an cntity in tetras of entities already in the CANLIST.","in the general case, these proposals appear to b(: too strong. Davey's restriction would seem t.o b(: the weaker of the two, but if taken literally, it will nevertheless prevent legitimate cases of bound-variable anaphora within an NP, such as the mani who ale the cake which poisoned himi. We suggest the following, possibly more general heuristic: do not express a given piece of information more than once within the same NP. For our simplified representation of contextual knowlc.dgc, exernplified above, we could encode this heuristic by stipulating that any fact in the knowledge base can only be chosen once within a given call to the algorithm. So in the above example, once the relation in(el, bl) has been chosen from the initial set [~,--in order to constrain the variable x---it is no longer available as a viable contextual constraint to distinguish b~ later on. This heuristic will therefore block the infinite description of cl. But as desired, it will admit the bound-variable anaphora mentioned above, since this NP is not based on repeated inforrnation; the phrase it mcrcly self-referential."]},{"title":"Conclusion","paragraphs":["Wc have shown how tile referring expression generation algorithm presented in Dale [1988, 1989] can bc extended to encompass the use of relations, by making use of constraint network consistency. In the context of this revised generation procedure we have investigated the problem of blocking the production of infinitely recursive noun phrase, and suggested an improvement on some existing approaches to the problem. Areas lbr further research include the relationship of our approach to existing algorithms in other fields, such as machine learning, and also its relationship to observed characteristics of human discourse production."]},{"title":"Acknowledgements","paragraphs":["The work reported here • was prompted by a conversation with Breck Baldwin. Both authors would like to thank colleagues at each of their institutions for numerous comments that have improved this paper."]},{"title":"References","paragraphs":["Appelt, Douglas E [1985a] Planning English Sentences. Cambridge: Cambridge University Press.","Appelt, Douglas E [1985b] Planning English l~ferring Expressions. Artificial Intelligence, 26, 1-33.","Dale, Robert [1988] Generating Referring Expressions in a Domain of Objects and Processes. PhD The-sis, Centre for Cognitive Science, University of Edinburgh.","Dale, Robert [1989] Cooking up Iteferring Expressions. In Proceedings of the ~Tth Annual Meeting of the Association for Computational Linguistics, Vancouver BC, pp68-75.","Davey, Anthony [1978] Discourse Production. F_ziinburgh: Edinburgh University Press.","Haddock, Nicholas J [1987] Incremental Interpretation and Combinatory Categorial Grammar. In Proceedings of the Tenth International Joint Conference on Artificial Intelligence, Milan, Italy, pp.","Haddock, Nicholas J [1988] Incremental Semantics and Interactive Syntactic Processing. PhD Thesis, Centre for Cognitive Science, University of Edinburgh.","Haddock, Nicholas 3 [1991] Linear-Time Reference Evaluation. Technical Report, ttewlett Packard Laboratories, Bristol.","Levelt, Willem J M [1989] Speaking: b¥om Intention to Articulation. Cambridge, Mass.: MIT Press.","Mac&worth, Alan K [1977] Consistency in Networks of Relations. Artificial Intelligence, 8, 99-118.","Mellish, Christopher S [1985] Computer Interpretation of Natural Language Descriptions. Chichester: Ellis Horwood.","Novak, Hans-Joachim [1988] Generating Referring Phrases in a Dynamic Environment. Chapter 5 in M Zock and G Sabah (eds), Advances in Natural Language Generation, Volume 2, pp76--85. London: Pintcr Publishers.","Reiter, Ehud [1990] Generating Appropriate Natural Language Object Descriptions. PhD thesis, Aiken Computation Laboratory, Harvard University.","Rosch, Eleanor 11978] Principles of Categorization. In E Rosch and B Lloyd (eds), Cognition and Categorization, pp27--48. Hillsdale, N J: Lawrence Erlbaum Associates. 166 -"]}]}