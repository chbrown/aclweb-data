{"sections":[{"title":"An Extension of Earley's Algorithm for S-Attributed Grammars Nelson Correa","paragraphs":["Department of Electrical Engineering","Universidad de los Andes","Apartado A6reo 4976, Bogotti, D.E., Colombia"]},{"title":"bitnet","paragraphs":[": NCORREA at ANDESCOL Abstract Attribute grammars are an elegant formalization of the augmented context-free grammars characteristic of most current natural language systems. This paper presents an extension of Earley's algorithm to Knuth's attribute grammars, considering the case of S-attributed grammars. For this case, we study the conditions on the underlying base grammar under which the extended algorithm may be guaranteed to terminate."]},{"title":"Finite partitioning","paragraphs":["of attribute domains is proposed to guarantee the termination of the algorithm, without the need for any restrictions on the context-free base. 1. Introduction Earley's (1970) algorithm is a general algorithm for context-free languages, widely used in natural language processing (King, 1983; Shieber, 1985) and syntactic pattern recognition (Fu, 1982), where the full generative power of context-free grammar is required. The original algorithm and its common implementations, however, assume the atomic symbols of context-free grammars, thus limiting its applicability to systems with attributed symbols, or"]},{"title":"attribute grammars","paragraphs":["(Knuth, 1968). Attribute grammar is an elegant formalization of the augmented context-free grammars characteristic of most current NLP systems. It is more general than members of the family of unification-based grammar formalisms (Kay, 1985; Shieber, 1986), mainly in that it allows and encourages the use of simpler attribution functions than unification for the definition of attribute values, and hence can lead to"]},{"title":"computationally efficient","paragraphs":["grammatical definitions, while maintaining the advantages of a well-understood declarative formalism. Attribute grammar has been used in the past by the author to define computational models of Chomsky's Government-binding theory, from which practical parsing programs were developed (Correa, 1987a). Many systems based on Earley's algorithm have a clear division between the phases of syntactic and semantic analysis. Yellin (1988), for instance, uses a syntactic analysis phase in which Earley's algorithm builds a factored parse tree (FPT) for the given input, which is then followed by up to two phases of semantic analysis, during which the FPT is attributed and evaluated. Watt (1980) and Jones and Madsen (1980) propose a close interaction between syntactic and semantic analysis in the form of \"attribute-directed\" parsing. However, their particular realization of the technique is severely restricted for NLP applications, since it uses a deterministic one-path (LR) algorithm, applicable only to semantically unambiguous grammars. Pereira and Warren (1983) and Shieber (1985) present v6rsions of Earley's algorithm for unification grammars, in which unification is the sole operation responsible for attribute evaluation. However, given the high computational cost of unification, important differences between attribute and unification grammars in their respective attribution domains and functions (Correa, forthcoming), and the more general nature of attribute grammars in this regard, it is of interest to investigate the extension of Earley's algorithm directly to the main subclasses of attribute grammar. The paper is organized as follows: Section 2 presents pieliminary elements, including a definition of attribute grammar and Earley's algorithm. Section 3 presents the extension of the algorithm for S-attributed grammars. In Section 4, we consider the conditions on the underlying grammar under which the extended algorithm may be guaranteed to terminate for each input. For the S-attributed case we show that the algorithm terminates if the grammar has no cycles or, equivalently, if it is finitely ambiguous. However,"]},{"title":"finite partitioning","paragraphs":["of attribute domains may be used to guarantee the termination of the algorithm, without the need for restrictions on the context-free base. Finally, a conclusion and note on implementation are given. 2. Notation and Preliminaries We follow the usual notation and terminology for grammars and languages. A"]},{"title":"language","paragraphs":["is a set of strings o~,er a finite set T of symbols. A"]},{"title":"grammar","paragraphs":["is a formal device for specifying which strings are in the set. In particular, a"]},{"title":"context-free grammar","paragraphs":["is a cuadruple - 299 - (N, T, P, S), where N is a finite set of string categories; T a finite set of terminal symbols; P a finite set of productions or rewriting rules of the form X--~t~, Xe N, ae (NUT)*; and S a distinguished symbol of N. A binary relation ~ of derivation between strings over the vocalulary NuT of the grammar is defined such that aXl~ ~ ctol3 iff Xo o is a production of P; now, ~* may be defined as the reflexive and transitive closure of ~. The language generated by the grammar, noted L(G), is the set of strings toe T*, such that S ~* to. An attribute grammar is defined upon a context-free grammar G=(N, T, P, S), by associating each symbol Xe NuT with a finite set A(X) of attributes, and a type or domain dom(a) for each attribute a thus defined (Knuth, 1968). Each attribute a of X, noted X.a, takes values over its domain and represents a specific, possibly context-sensitive property of the symbol. Attribute values are defined by attribution rules of the form Xi.a~f(Xj.b ..... Xk.c), associated with each production p=Xo-~Xt...Xn in the grammar, 0<i,j,k<n. Here, f is an applicative expression (function) whose value depends on the values of attribute occurrences associated with symbols in the production. Each time p applies in a derivation, the attribution rule defines the value of the attribute occurrence X.a as a function of the occurrences Xj.b ..... Xk.c, associated with other symbols in p . We let R(p) denote the packet of attribution rules associated with p. The grammar may also define attribute conditions of the form B(Xi.a ..... Xk.b ), 0 < i, k < n, where B is a Boolean predicate on the values of attribute ocurrences in p. This condition must be satisfied in any derivation requiring the application of p, and thus contributes to the notion of grammaticality in the language generated by the grammar. We let B(p) denote the packet of attribute conditions associated with p. The above remarks are summarized as follows: An attribute grmmnar is a cuadruple AG=(G,A,R,B), where i. G = (N, T, P, S) is a context-free grammar; ii. A = L3Xe NuT A(X) is a finite set of attributes; iii. R= k..Jpe pR(p) is a finite set of attribution rules,","as above; and iv. B=L3pe p B(p) is a finite set of attribute conditions, as above. The base grammar G assigns a derivation tree x to each sentence in L(G). The tree is annotated at each node labelled X with the set A(X) of attributes associated with X; each attribute ae A(X) defines an attribute occurrence X.a at node X. If the grammar is well defined (Knuth, 1968), it is possible to evaluate each attribute occurrenc~ on the tree, and we say that • is correctly attributed iff all attribute conditions yield 'true.' The language generated by the attribute grammar, L(AG), is now the subset of L(G) whose members have at least one correctly attributed tree. It is possible to classify the attributes in AG according to the manner in which their values are defined. We say an attribute X.a is synthesized if its value depends only on attributes of daughters of X; it is inherited if its value depends on attributes associated with the parent or sisters of X. We say the grammar is S-attributed if it contains only synthesized attributes. A more general and practically important class of L-attributed grammars is obtained if we allow attributes of both kinds, but such that each inherited attribute depends only on inherited attributes of the parent, or attributes of the sisters to its left (Bochmann, 1976). Earley's algorithm is a recognizer for CFGs which uses top-down prediction in combination with bottom-up parsing actions. Given an input string Xl ..... Xn it builds a state set Si at each position i of the string, 0< i < n+l. Each state in Si is of the form <A--~a.l~, f, ~5>, where A---~a.~ is a dotted-production,f an index to the position in the input string where this instance of the production began to be recognized (0 < f < i), and 8 a string of k symbols of Iookahead (k >0). To begin, all state sets are initialized to empty and the initial state <¢~.S _1_, 0, _l_k> is put into SO; here _1_ is the end-of-input marker. States are processed in order according to the position of their \"dot\" following three actions, Predictor, Completer, and Scanner, while maintaining the following invariant: State < A---~a-13, f, ~5> is in Si iff the following derivations are valid: S ~* GA~ ; a ~* x ...xf; and ot ~* Xf+l...xi. Since the number of possible states is finite the algorithm terminates. The input string is accepted if Sn+I={<~---~S _1_., 0, .l_k>}. The correctness of this acceptance condition is a consequence of the invariant. 3. Extension to S-attributed Grammars The chief element of the extension of the algorithm is a change in the representation of the states in Earley's original algorithm to attributed representations. Now, each dotted production A~a*l~ in a state consists of symbols attributed according to the grammar. For each category symbol A in the base grammar, we define the attributed symbol A[A.al ..... A.an], where A is the category and A.ai, l<i<n, an attribute occurrence of A. The extended algorithm, in addition to syntactically recognizing the input string, evaluates the attribution associated with each of its possible derivations. In particular, for each derivation of the attributed final state - 300 - <¢-->S[ S.al ..... S.an] _1_., 0, ±k>, where S is the start symbol of the grammar and S.al ..... S.a n the attribute occurrences of S associated with that state, the algorithm evaluates the corresponding attribute occurrences. For an S-attributed grammar, this is achieved by the following modification of Earley's algorithm, in its Completer step: SO := { < ¢---)'SIS.al ..... S.anl±, O,"]},{"title":"£k>","paragraphs":["};","for i:= 1 rondo","begin For each state s in Si, repeat until no more states may be added to Si or Si+l begin"]},{"title":"1. Predictor","paragraphs":["If s = < A--->~-X[I, f, 8> (i.e., s is not final and X non-terminal)"]},{"title":"Si","paragraphs":[":= Si t..) { <x--~,o, i, B> I X-->c in P and It in FIRSTk(~8)}"]},{"title":"2. Completer","paragraphs":["If s = < A-)a., f, 8> (i,e., s is final) and 8 = Xi+l ... Xi+k a. Ae := eval s(A, ct, A->a) b. Si := Si w { < X--->aAe.13, k, It>l","<X-->a.AI3, k, It> in Sf }"]},{"title":"3. Scanner","paragraphs":["If s = < A-->a.Xi+ll3, f, 8> (i.e., s not final and Xi+l the next input symbol)","Si+l := Si+l t..) { < X--->aXi+l.~, f, 8> } end; If Si+l is empty, reject and terminate","end;","If <¢~S[S.al ..... S.an]_l_., 0, ±k> in Sn+l, accept.","Extension of Earley's Algorithm for S-attributed Grammars The states in the algorithm are attributed as indicated above. For example, the symbol A in the state <A--gao, f, 8> input to the Completer could be shown more explicitly as A=A[A.al ..... A.an]. As the state enters the completer, the attribute occurrences A.ai of A are unevaluated; however, since the grammar is S-attributed it is easy to show that the attribute occurrences on the right-hand side a of the production have already been evaluated. Hence, evaluation of the attribute occurrences of A reduces to application of the attribution associated with the production A->a, according to the attribute values in a. This is done by the function"]},{"title":"eval_s(A, ct, A---~ot),","paragraphs":["which returns the attributed symbol Ae, identical to A, except that its attribute occurrences have been evaluated, as required. The last state set generated by the algorithm contains final states of the form <¢-->S[ ...] .1_., 0, -l-k>, in which the attributed start symbol S[ ...] is already evaluated. Here the extended algorithm differs form Earley's; whereas the original algorithm generates at most one final state, regardless of the ambiguity of the underlying grammar, the extended algorithm may generate several instances of this state, if the grammar is ambiguous. Each instance of the final state corresponds to a different derivation of the initial symbol, leading to a different evaluation of the symbors attributes. 4. Finite Partitioning of Attribute Domains The last remark in the extension of section 3 shows a defect of the Extended Algorithm: It may not terminate in the general case. For the S-attributed case, however, this may happen only if the underlying grammar is ~nfinitely ambiguous or, equivalently, if it has"]},{"title":"cycles","paragraphs":["Or derivations of the form A~+A, for some A~ N. Consider, for example, the following grammar, which ,measures\" the length of each derivation of the sole string 'a' it generates: S--cA S.v <--- A.v A--~A A0.ve-- A 1.v +1 A-->a A.ve- 1 Given the input string 'a', the algorithm defines three attributted slate sets:","SO = {<¢~-->.S[v]_L, 0, _l_k>, <S[v]-->-A[ v], 0, .l_k>, <A[v]-->.a, 0, £k>, <A[ v]-->.A[v], 0, d-k> }","S 1 = {<A-->a., 0, ±k>, <S[v]--~A[ 1]., 0, £k>, <A[v]-->A[1 ]., 0, _l_k>. <~->S[ 1]-±, O, ±k> <S[v]-->A.[2], 0, j k>, <A[vl-->A[2]-, 0, j.k>,","ad infinitum ... }","$2 = {<¢-->S[ I]_L., 0, _Lk>, <¢-->S[2].L-, 0, ±k>,","ad infinitum ...} Since S1 is infinite, the algorithm does not terminate. Cyclic grammars play an important role in most recent linguistic theories, including Government-binding (GB), LexicaI-Functional Grammar (LFG) and GPSG (cf. Bcrwick, 1988; Con'ca, 1987b; Kornai and Pullum, 1990). These have in common that they have shifted from rule-based descriptions of language, to declarative orprinciple-based descriptions, in which the role of phrase structure rules or principles is relatively minor. Thus, to make the extension of the algorithm useful for natural language applications it becomes necessary to ensure its termination, in spite of cyclic bases. - 301 - The termination of the Extended Algorithm may be guaranteed while maintaining its full generality, through"]},{"title":"a finite partition","paragraphs":["on the attribute domains associated with each cyclic symbol in the grammar. For each such domain"]},{"title":"dom (a),","paragraphs":["the partition defines a finite collection of equivalence classes on attribute values. Now, before adding a new state <A--~a'l~, f, ~i> to a state set Si, we test for"]},{"title":"equivalence","paragraphs":["(according to the defined partitions) rather than equality to some previously added state; if the new state is equivalent to some other, it is not added. It is easy to show that the number of attributed dotted items in the grammar, and hence the size of the state sets, is now finite. This number is in fact identical to that of Earley's algorithm, except for a constant multiplicative factor, dependent on the grammar and the size of the partitions selected for attribute domains. Since the size of the state sets possible with finite partitioning is now finite, the algorithm always terminates. After establishing a correspondence between attribute and unification grammar (UG), we may see that the technique of \"restriction\" used by Shieber (1985) in his extended algorithm is related to finite partitioning on attribute domains, in fact a particular case which takes advantage of the more structured attribute domains of UG. For attribute grammar, given that the domains involved are more general (e.g., the integers), finite partitioning is the required device. 5. Conclusions and Implementalion Status This paper presented and extension of Earley's algorithm to S-attributed grammars. Combining on-line semantic evaluation with the execution of syntactic actions, the algorithm is an effective realization of attribute-directed parsing, as proposed by Watt (1980) and Jones and Madsen (1980). Although the algorithm is a recognizer, it computes the semantic values associated with each derivation of the input string, and hence need not be extended to compute tree representations. In attribute grammars with conditions on productions, the values of attributes already evaluated unay be used to guide the parsing process, reducing the number of states! that may be generated by the algorithm. The extension of the algorithm has been written in \"C\", using an efficient \"C\" implementation of Earley's original algorithm (Chamorro and Correa, 1990), and is currently being tested on small grammars. The extended algorithm will be the kernel of ANDES-l, a programming environment for attribute grammars, intended for natural language applications. References Berwick, Robert. 1988. \"Principlerbased Parsing\". MIT A.I. Memo 972, revised. MIT, Cambridge, MA. Bochmann, Gregor. 1976. \"Semantic Evaluation from Left to Right.\""]},{"title":"Communications of the ACM","paragraphs":[", Vol. 19, No. 2, p. 55-62. Chamorro, Miriam, and N. Correa. 1990. \"An Efficient 'C' Implementation of Earley's Algorithm\" - in Spanish. CIFI, Universidad de los Andes, Bogot,5, Colombia. Correa, Nelson. 1987a. \"An Attribute Grammar Implementation of Government-binding Theory.\""]},{"title":"Proceedings of the 25th Annual Meeting of the ACL,","paragraphs":["Stanford University, Stanford, CA. Correa, Nelson. 1987b. \"Empty Categories, Chain Binding, and Parsing.\" Parsing Seminar;"]},{"title":"MIT Working Papers of the Lexicon Project,","paragraphs":["MIT, Cambridge, MA. Correa, Nelson. Forthcoming. Attribute and Unification Grammar: A Review of Formalisms and Comparision. CIFI, Universidad de los Andes. Earley, Jay. 1970. \"An Efficient Context-free Parsing Algorithm.\""]},{"title":"Communications of the ACM","paragraphs":[", VoL 13, No. 2, p. 94-102. Fu, K.S. 1982."]},{"title":"Syntactic Pattern Recognition.","paragraphs":["Academic Press, New York. Jones, Neii D., and M. Madsen. 1980. \"Attribute Influenced LR Parsing.\" In N. D. Jones, ed.,"]},{"title":"Semantics-directed Compiler Generation","paragraphs":[", LNCS 94. Springer-Verlag, New York. Kay, Martin. 1985. Parsing in Functional Unification Grammar. In D. Dowty, L. Karttunen, and A. Zwicky,"]},{"title":"eds., Natural Language Parsing,","paragraphs":["Cambridge University Press, Cambridge, England. King, Margaret, ed. 1983."]},{"title":"Natural Language Parsing.","paragraphs":["Academic Press, New York. : Knuth, Donald. 1968. \"Semantics of Context-free Languages.\" Mathematical Systems Theory, Vol. 2, No. 2, p. 127-145. Kornai, Andras, and G. Puilum, 1990. \"The X-bar Theory of Phrase Structure.\" Language, Vol. 66. Pereira, Fernando, and D. H. Warren. 1983. \"Parsing as Deduction.\""]},{"title":"Proceedings of the 21st Annual Meeting of the ACL ,","paragraphs":["MIT, Cambridge, MA. Shieber, Stuart. 1985. \"Using Restriction to Extend Parsing Algorithms for Complex-Feature-Based Formalisms.\""]},{"title":"Proceedings of the 23rd Annual Meeting of the ACL,","paragraphs":["University of Chicago, Chicago, IL. Shieber, Stuart. 1986."]},{"title":"An Introduction to Unification Based Approaches to Grammar.","paragraphs":["CSLI Lecture Notes No. 4, Stanford, CA. Watt, David. 1980. \"Rule Splitting and Attribute Directed Parsing.\" In N.D.Jones, ed.,"]},{"title":"Semantics-directed Compiler Generation,","paragraphs":["LNCS 94. Springer-Verlag, NY. Yellin, Daniel. 1988. \"Generalized Attributed Parsing.\" Manuscript; IBM Research, Yorktown Heights, NY. - 302 -"]}]}